
   Thinking In C++. Volume 2: Practical Programming
   To all those who have worked tirelessly on the development of the C++ language
   Preface
   In Volume 1 of this book, you learn the fundamentals of C and C++. In this volume, we look at more advanced features, with an eye towards developing techniques and ideas that produce robust C++ programs.
   Thus, in this volume we are assuming that you are familiar with the material developed in Volume 1.
   Goals
   Our goals in this book are to:.
   1. Present the material a simple step at a time, so the reader can easily digest each concept before moving on.
   2. Teach«practical programming» techniques that you can use on a day-to-day basis.
   3. Give you what we think is important for you to understand about the language, rather than everything we know. We believe there is an«information importance hierarchy,» and there are some facts that 95% of programmers will never need to know, but that would just confuse people and add to their perception of the complexity of the language. To take an example from C, if you memorize the operator precedence table (we never did) you can write clever code. But ifyou have to think about it, it will confuse the reader/maintainer of that code. So forget about precedence, and use parentheses when things aren’t clear. This same attitude will be taken with some information in the C++ language, which is more important for compiler writers than for programmers.
   4. Keep each section focused enough so the lecture time—and the time between exercise periods—is small. Not only does this keep the audience’ minds more active and involved during a hands-on seminar, but it gives the reader a greater sense of accomplishment.
   5. We have endeavored not to use any particular vendor’s version of C++. We have tested the code on all the implementations we could, and when one implementation absolutely refused to work because it doesn’t conform to the C++ Standard, we’ve flagged that fact in the example (you’ll see the flags in the source code) to exclude it from the build process.
   6. Automate the compiling and testing of the code in the book. We have discovered that code that isn’t compiled and tested is probably broken, so in this volume we’ve instrumented the examples with test code. In addition, the code that you can download from http://www.MindView.net has been extracted directly from the text of the book using programs that also automatically create makefiles to compile and run the tests. This way we know that the code in the book is correct.
   Chapters
   Here is a brief description of the chapters contained in this book:
   Part 1: Building Stable Systems
   1. Exception handling. Error handling has always been a problem in programming. Even if you dutifully return error information or set a flag, the function caller may simply ignore it. Exception handling is a primary feature in C++ that solves this problem by allowing you to«throw» an object out of your function when a critical error happens. You throw different types of objects for different errors, and the function caller «catches» these objects in separate error handling routines. If you throw an exception, it cannot be ignored, so you can guarantee thatsomething will happen in response to your error. The decision to use exceptions (a good one!) affects code design in fundamental ways.
   2. Defensive Programming. Many software problems can be prevented. To program defensively is to craft code in such a way that bugs can be found and fixed early before they have a chance to do damage in the field. The use of assertions is the single most important thing you can do to validate your code during development, while at the same time leaving an executable documentation trail in your code that reveals what you were thinking when you wrote the code in the first place. Before you let your code out of your hands it should be rigorously tested. A framework for automated unit testing is an indispensable tool for successful, everyday software development.
   Part 2: The Standard C++ Library
   3. Strings in Depth. Text processing is the most common programming activity by far. The C++ string class relieves the programmer from memory management issues, while at the same time delivering a powerhouse of text processing capability. C++ also supports the use of wide characters and locales for internationalized applications.
    4. Iostreams. One of the original C++ libraries—the one that provides the essential I/O facility—is called iostreams. Iostreams is intended to replace C’sstdio.hwith an I/O library that is easier to use, more flexible, and extensible—you can adapt it to work with your new classes. This chapter teaches you the ins and outs of how to make the best use of the existing iostream library for standard I/O, file I/O, and in-memory formatting.
   5. Templates in Depth. The distinguishing feature of«modern C++» is the broad power of templates. Templates are for more than just generic containers; they support development of robust, generic, high-performance libraries. There is a lot to know about templates—they constitute, as it were, a sub-language within the C++ language, and give the programmer an impressive degree of control over the compilation process. It is not an understatement to say that templates have revolutionized C++ programming.
   6. Generic Algorithms. Algorithms are at the core of computing, and C++, through its template facility, supports an impressive entourage of powerful, efficient, and easy-to-use generic algorithms. The standard algorithms are also customizable through function objects. This chapter looks at every algorithm in the library. (Chapters 6 and 7 cover that portion of the standard C++ library commonly-known as the Standard Template Library, or STL.)
   7. Generic Containers& Iterators. C++ supports all the common data structures known to man in a type-safe manner. You never have to worry about what such a container holds; the homogeneity of its objects is guaranteed. Separating the traversing of a container from the container itself, another accomplishment of templates, is made possible through iterators. This ingenious arrangement allows a flexible application of algorithms to containers by means of the simplest of designs.
   Part 3: Special Topics
   8. Run-time type identification. Run-time type identification (RTTI) lets you find the exact type of an object when you only have a pointer or reference to the base type. Normally, you’ll want to intentionally ignore the exact type of an object and let the virtual function mechanism implement the correct behavior for that type. But occasionally (like when writing software tools such as debuggers) it is helpful to know the exact type of an object for which you only have a base pointer; often this information allows you to perform a special-case operation more efficiently. This chapter explains what RTTI is for and how to use it.
   9. Multiple inheritance. This sounds simple at first: A new class is inherited from more than one existing class. However, you can end up with ambiguities and multiple copies of base-class objects. That problem is solved with virtual base classes, but the bigger issue remains: When do you use it? Multiple inheritance is only essential when you need to manipulate an object through more than one common base class. This chapter explains the syntax for multiple inheritance, and shows alternative approaches—in particular, how templates solve one common problem. The use of multiple inheritance to repair a «damaged» class interface is demonstrated as a genuinely valuable use of this feature.
   10. Design Patterns. The most revolutionary advance in programming since objects is the introduction ofdesign patterns. A design pattern is a language-independent codification of a solution to a common programming problem, expressed in such a way that it can apply to many contexts. Patterns such as Singleton, Factory Method, and Visitor now find their way into daily discussions around the keyboard. This chapter shows how to implement and use some of the more useful design patterns in C++.
   11. Concurrent Programming. Users have long been used to responsive user interfaces that (seem to) process multiple tasks simultaneously. Modern operating systems allow processes to have multiple threads that share the process address space. Multi-threaded programming requires a different mindset, however, and comes with its own set of«gotchas.» This chapter uses a freely available library (the ZThread library by Eric Crahen of IBM) to show how to effectively manage multi-threaded applications in C++.
   Exercises
   We have discovered that simple exercises are exceptionally useful during a seminar to complete a student’s understanding, so you’ll find a set at the end of each chapter.
   These are fairly simple, so they can be finished in a reasonable amount of time in a classroom situation while the instructor observes, making sure all the students are absorbing the material. Some exercises are a bit more challenging to keep advanced students entertained. They’re all designed to be solved in a short time and are only there to test and polish your knowledge rather than present major challenges (presumably, you’ll find those on your own—or more likely they’ll find you).
   Exercise solutions
   Solutions to exercises can be found in the electronic documentThe C++ Annotated Solution Guide, Volume 2, available for a nominal fee fromwww.MindView.net.
   Source code
   The source code for this book is copyrighted freeware, distributed via the web site http://www.MindView.net. The copyright prevents you from republishing the code in print media without permission.
   In the starting directory where you unpacked the code you will find the following copyright notice:.
   //:! :CopyRight.txt
   Copyright (c) MindView, Inc., 2003
   Source code file from the book
   «Thinking in C++, 2nd Edition, Volume 2.»
   All rights reserved EXCEPT as allowed by the
   following statements: You can freely use this file
   for your own work (personal or commercial),
   including modifications and distribution in
   executable form only. Permission is granted to use
   this file in classroom situations, including its
   use in presentation materials, as long as the book
   «Thinking in C++» is cited as the source.
   Except in classroom situations, you cannot copy
   and distribute this code; instead, the sole
   distribution point is http://www.MindView.net
   (and official mirror sites) where it is
   freely available. You cannot remove this
   copyright and notice. You cannot distribute
   modified versions of the source code in this
   package. You cannot use this file in printed
   media without the express permission of the
   author. The authors makes no representation about
   the suitability of this software for any purpose.
   It is provided«as is» without express or implied
   warranty of any kind, including any implied
   warranty of merchantability, fitness for a
   particular purpose or non-infringement. The entire
   risk as to the quality and performance of the
   software is with you. The authors and publisher shall not be liable for any damages suffered by you or any third party as a result of using or distributing software. In no event will the authors or the publisher be liable for any
   lost revenue, profit, or data, or for direct,
   indirect, special, consequential, incidental, or
   punitive damages, however caused and regardless of
   the theory of liability, arising out of the use of
   or inability to use software, even if Bruce Eckel
   and the publisher have been advised of the
   possibility of such damages. Should the software
   prove defective, you assume the cost of all
   necessary servicing, repair, or correction. If you
   think you've found an error, please submit the
   correction using the form you will find at
   www.MindView.net. (Please use the same
   form for non-code errors found in the book.)
   ///:~

   You may use the code in your projects and in the classroom as long as the copyright notice is retained.
   Language standards
   Throughout this book, when referring to conformance to the ANSI/ISO C standard, we will be referring to the 1989 standard, and will generally just say‘C.’ Only if it is necessary to distinguish between Standard 1989 C and older, pre-Standard versions of C will we make the distinction. We do not reference C99 in this book.
   As this book goes to press the ANSI/ISO C++ committee has long ago finished working on the first C++ standard, commonly known as C++98. We will use the termStandard C++ to refer to this standardized language. If we simply refer to C++, assume we mean«Standard C++.» The C++ standards committee continues to address issues important to the C++ community that will find expression in C++0x, a future C++ standard not likely to be available for many years.
   Language support
   Your compiler may not support all the features discussed in this book, especially if you don’t have the newest version of your compiler. Implementing a language like C++ is a Herculean task, and you can expect that the features will appear in pieces rather than all at once. But if you attempt one of the examples in the book and get a lot of errors from the compiler, it’s not necessarily a bug in the code or the compiler—it may simply not be implemented in your particular compiler yet. On the Windows platform we have validated all examples with the C++ compiler found in Microsoft’s Visual Studio .NET 2003; Borland C++ Builder version 6; the GNU projects g++ compiler, version 3.2, running under Cygwin; and the Edison Design Group’s C++ front end using the Dinkumware full C++ library. We have also run all the examples on Mac OS X with Metrowerks C++ version 8. In those instances where a compiler does not support the feature required by a sample program, we have so indicated in comments in the source code.
   Seminars, CD-ROMs& consulting
   Bruce Eckel’s company, MindView, Inc., provides public hands-on training seminars based on the material in this book, and also for advanced topics. Selected material from each chapter represents a lesson, which is followed by a monitored exercise period so each student receives personal attention. We also provide on-site training, consulting, mentoring, and design& code walkthroughs. Information and sign-up forms for upcoming seminars and other contact information can be found athttp://www.MindView.net.
   Errors
   No matter how many tricks a writer uses to detect errors, some always creep in and these often leap off the page for a fresh reader. If you discover anything you believe to be an error, please use the feedback system built into the electronic version of this book, which you will find athttp://www.MindView.net. The feedback system uses unique identifiers on the paragraphs in the book, so click on the identifier next to the paragraph that you wish to comment on. Your help is appreciated.
   About the cover
   The cover artwork was painted by Larry O’Brien’s wife, Tina Jensen (yes, the Larry O’Brien who was the editor of Software Development Magazine for so many years). Not only are the pictures beautiful, but they are excellent suggestions of polymorphism. The idea for using these images came from Daniel Will-Harris, the cover designer (www.Will-Harris.com), working with Bruce Eckel.
   Acknowledgements
   Volume 2 of this book languished in a half-completed state for a long time while Bruce got distracted with other things, notably Java, Design Patterns and especially Python (see www.Python.org). If Chuck hadn’t been willing (foolishly, he has sometimes thought) to finish the other half and bring things up-to-date, this book almost certainly wouldn’t have happened. There aren’t that many people whom Bruce would have felt comfortable entrusting this book to. Chuck’s penchant for precision, correctness and clear explanation is what has made this book as good as it is.
   Jamie King acted as an intern under Chuck’s direction during the completion of this book. He was instrumental in making sure the book got finished, not only by providing feedback for Chuck, but especially because of his relentless questioning and picking of every single possible nit that he didn’t completely understand. If your questions are answered by this book, it’s probably because Jamie asked them first. Jamie also enhanced a number of the sample programs and created many of the exercises at the end of each chapter.
   Eric Crahen of IBM was instrumental in the completion of Chapter 11 (Concurrent Programming). When we were looking for a threads package, we sought out one that was intuitive and easy to use, while being sufficiently robust to do the job. With Eric we got that and then some—he was extremely cooperative and has used our feedback to enhance his library, while we have benefited from his insights as well.
   We are grateful to have had Pete Becker as a technical editor. Few people are as articulate and discriminating as Pete, not to mention as expert in C++ and software development in general. We also thank Bjorn Karlsson for his gracious and timely technical assistance as he reviewed the entire manuscript with little notice.
   The ideas and understanding in this book have come from many other sources, as well: friends like Andrea Provaglio, Dan Saks, Scott Meyers, Charles Petzold, and Michael Wilk; pioneers of the language like Bjarne Stroustrup, Andrew Koenig, and Rob Murray; members of the C++ Standards Committee like Nathan Myers (who was particularly helpful and generous with his insights), Herb Sutter, PJ Plauger, Pete Becker, Kevlin Henney, David Abrahams, Tom Plum, Reg Charney, Tom Penello, Sam Druker, and Uwe Steinmueller, John Spicer, Steve Adamczyk, and Daveed Vandevoorde; people who have spoken in the C++ track at the Software Development Conference (which Bruce created and developed, and Chuck spoke in); and often students in seminars, who ask the questions we need to hear to make the material clearer.
   The book design, cover design, and cover photo were created by Bruce’s friend Daniel Will-Harris, noted author and designer, who used to play with rub-on letters in junior high school while he awaited the invention of computers and desktop publishing. However, we produced the camera-ready pages ourselves, so the typesetting errors are ours. Microsoft® Word XP was used to write the book and to create camera-ready pages. The body typeface is Georgia and the headlines are in Verdana. The code type face is Andale Mono.
   We also wish to thank the generous professionals at the Edison Design Group and Dinkumware, Ltd., for giving us complimentary copies of their compiler and library (respectively). Without their assistance some of the examples in this book could not have been tested. We also wish to thank Howard Hinnant and the folks at Metrowerks for a copy of their compiler, and Sandy Smith and the folks at SlickEdit for keeping Chuck supplied with a world-class editing environment for so many years. Greg Comeau also provided a copy of his successful EDG-based compiler, Comeau C++.
   A special thanks to all our teachers, and all our students (who are our teachers as well).
   Evan Cofsky (Evan@TheUnixMan.com) provided all sorts of assistance on the server as well as development of programs in his now-favorite language, Python. Sharlynn Cobaugh and Paula Steuer were instrumental assistants, preventing Bruce from being washed away in a flood of projects.
   Dawn McGee provided much-appreciated inspiration and enthusiasm during this project. The supporting cast of friends includes, but is not limited to: Mark Western, Gen Kiyooka, Kraig Brockschmidt, Zack Urlocker, Andrew Binstock, Neil Rubenking, Steve Sinofsky, JD Hildebrandt, Brian McElhinney, Brinkley Barr, Bill Gates at Midnight Engineering Magazine, Larry Constantine & Lucy Lockwood, Tom Keffer, Greg Perry, Dan Putterman, Christi Westphal, Gene Wang, Dave Mayer, David Intersimone, Claire Sawyers, The Italians (Andrea Provaglio, Laura Fallai, Marco Cantu, Michael Seaver, Huston Franklin, David Wagstaff, Corrado, Ilsa and Christina Giustozzi), Chris& Laura Strand, The Almquists, Brad Jerbic, John Kruth& Marilyn Cvitanic, Holly Payne (yes, the famous novelist!), Mark Mabry, The Robbins Families, The Moelter Families (& the McMillans), The Wilks, Dave Stoner, Laurie Adams, The Cranstons, Larry Fogg, Mike& Karen Sequeira, Gary Entsminger& Allison Brody, Chester Andersen, Joe Lordi, Dave& Brenda Bartlett, The Rentschlers, The Sudeks, Lynn& Todd, and their families. And of course, Mom& Dad, Sandy, James& Natalie, Kim& Jared, Isaac, and Abbi.
   Part 1.Building Stable Systems

   Software engineers spend about as much time validating code as they do creating it. Quality is or should be the goal of every programmer, and one can go a long way towards that goal by eliminating problems before they rear their ugly heads. In addition, software systems should be robust enough to behave reasonably in the presence of unforeseen environmental problems.
   Exception handling was introduced into C++ to support sophisticated error handling without cluttering code with an inordinate amount of error-handling logic. Chapter 1 shows how proper use of exceptions can make for well-behaved software, and also introduces the design principles that underlie exception-safe code. In Chapter 2 we cover unit testing and debugging techniques intended to maximize code quality long before it’s released. The use of assertions to express and enforce program invariants is a sure sign of an experienced software engineer. We also introduce a simple framework to help mitigate the tedium of unit testing.
   1: Exception handling
   Improving error recovery is one of the most powerful ways you can increase the robustness of your code.
   Unfortunately, it’s almost accepted practice to ignore error conditions, as if we’re in a state of denial about errors. One reason, no doubt, is the tediousness and code bloat of checking for many errors. For example,printf( ) returns the number of characters that were successfully printed, but virtually no one checks this value. The proliferation of code alone would be disgusting, not to mention the difficulty it would add in reading the code.
   The problem with C’s approach to error handling could be thought of as coupling—the user of a function must tie the error-handling code so closely to that function that it becomes too ungainly and awkward to use.
   One of the major features in C++ isexception handling, which is a better way of thinking about and handling errors. With exception handling the following statements apply:.
   1.Error-handling code is not nearly so tedious to write, and it doesn't become mixed up with your«normal» code. You write the code youwant to happen; later in a separate section you write the code to cope with the problems. If you make multiple calls to a function, you handle the errors from that function once, in one place.
   2.Errors cannot be ignored. If a function needs to send an error message to the caller of that function, it«throws» an object representing that error out of the function. If the caller doesn’t «catch» the error and handle it, it goes to the next enclosing dynamic scope, and so on until the error is either caught or the program terminates because there was no handler to catch that type of exception.
   This chapter examines C’s approach to error handling (such as it is), discusses why it did not work well for C, and explains why it won’t work at all for C++. This chapter also coverstry,throw, andcatch, the C++ keywords that support exception handling.
   Traditional error handling
   In most of the examples in these volumes, we useassert( ) as it was intended: for debugging during development with code that can be disabled with#define NDEBUG for the shipping product. Runtime error checking uses therequire.h functions (assure( ) andrequire( )) developed in Chapter 9 in Volume 1. These functions are a convenient way to say,«There’s a problem here you’ll probably want to handle with some more sophisticated code, but you don’t need to be distracted by it in this example.» Therequire.h functions might be enough for small programs, but for complicated products you might need to write more sophisticated error-handling code.
   Error handling  quite straightforward in situations in which you know exactly what to do because you have all the necessary information in that context. Of course, you just handle the error at that point.
   The problem occurs when youdon’t have enough information in that context, and you need to pass the error information into a different context where that information does exist. In C, you can handle this situation using three approaches:.
   1.Return error information from the function or, if the return value cannot be used this way, set a global error condition flag. (Standard C provideserrno andperror( ) to support this.) As mentioned earlier, the programmer is likely to ignore the error information because tedious and obfuscating error checking must occur with each function call. In addition, returning from a function that hits an exceptional condition might not make sense.
   2.Use the little-known Standard C library signal-handling system, implemented with thesignal( ) function (to determine what happens when the event occurs) andraise( ) (to generate an event). Again, this approach involves high coupling because it requires the user of any library that generates signals to understand and install the appropriate signal-handling mechanism; also in large projects the signal numbers from different libraries might clash.
   3.Use thenonlocal goto functions in the Standard C library:setjmp( ) andlongjmp( ). Withsetjmp( ) you save a known good state in the program, and if you get into trouble,longjmp( ) will restore that state. Again, there is high coupling between the place where the state is stored and the place where the error occurs.
   When considering error-handling schemes with C++, there’s an additional critical problem: The C techniques of signals andsetjmp( )/longjmp( ) do not call destructors, so objects aren’t properly cleaned up. (In fact, iflongjmp( ) jumps past the end of a scope where destructors should be called, the behavior of the program is undefined.) This makes it virtually impossible to effectively recover from an exceptional condition because you’ll always leave objects behind that haven’t been cleaned up and that can no longer be accessed. The following example demonstrates this withsetjmp/longjmp:.
   //: C01:Nonlocal.cpp
   // setjmp()& longjmp()
   #include&lt;iostream&gt;
   #include&lt;csetjmp&gt;
   using namespace std;

   class Rainbow {
   public:
     Rainbow() { cout&lt;&lt;«Rainbow()»&lt;&lt; endl; }
     ~Rainbow() { cout&lt;&lt;«~Rainbow()»&lt;&lt; endl; }
   };

   jmp_buf kansas;

   void oz() {
     Rainbow rb;
     for(int i = 0; i&lt; 3; i++)
       cout&lt;&lt;«there's no place like home\n»;
     longjmp(kansas, 47);
   }

   int main() {
     if(setjmp(kansas) == 0) {
       cout&lt;&lt;«tornado, witch, munchkins...\n»;
       oz();
     } else {
       cout&lt;&lt;«Auntie Em! "
           &lt;&lt; "I had the strangest dream..."
           &lt;&lt; endl;
     }
   } ///:~

   Thesetjmp( ) function is odd because if you call it directly, it stores all the relevant information about the current processor state (such as the contents of the instruction pointer and runtime stack pointer) in thejmp_buf and returns zero. In this case it behaves like an ordinary function. However, if you calllongjmp( ) using the samejmp_buf, it’s as if you’re returning fromsetjmp( ) again—you pop right out the back end of thesetjmp( ). This time, the value returned is the second argument tolongjmp( ), so you can detect that you’re actually coming back from alongjmp( ). You can imagine that with many differentjmp_bufs, you could pop around to many different places in the program. The difference between a localgoto (with a label) and this nonlocal goto is that you can return to any pre-determined location higher up in the runtime stack withsetjmp( )/longjmp( ) (wherever you’ve placed a call tosetjmp( )).
   The problem in C++ is thatlongjmp( ) doesn’t respect objects; in particular it doesn’t call destructors when it jumps out of a scope.[1] Destructor calls are essential, so this approach won’t work with C++. In fact, the C++ standard states that branching into a scope withgoto (effectively bypassing constructor calls), or branching out of a scope withlongjmp( ) where an object on the stack has a destructor, constitutes undefined behavior.
   Throwing an exception
   If you encounter an exceptional situation in your code—that is, one in which you don’t have enough information in the current context to decide what to do—you can send information about the error into a larger context by creating an object that contains that information and "throwing" it out of your current context. This is calledthrowing an exception. Here’s what it looks like:.
   //: C01:MyError.cpp
   class MyError {
      const char* const data;
   public:
      MyError(const char* const msg = 0) : data (msg) {}
   };

   void f() {
      // Here we "throw" an exception object:
      throw MyError("something bad happened");
   }

   int main() {
      // As you’ll see shortly,
      // we’ll want a "try block" here:
      f();
   } ///:~

   MyError is an ordinary class, which in this case takes achar* as a constructor argument. You can use any type when you throw (including built-in types), but usually you’ll create special classes for throwing exceptions.
   The keywordthrow causes a number of relatively magical things to happen. First, it creates a copy of the object you’re throwing and, in effect, "returns" it from the function containing the throw expression, even though that object type isn’t normally what the function is designed to return. A naive way to think about exception handling is as an alternate return mechanism (although you find you can get intotrouble if you take the analogy too far). You can also exit from ordinary scopes by throwing an exception. In any case, a value is returned, and the function or scope exits.
   Any similarity to function returns ends there becausewhere you return is some place completely different from where a normal function call returns. (You end up in an appropriate part of the code—called an exception handler—that might be far removed from where the exception was thrown.) In addition, any local objects created by the time the exception occurs are destroyed. This automatic cleanup of local objects is often called "stack unwinding.".
   In addition, you can throw as many different types of objects as you want. Typically, you’ll throw a different type for each category of error. The idea is to store the information in the object and in thename of its class so that someone in a calling context can figure out what to do with your exception.
   Catching an exception
   As mentioned earlier, one of the advantages of C++ exception handling is that it allows you to concentrate on the problem you’re actually trying to solve in one place, and then deal with the errors from that code in another place.
   The try block
   If you’re inside a function and you throw an exception (or a called function throws an exception), the function exits in the process of throwing. If you don’t want athrowto leave a function, you can set up a special block within the function where you try to solve your actual programming problem (and potentially generate exceptions). This block is called thetry block because you try your various function calls there. The try block is an ordinary scope, preceded by the keywordtry:.
   try {
     // Code that may generate exceptions
   }

   If you check for errors by carefully examining the return codes from the functions you use, you need to surround every function call with setup and test code, even if you call the same function several times. With exception handling, you put everything in atry block and handle exceptions after thetry block. Thus, your code is a lot easier to write and easier to read because the goal of the code is not confused with the error checking.
   Exception handlers
   Of course, the thrown exception must end up some place. This place is theexception handler, and you need one exception handler for every exception type you want to catch. Exception handlers immediately follow thetry block and are denoted by the keywordcatch:.
   try {
     // Code that may generate exceptions
   } catch(type1 id1) {
     // Handle exceptions of type1
   } catch(type2 id2) {
     // Handle exceptions of type2
   } catch(type3 id3)
     // Etc...
   } catch(typeN idN)
     // Handle exceptions of typeN
   }
   // Normal execution resumes here...

   The syntax of acatch clause resembles functions that take a single argument. The identifier (id1,id2, and so on) can be used inside the handler, just like a function argument, although you can omit the identifier if it’s not needed in the handler. The exception type usually gives you enough information to deal with it.
   The handlers must appear directly after thetry block. If an exception is thrown, the exception-handling mechanism goes hunting for the first handler with an argument that matches the type of the exception. It then enters thatcatch clause, and the exception is considered handled. (The search for handlers stops once thecatch clause is found.) Only the matchingcatch clause executes; control then resumes after the last handler associated with that try block.
   Notice that, within thetry block, a number of different function calls might generate the same type of exception, but you need only one handler.
   To illustrate usingtry andcatch, the following variation ofNonlocal.cpp replaces the call tosetjmp( ) with atry block and replaces the call tolongjmp( ) with athrow statement.
   //: C01:Nonlocal2.cpp
   // Illustrates exceptions
   #include&lt;iostream&gt;
   using namespace std;

   class Rainbow {
   public:
     Rainbow() { cout&lt;&lt; "Rainbow()"&lt;&lt; endl; }
     ~Rainbow() { cout&lt;&lt; "~Rainbow()"&lt;&lt; endl; }
   };

   void oz() {
     Rainbow rb;
     for(int i = 0; i&lt; 3; i++)
       cout&lt;&lt; "there's no place like home\n";
     throw 47;
   }

   int main() {
     try {
       cout&lt;&lt; "tornado, witch, munchkins...\n";
       oz();
     }
     catch (int) {
       cout&lt;&lt; "Auntie Em! "
           &lt;&lt; "I had the strangest dream..."
           &lt;&lt; endl;
     }
   } ///:~

   When thethrow statement inoz( ) executes, program control backtracks until it finds thecatch clause that takes anint parameter, at which point execution resumes with the body of thatcatch clause. The most important difference between this program andNonlocal.cpp is that the destructor for the objectrb is called when thethrow statement causes execution to leave the functionoz( ).
   There are two basic models in exception-handling theory: termination and resumption. Intermination (which is what C++ supports), you assume the error is so critical that there’s no way to automatically resume execution at the point where the exception occurred. In other words, "whoever" threw the exception decided there was no way to salvage the situation, and they don’twant to come back.
   The alternative error-handling model is calledresumption, first introduced with the PL/I language in the 1960s[2].Using resumption semantics means that the exception handler is expected to do something to rectify the situation, and then the faulting code is automatically retried, presuming success the second time. If you want resumption in C++, you must explicitly transfer execution back to the code where the error occurred, usually by repeating the function call that sent you there in the first place. It is not unusual, therefore, to place yourtry block inside awhile loop that keeps reentering thetry block until the result is satisfactory.
   Historically, programmers using operating systems that supported resumptive exception handling eventually ended up using termination-like code and skipping resumption. Although resumption sounds attractive at first, it seems it isn’t quite so useful in practice. One reason may be the distance that can occur between the exception and its handler; it is one thing to terminate to a handler that’s far away, but to jump to that handler and then back again may be too conceptually difficult for large systems on which the exception can be generated from many points.
   Exception matching
   When an exception is thrown, the exception-handling system looks through the "nearest" handlers in the order they appear in the source code. When it finds a match, the exception is considered handled and no further searching occurs.
   Matching an exception doesn’t require a perfect correlation between the exception and its handler. An object or reference to a derived-class object will match a handler for the base class. (However, if the handler is for an object rather than a reference, the exception object is "sliced"— truncated to the base type — as it is passed to the handler; this does no damage but loses all the derived-type information.) For this reason, as well as to avoid making yet another copy of the exception object, it is always better to catch an exception byreference instead of by value[3]. If a pointer is thrown, the usual standard pointer conversions are used to match the exception. However, no automatic type conversions are used to convert from one exception type to another in the process of matching, for example:.
   //: C01:Autoexcp.cpp
   // No matching conversions
   #include&lt;iostream&gt;
   using namespace std;

   class Except1 {};
   class Except2 {
   public:
     Except2(const Except1&) {}
   };

   void f() { throw Except1(); }

   int main() {
     try { f();
     } catch (Except2&) {
       cout&lt;&lt; "inside catch(Except2)"&lt;&lt; endl;
     } catch (Except1&) {
       cout&lt;&lt; "inside catch(Except1)"&lt;&lt; endl;
     }
   } ///:~

   Even though you might think the first handler could be used by converting anExcept1 object into anExcept2 using the constructor conversion, the system will not perform such a conversion during exception handling, and you’ll end up at theExcept1 handler.
   The following example shows how a base-class handler can catch a derived-class exception:.
   //: C01:Basexcpt.cpp
   // Exception hierarchies
   #include&lt;iostream&gt;
   using namespace std;

   class X {
   public:
     class Trouble {};
     class Small : public Trouble {};
     class Big : public Trouble {};
     void f() { throw Big(); }
   };

   int main() {
     X x;
     try {
       x.f();
     } catch(X::Trouble&) {
       cout&lt;&lt; "caught Trouble"&lt;&lt; endl;
     // Hidden by previous handler:
     } catch(X::Small&) {
       cout&lt;&lt; "caught Small Trouble"&lt;&lt; endl;
     } catch(X::Big&) {
       cout&lt;&lt; "caught Big Trouble"&lt;&lt; endl;
     }
   } ///:~

   Here, the exception-handling mechanism will always match aTrouble object,or anything that is aTrouble (through public inheritance),[4] to the first handler. That means the second and third handlers are never called because the first one captures them all. It makes more sense to catch the derived types first and put the base type at the end to catch anything less specific.
   Notice that these examples catch exceptions by reference, although for these classes it isn’t important because there are no additional members in the derived classes, and there are no argument identifiers in the handlers anyway. You’ll usually want to use reference arguments rather than value arguments in your handlers to avoid slicing off information.
   Catching any exception
   Sometimes you want to create a handler that catchesany type of exception. You do this using the ellipsis in the argument list:.
   Catch(...) {
     cout&lt;&lt; "an exception was thrown"&lt;&lt; endl;
   }

   An ellipsis catches any exception, so you’ll want to put it at theend of your list of handlers to avoid pre-empting any that follow it.
   Because the ellipsis gives you no possibility to have an argument, you can’t know anything about the exception or its type. It’s a "catchall." Such acatch clause is often used to clean up some resources and then rethrow the exception.
   Re-throwing an exception
   You usually want to re-throw an exception when you have some resource that needs to be released, such as a network connection or heap memory that needs to be deallocated. (See the section "Resource Management" later in this chapter for more detail). If an exception occurs, you don’t necessarily care what error caused the exception—you just want to close the connection you opened previously. After that, you’ll want to let some other context closer to the user (that is, higher up in the call chain) handle the exception. In this case the ellipsis specification is just what you want. You want to catchany exception, clean up your resource, and then re-throw the exception so that it can be handled elsewhere. You re-throw an exception by usingthrow with no argument inside a handler:.
   catch(...) {
   cout&lt;&lt; "an exception was thrown"&lt;&lt; endl;
   // Deallocate your resource here, and then re-throw…
     throw;
   }

   Any furthercatch clauses for the sametry block are still ignored—thethrow causes the exception to go to the exception handlers in the next-higher context. In addition, everything about the exception object is preserved, so the handler at the higher context that catches the specific exception type can extract any information the object may contain.
   Uncaught exceptions
   As we explained in the beginning of this chapter, exception handling is considered better than the traditional return-an-error-code technique because exceptions can’t be ignored. If none of the exception handlers following a particulartry block matches an exception, that exception moves to the next-higher context, that is, the function ortry block surrounding thetry block that did not catch the exception. (The location of thistry block is not always obvious at first glance, since it’s higher up in the call chain.) This process continues until, at some level, a handler matches the exception. At that point, the exception is considered "caught," and no further searching occurs.
   The terminate( ) function
   If no handler at any level catches the exception, the special library functionterminate( ) (declared in the&lt;exception&gt; header) is automatically called. By default,terminate( ) calls the Standard C library functionabort( ), which abruptly exits the program. On Unix systems,abort( ) also causes a core dump. Whenabort( ) is called, no calls to normal program termination functions occur, which means that destructors for global and static objects do not execute. Theterminate( ) function also executes if a destructor for a local object throws an exception during stack unwinding (interrupting the exception that was in progress) or if a global or static object’s constructor or destructor throws an exception. In general, do not allow a destructor to throw an exception.
   The set_terminate( ) function
   You can install your ownterminate( ) function using the standardset_terminate( ) function, which returns a pointer to theterminate( ) function you are replacing (which will be the default library version the first time you call it), so you can restore it later if you want. Your customterminate( ) must take no arguments and have avoid return value. In addition, anyterminate( ) handler you install must not return or throw an exception, but instead must execute some sort of program-termination logic. Ifterminate( ) is called, the problem is unrecoverable.
   The following example shows the use ofset_terminate( ). Here, the return value is saved and restored so that theterminate( ) function can be used to help isolate the section of code in which the uncaught exception is occurring:.
   //: C01:Terminator.cpp
   // Use of set_terminate()
   // Also shows uncaught exceptions
   #include&lt;exception&gt;
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   using namespace std;

   void terminator() {
     cout&lt;&lt; "I'll be back!"&lt;&lt; endl;
     exit(0);
   }

   void (*old_terminate)()
     = set_terminate(terminator);

   class Botch {
   public:
     class Fruit {};
     void f() {
       cout&lt;&lt; "Botch::f()"&lt;&lt; endl;
       throw Fruit();
     }
     ~Botch() { throw 'c'; }
   };

   int main() {
     try {
       Botch b;
       b.f();
     } catch(...) {
       cout&lt;&lt; "inside catch(...)"&lt;&lt; endl;
     }
   } ///:~

   The definition ofold_terminate looks a bit confusing at first: it not only creates a pointer to a function, but it initializes that pointer to the return value ofset_terminate( ). Even though you might be familiar with seeing a semicolon right after a pointer-to-function declaration, here it’s just another kind of variable and can be initialized when it is defined.
   The classBotch not only throws an exception insidef( ), but also in its destructor. As we explained earlier, this situation causes a call toterminate( ), as you can see inmain( ). Even though the exception handler sayscatch(...), which would seem to catch everything and leave no cause forterminate( ) to be called,terminate( )is called anyway. In the process of cleaning up the objects on the stack to handle one exception, theBotch destructor is called, and that generates a second exception, forcing a call toterminate( ). Thus, a destructor that throws an exception or causes one to be thrown is usually a sign of poor design or sloppy coding.
   Cleaning up
   Part of the magic of exception handling is that you can pop from normal program flow into the appropriate exception handler. Doing so wouldn’t be useful, however, if things weren’t cleaned up properly as the exception was thrown. C++ exception handling guarantees that as you leave a scope, all objects in that scopewhose constructors have been completed will have destructors called.
   Here’s an example that demonstrates that constructors that aren’t completed don’t have the associated destructors called. It also shows what happens when an exception is thrown in the middle of the creation of an array of objects:.
   //: C01:Cleanup.cpp
   // Exceptions clean up complete objects only
   #include&lt;iostream&gt;
   using namespace std;

   class Trace {
     static int counter;
     int objid;
   public:
     Trace() {
       objid = counter++;
       cout&lt;&lt; "constructing Trace #"&lt;&lt; objid&lt;&lt; endl;
       if(objid == 3) throw 3;
     }
     ~Trace() {
       cout&lt;&lt; "destructing Trace #"&lt;&lt; objid&lt;&lt; endl;
     }
   };

   int Trace::counter = 0;

   int main() {
     try {
       Trace n1;
       // Throws exception:
       Trace array[5];
       Trace n2;  // won't get here
     } catch(int i) {
       cout&lt;&lt; "caught "&lt;&lt; i&lt;&lt; endl;
     }
   } ///:~

   The classTrace keeps track of objects so that you can trace program progress. It keeps a count of the number of objects created with astatic data membercounter and tracks the number of the particular object withobjid.
   The main program creates a single object,n1 (objid 0), and then attempts to create an array of fiveTrace objects, but an exception is thrown before the third object is fully created. The objectn2 is never created. You can see the results in the output of the program:.
   constructing Trace #0
   constructing Trace #1
   constructing Trace #2
   constructing Trace #3
   destructing Trace #2
   destructing Trace #1
   destructing Trace #0
   caught 3

   Three array elements are successfully created, but in the middle of the constructor for the fourth element, an exception is thrown. Because the fourth construction inmain( ) (forarray[2]) never completes, only the destructors for objectsarray[1] andarray[0] are called. Finally, objectn1 is destroyed, but not objectn2, because it was never created.
   Resource management
   When writing code with exceptions, it’s particularly important that you always ask, "If an exception occurs, will my resources be properly cleaned up?" Most of the time you’re fairly safe, but in constructors there’s a particular problem: if an exception is thrown before a constructor is completed, the associated destructor willnot be called for that object. Thus, you must be especially diligent while writing your constructor.
   The general difficulty is allocating resources in constructors. If an exception occurs in the constructor, the destructor doesn’t get a chance to deallocate the resource. This problem occurs most often with "naked" pointers. For example:.
   //: C01:Rawp.cpp
   // Naked pointers
   #include&lt;iostream&gt;
   using namespace std;

   class Cat {
   public:
     Cat() { cout&lt;&lt; "Cat()"&lt;&lt; endl; }
     ~Cat() { cout&lt;&lt; "~Cat()"&lt;&lt; endl; }
   };

   class Dog {
   public:
     void* operator new(size_t sz) {
       cout&lt;&lt; "allocating a Dog"&lt;&lt; endl;
       throw 47;
     }
     void operator delete(void* p) {
       cout&lt;&lt; "deallocating a Dog"&lt;&lt; endl;
       ::operator delete(p);
     }
   };

   class UseResources {
     Cat* bp;
     Dog* op;
   public:
     UseResources(int count = 1) {
       cout&lt;&lt; "UseResources()"&lt;&lt; endl;
       bp = new Cat[count];
       op = new Dog;
     }
     ~UseResources() {
       cout&lt;&lt; "~UseResources()"&lt;&lt; endl;
       delete [] bp; // Array delete
       delete op;
     }
   };

   int main() {
     try {
       UseResources ur(3);
     } catch(int) {
       cout&lt;&lt; "inside handler"&lt;&lt; endl;
     }
   } ///:~

   The output is the following:.
   UseResources()
   Cat()
   Cat()
   Cat()
   allocating a Dog
   inside handler

   TheUseResources constructor is entered, and theCat constructor is successfully completed for the three array objects. However, insideDog::operator new( ), an exception is thrown (to simulate an out-of-memory error). Suddenly, you end up inside the handler,without theUseResources destructor being called. This is correct because theUseResources constructor was unable to finish, but it also means theCat objects that were successfully created on the heap were never destroyed.
   Making everything an object
   To prevent such resource leaks, you must guard against these "raw" resource allocations in one of two ways:
   ·         You can catch exceptions inside the constructor and then release the resource.
   ·         You can place the allocations inside an object’s constructor, and you can place the deallocations inside an object’s destructor.
   Using the latter approach, each allocation becomes atomic, by virtue of being part of the lifetime of a local object, and if it fails, the other resource allocation objects are properly cleaned up during stack unwinding. This technique is called Resource Acquisition Is Initialization (RAII for short) , because it equates resource control with object lifetime. Using templates is an excellent way to modify the previous example to achieve this:.
   //: C01:Wrapped.cpp
   // Safe, atomic pointers
   #include&lt;iostream&gt;
   using namespace std;

   // Simplified. Yours may have other arguments.
   template&lt;class T, int sz = 1&gt; class PWrap {
     T* ptr;
   public:
     class RangeError {}; // Exception class
     PWrap() {
       ptr = new T[sz];
       cout&lt;&lt; "PWrap constructor"&lt;&lt; endl;
     }
     ~PWrap() {
       delete [] ptr;
       cout&lt;&lt; "PWrap destructor"&lt;&lt; endl;
     }
     T& operator[](int i) throw(RangeError) {
       if(i&gt;= 0&& i&lt; sz) return ptr[i];
       throw RangeError();
     }
   };

   class Cat {
   public:
     Cat() { cout&lt;&lt; "Cat()"&lt;&lt; endl; }
     ~Cat() { cout&lt;&lt; "~Cat()"&lt;&lt; endl; }
     void g() {}
   };

   class Dog {
   public:
     void* operator new[](size_t) {
       cout&lt;&lt; "Allocating a Dog"&lt;&lt; endl;
       throw 47;
     }
     void operator delete[](void* p) {
       cout&lt;&lt; "Deallocating a Dog"&lt;&lt; endl;
       ::operator delete[](p);
     }
   };

   class UseResources {
     PWrap&lt;Cat, 3&gt; cats;
     PWrap&lt;Dog&gt; dog;
   public:
     UseResources() {
       cout&lt;&lt; "UseResources()"&lt;&lt; endl;
     }
     ~UseResources() {
       cout&lt;&lt; "~UseResources()"&lt;&lt; endl;
     }
     void f() { cats[1].g(); }
   };

   int main() {
     try {
       UseResources ur;
     } catch(int) {
       cout&lt;&lt; "inside handler"&lt;&lt; endl;
     } catch(...) {
       cout&lt;&lt; "inside catch(...)"&lt;&lt; endl;
     }
   } ///:~

   The difference is the use of the template to wrap the pointers and make them into objects. The constructors for these objects are calledbefore the body of theUseResources constructor, and any of these constructors that complete before an exception is thrown will have their associated destructors called during stack unwinding.
   ThePWrap template shows a more typical use of exceptions than you’ve seen so far: A nested class calledRangeError is created to use inoperator[ ] if its argument is out of range. Becauseoperator[ ] returns a reference, it cannot return zero. (There are no null references.) This is a true exceptional condition—you don’t know what to do in the current context, and you can’t return an improbable value. In this example,RangeError is simple and assumes all the necessary information is in the class name, but you might also want to add a member that contains the value of the index, if that is useful.
   Now the output is:.
   Cat()
   Cat()
   Cat()
   PWrap constructor
   allocating a Dog
   ~Cat()
   ~Cat()
   ~Cat()
   PWrap destructor
   inside handler

   Again, the storage allocation forDog throws an exception, but this time the array ofCat objects is properly cleaned up, so there is no memory leak.
   auto_ptr
   Since dynamic memory is the most frequent resource used in a typical C++ program, the standard provides an RAII wrapper for pointers to heap memory that automatically frees the memory. Theauto_ptr class template, defined in the&lt;memory&gt; header, has a constructor that takes a pointer to its generic type (whatever you use in your code). Theauto_ptr class template also overloads the pointer operators* and-&gt; to forward these operations to the original pointer theauto_ptr object is holding. You can, therefore, use theauto_ptr object as if it were a raw pointer. Here’s how it works:.
   //: C01:Auto_ptr.cpp
   // Illustrates the RAII nature of auto_ptr
   #include&lt;memory&gt;
   #include&lt;iostream&gt;
   using namespace std;

   class TraceHeap {
     int i;
   public:
     static void* operator new(size_t siz) {
       void* p = ::operator new(siz);
       cout&lt;&lt; "Allocating TraceHeap object on the heap "
           &lt;&lt; "at address "&lt;&lt; p&lt;&lt; endl;
       return p;
     }
     static void operator delete(void* p) {
       cout&lt;&lt; "Deleting TraceHeap object at address "
           &lt;&lt; p&lt;&lt; endl;
       ::operator delete(p);
     }
     TraceHeap(int i) : i(i) {}
     int getVal() const {
       return i;
     }
   };

   int main() {
     auto_ptr&lt;TraceHeap&gt; pMyObject(new TraceHeap(5));
     cout&lt;&lt; pMyObject-&gt;getVal()&lt;&lt; endl;  // prints 5
   } ///:~

   TheTraceHeap class overloads theoperator new andoperator delete so you can see exactly what’s happening. Notice that, like any other class template, you specify the type you’re going to use in a template parameter. You don’t sayTraceHeap*, however;auto_ptr already knows that it will be storing a pointer to your type. The second line ofmain( ) verifies thatauto_ptr’soperator-&gt;( ) function applies the indirection to the original, underlying pointer. Most important, even though we didn’t explicitly delete the original pointer (in fact we can’t here, since we didn’t save its address in a variable anywhere),pMyObject’s destructor deletes the original pointer during stack unwinding, as the following output verifies:.
   Allocating TraceHeap object on the heap at address 8930040
   5
   Deleting TraceHeap object at address 8930040

   The auto_ptr class template is also handy for pointer data members. Since class objects contained by value are always destructed,auto_ptr members always delete the raw pointer they wrap when the containing object is destructed[5].
   Function-level try blocks
   Since constructors can routinely throw exceptions, you might want to handle exceptions that occur when an object’s member or base subobjects are initialized. To do this, you can place the initialization of such subobjects in afunction-level try block. In a departure from the usual syntax, thetry block for constructor initializers is the constructor body, and the associatedcatch block follows the body of the constructor, as in the following example.
   //: C01:InitExcept.cpp
   // Handles exceptions from subobjects
   //{-bor}
   #include&lt;iostream&gt;
   using namespace std;

   class Base {
     int i;
   public:
     class BaseExcept {};
     Base(int i) : i(i) {
       throw BaseExcept();
     }
   };

   class Derived : public Base {
   public:
     class DerivedExcept {
       const char* msg;
     public:
       DerivedExcept(const char* msg) : msg(msg) {}
       const char* what() const {
         return msg;
       }
     };
     Derived(int j)
     try
       : Base(j) {
       // Constructor body
       cout&lt;&lt; "This won't print\n";
     }
     catch (BaseExcept&) {
       throw DerivedExcept("Base subobject threw");;
     }
   };

   int main() {
     try {
       Derived d(3);
     }
     catch (Derived::DerivedExcept& d) {
       cout&lt;&lt; d.what()&lt;&lt; endl;  // "Base subobject threw"
     }
   } ///:~

   Notice that the initializer list in the constructor forDerived goes after thetry keyword but before the constructor body. If an exception does indeed occur, the contained object is not constructed, so it makes no sense to return to the code that created it. For this reason, the only sensible thing to do is to throw an exception in the function-levelcatch clause.
   Although it is not terribly useful, C++ also allows function-leveltry blocks forany function, as the following example illustrates:
   //: C01:FunctionTryBlock.cpp
   // Function-level try blocks
   //{-bor}
   #include&lt;iostream&gt;
   using namespace std;

   int main() try {
     throw "main";
   } catch(const char* msg) {
   cout&lt;&lt; msg&lt;&lt; endl;
   return 1;
   } ///:~

   In this case, thecatch block can return in the same manner that the function body normally returns. Using this type of function-leveltry block isn’t much different from inserting atry-catch around the code inside of the function body.
   Standard exceptions
   The set of exceptions used with the Standard C++ library is also available for your use. Generally it’s easier and faster to start with a standard exception class than to try to define your own. If the standard class doesn’t do exactly what you need, you can derive from it.
   All standard exception classes derive ultimately from the classexception, defined in the header&lt;exception&gt;. The two main derived classes arelogic_error andruntime_error, which are found in&lt;stdexcept&gt; (which itself includes&lt;exception&gt;). The classlogic_error represents errors in programming logic, such as passing an invalid argument. Runtime errors are those that occur as the result of unforeseen forces such as hardware failure or memory exhaustion. Bothruntime_error andlogic_error provide a constructor that takes astd::string argument so that you can store a message in the exception object and extract it later withexception::what( ) , as the following program illustrates.
   //: C01:StdExcept.cpp
   // Derives an exception class from std::runtime_error
   #include&lt;stdexcept&gt;
   #include&lt;iostream&gt;
   using namespace std;

   class MyError : public runtime_error {
   public:
     MyError(const string& msg = "") : runtime_error(msg) {}
   };

   int main() {
     try {
       throw MyError("my message");
     }
     catch (MyError& x) {
       cout&lt;&lt; x.what()&lt;&lt; endl;
     }
   } ///:~

   Although theruntime_error constructor passes the message up to itsstd::exception subobject to hold,std::exception does not provide a constructor that takes astd::string argument. Therefore, you usually want to derive your exception classes from eitherruntime_error orlogic_error (or one of their derivatives), and not fromstd::exception.
   The following tables describe the standard exception classes.exceptionThe base class for all the exceptions thrown by the C++ standard library. You can askwhat( ) and retrieve the optional string with which the exception was initialized.logic_errorDerived fromexception. Reports program logic errors, which could presumably be detected by inspection.runtime_errorDerived fromexception. Reports runtime errors, which can presumably be detected only when the program executes.

   The iostream exception classios::failure is also derived fromexception, but it has no further subclasses.
   You can use the classes in both of the following tables as they are, or you can use them as base classes from which to derive your own more specific types of exceptions.Exception classes derived from logic_errordomain_errorReports violations of a precondition.invalid_argumentIndicates an invalid argument to the function from which it’s thrown.length_errorIndicates an attempt to produce an object whose length is greater than or equal tonpos (the largest representable value of typesize_t).Out_of_rangeReports an out-of-range argument.Bad_castThrown for executing an invaliddynamic_cast expression in runtime type identification (see Chapter 8).bad_typeidReports a null pointerp in an expressiontypeid(*p). (Again, a runtime type identification feature in Chapter 8).
Exception classes derived from runtime_errorrange_errorReports violation of a postcondition.overflow_errorReports an arithmetic overflow.bad_allocReports a failure to allocate storage.
   Exception specifications
   You’re not required to inform the people using your function what exceptions you might throw. Failure to do so can be considered uncivilized, however, because it means that users cannot be sure what code to write to catch all potential exceptions. Of course, if they have your source code, they can hunt through and look forthrow statements, but often a library doesn’t come with sources. Good documentation can help alleviate this problem, but how many software projects are well documented? C++ provides syntax that allows you to tell the user what exceptions this function throws, so the user can handle them. This is the optionalexception specification, which adorns a function’s declaration, appearing after the argument list.
   The exception specification reuses the keywordthrow, followed by a parenthesized list of all the types of potential exceptions that the function can throw. Your function declaration might look like this:.
   void f() throw(toobig, toosmall, divzero);

   As far as exceptions are concerned, the traditional function declaration
   void f();

   means thatany type of exception can be thrown from the function. If you say
   void f() throw();

   no exceptions whatsoever will be thrown from the function (so you’d better be sure that no functions farther down in the call chain let any exceptions propagate up!).
   For good coding policy, good documentation, and ease-of-use for the function caller, always consider using exception specifications when you write functions that throw exceptions. (Exceptions to this guideline are discussed later in this chapter.)
   The unexpected( ) function
   If your exception specification claims you’re going to throw a certain set of exceptions and then you throw something that isn’t in that set, what’s the penalty? The special functionunexpected( ) is called when you throw something other than what appears in the exception specification. Should this unfortunate situation occur, the default implementation ofunexpected calls theterminate( ) function mentioned earlier in this chapter.
   The set_unexpected( ) function
   Liketerminate( ), theunexpected( ) mechanism allows you to install your own function to respond to unexpected exceptions. You do so with a function calledset_unexpected( ), which, likeset_terminate( ), takes the address of a function with no arguments andvoid return value. Also, because it returns the previous value of theunexpected( ) pointer, you can save it and restore it later. To useset_unexpected( ), include the header file&lt;exception&gt;. Here’s an example that shows a simple use of the features discussed so far in this section:.
   //: C01:Unexpected.cpp
   // Exception specifications& unexpected()
   //{-msc} Doesn’t terminate properly
   #include&lt;exception&gt;
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   using namespace std;

   class Up {};
   class Fit {};
   void g();

   void f(int i) throw (Up, Fit) {
     switch(i) {
       case 1: throw Up();
       case 2: throw Fit();
     }
     g();
   }

   // void g() {} // Version 1
   void g() { throw 47; } // Version 2

   void my_unexpected() {
     cout&lt;&lt; "unexpected exception thrown"&lt;&lt; endl;
     exit(0);
   }

   int main() {
     set_unexpected(my_unexpected);
     // (ignores return value)
     for(int i = 1; i&lt;=3; i++)
       try {
         f(i);
       } catch(Up) {
         cout&lt;&lt; "Up caught"&lt;&lt; endl;
       } catch(Fit) {
         cout&lt;&lt; "Fit caught"&lt;&lt; endl;
       }
   } ///:~

   The classesUp andFit are created solely to throw as exceptions. Often exception classes will be small, but they can certainly hold additional information so that the handlers can query for it.
   Thef( ) function promises in its exception specification to throw only exceptions of typeUp andFit, and from looking at the function definition, this seems plausible. Version one ofg( ), called byf( ), doesn’t throw any exceptions, so this is true. But if someone changesg( ) so that it throws a different type of exception (like the second version in this example, which throws anint), the exception specification forf( ) is violated.
   Themy_unexpected( ) function has no arguments or return value, following the proper form for a customunexpected( ) function. It simply displays a message so that you can see that it was called, and then exits the program (exit(0) is used here so that the book’smake process is not aborted). Your newunexpected( ) function should not have areturn statement.
   Inmain( ), thetry block is within afor loop, so all the possibilities are exercised. In this way, you can achieve something like resumption. Nest thetry block inside afor,while,do, orif and cause any exceptions to attempt to repair the problem; then attempt thetry block again.
   Only theUp andFit exceptions are caught because those are the only exceptions that the programmer off( ) said would be thrown. Version two ofg( ) causesmy_unexpected( ) to be called becausef( ) then throws anint.
   In the call toset_unexpected( ), the return value is ignored, but it can also be saved in a pointer to function and be restored later, as we did in theset_terminate( ) example earlier in this chapter.
   A typicalunexpected handler logs the error and terminates the program by callingexit( ). It can, however, throw another exception (or re-throw the same exception) or callabort( ). If it throws an exception of a type allowed by the function whose specification was originally violated, the search resumes at thecall of the function with this exception specification. (This behavior is unique tounexpected( ).)
   If the exception thrown from yourunexpected handler is not allowed by the original function’s specification, one of the following occurs:
   1.       Ifstd::bad_exception (defined in&lt;exception&gt;) was in the function’s exception specification, the exception thrown from the unexpected handler is replaced with astd::bad_exception object, and the search resumes from the function as before.
   2.      If the original function’s specification did not includestd::bad_exception,terminate( ) is called.
   The following program illustrates this behavior.
   //: C01:BadException.cpp
   //{-bor}
   #include&lt;exception&gt;    // for std::bad_exception
   #include&lt;iostream&gt;
   #include&lt;cstdio&gt;
   using namespace std;

   // Exception classes:
   class A {};
   class B {};

   // terminate() handler
   void my_thandler() {
     cout&lt;&lt; "terminate called\n";
     exit(0);
   }

   // unexpected() handlers
   void my_uhandler1() {
     throw A();
   }
   void my_uhandler2() {
     throw;
   }

   // If we embed this throw statement in f or g,
   // the compiler detects the violation and reports
   // an error, so we put it in its own function.
   void t() {
     throw B();
   }

   void f() throw(A) {
     t();
   }
   void g() throw(A, bad_exception) {
     t();
   }

   int main() {
     set_terminate(my_thandler);
     set_unexpected(my_uhandler1);
     try {
       f();
     }
     catch (A&) {
       cout&lt;&lt; "caught an A from f\n";
     }
     set_unexpected(my_uhandler2);
     try {
       g();
     }
     catch (bad_exception&) {
       cout&lt;&lt; "caught a bad_exception from g\n";
     }
     try {
       f();
     }
     catch (...) {
       cout&lt;&lt; "This will never print\n";
     }
   } ///:~

   Themy_uhandler1( ) handler throws an acceptable exception (A), so execution resumes at the first catch, which succeeds. Themy_uhandler2( ) handler does not throw a valid exception (B), but sinceg specifiesbad_exception, theB exception is replaced by abad_exception object, and the second catch also succeeds. Sincef does not includebad_exception in its specification,my_thandler( ) is called as a terminate handler. Thus, the output from this program is as follows:.
   caught an A from f
   caught a bad_exception from g
   terminate called

   Better exception specifications?
   You may feel that the existing exception specification rules aren’t very safe, and that
   void f();

   should mean that no exceptions are thrown from this function. If the programmer wants to throw any type of exception, you might think he or sheshouldhave to say.
   void f() throw(...); // Not in C++

   This would surely be an improvement because function declarations would be more explicit. Unfortunately, you can’t always know by looking at the code in a function whether an exception will be thrown—it could happen because of a memory allocation, for example. Worse, existing functions written before exception handling was introduced may find themselves inadvertently throwing exceptions because of the functions they call (which might be linked into new, exception-throwing versions). Hence, the uninformative situation whereby.
   void f();

   means, "Maybe I’ll throw an exception, maybe I won’t." This ambiguity is necessary to avoid hindering code evolution. If you want to specify thatf throws no exceptions, use the empty list, as in:.
   void f() throw();

   Exception specifications and inheritance
   Each public function in a class essentially forms a contract with the user; if you pass it certain arguments, it will perform certain operations and/or return a result. The same contract must hold true in derived classes; otherwise the expected "is-a" relationship between derived and base classes is violated. Since exception specifications are logically part of a function’s declaration, they too must remain consistent across an inheritance hierarchy. For example, if a member function in a base class says it will only throw an exception of typeA, an override of that function in a derived class must not add any other exception types to the specification list, because that would result in unexpected exceptions for the user, breaking any programs that adhere to the base class interface. You can, however, specifyfewer exceptions ornone at all, since that doesn’t require the user to do anything differently. You can also specify anything that "is-a"A in place ofA in the derived function’s specification. Here’s an example.
   // C01:Covariance.cpp
   // Compile Only!
   //{-msc}
   #include&lt;iostream&gt;
   using namespace std;

   class Base {
   public:
     class BaseException {};
     class DerivedException : public BaseException {};
     virtual void f() throw (DerivedException) {
       throw DerivedException();
     }
     virtual void g() throw (BaseException) {
       throw BaseException();
     }
   };

   class Derived : public Base {
   public:
     void f() throw (BaseException) {
       throw BaseException();
     }
     virtual void g() throw (DerivedException) {
       throw DerivedException();
     }
   };

   A compiler should flag the override ofDerived::f( ) with an error (or at least a warning) since it changes its exception specification in a way that violates the specification ofBase::f( ). The specification forDerived::g( ) is acceptable becauseDerivedException "is-a"BaseException (not the other way around). You can think ofBase/Derived andBaseException/DerivedException as parallel class hierarchies; when you are inDerived, you can replace references toBaseException in exception specifications and return values withDerivedException. This behavior is calledcovariance (since both sets of classes vary down their respective hierarchies together). (Reminder from Volume 1: parameter types arenot covariant—you are not allowed to change the signature of an overridden virtual function.).
   Whennot to use exception specifications
   If you peruse the function declarations throughout the Standard C++ library, you’ll find that not a single exception specification occurs anywhere! Although this might seem strange, there is a good reason for this seeming incongruity: the library consists mainly of templates, and you never know what a generic might do. For example, suppose you are developing a generic stack template and attempt to affix an exception specification to your pop function, like this:
   T pop() throw(logic_error);

   Since the only error you anticipate is a stack underflow, you might think it’s safe to specify alogic_error or some other appropriate exception type. But since you don’t know much about the typeT, what if its copy constructor could possibly throw an exception (it’s not unreasonable, after all)? Thenunexpected( ) would be called, and your program would terminate. The point is that you shouldn’t make guarantees that you can’t stand behind. If you don’t know what exceptions might occur, don’t use exception specifications. That’s why template classes, which constitute 90 percent of the Standard C++ library, do not use exception specifications—they specify the exceptions they know about indocumentation and leave the rest to you. Exception specifications are mainly for non-template classes.
   Exception safety
   In Chapter 7 we’ll take an in-depth look at the containers in the Standard C++ library, including the stack container. One thing you’ll notice is that the declaration of thepop( ) member function looks like this:
   void pop();

   You might think it strange thatpop( ) doesn’t return a value. Instead, it just removes the element at the top of the stack. To retrieve the top value, calltop( ) before you callpop( ). There is an important reason for this behavior, and it has to do withexception safety, a crucial consideration in library design.
   Suppose you are implementing a stack with a dynamic array (we’ll call itdata and the counter integercount), and you try to writepop( ) so that it returns a value. The code for such apop( ) might look something like this:
   template&lt;class T&gt;
   T stack&lt;T&gt;::pop() {
     if (count == 0)
       throw logic_error("stack underflow");
     else
       return data[--count];
   }

   What happens if the copy constructor that is called for the return value in the last line throws an exception when the value is returned? The popped element is not returned because of the exception, and yetcount has already been decremented, so the top element you wanted is lost forever! The problem is that this function attempts to do two things at once: (1) return a value, and (2) change the state of the stack. It is better to separate these two actions into two separate member functions, which is exactly what the standardstack class does. (In other words, follow the time-worn design practice ofcohesion—every function should doone thing well.) Exception-safe code leaves objects in a consistent state and does not leak resources.
   You also need to be careful writing custom assignment operators. In Chapter 12 of Volume 1, you saw thatoperator= should adhere to the following pattern:
   1.       Make sure you’re not assigning to self. If you are, go to step 6. (This is strictly an optimization.)
   2.      Allocate new memory required by pointer data members.
   3.      Copy data from the old memory to the new.
   4.      Delete the old memory.
   5.      Update the object’s state by assigning the new heap pointers to the pointer data members.
   6.      Return*this.
   It’s important to not change the state of your object until all the new pieces have been safely allocated and initialized. A good technique is to move all of steps 2 and 3 into a separate function, often calledclone( ). The following example does this for a class that has two pointer members,theString andtheInts.
   //: C01:SafeAssign.cpp
   // Shows an Exception-safe operator=
   #include&lt;iostream&gt;
   #include&lt;new&gt;       // For std::bad_alloc
   #include&lt;cstring&gt;
   using namespace std;

   // A class that has two pointer members using the heap
   class HasPointers {
     // A Handle class to hold the data
     struct MyData {
       const char* theString;
       const int* theInts;
       size_t numInts;
       MyData(const char* pString, const int* pInts,
              size_t nInts)
       : theString(pString), theInts(pInts),
       numInts(nInts) {}
     } *theData;  // The handle

     // clone and cleanup functions
     static MyData* clone(const char* otherString,
           const int* otherInts, size_t nInts){
       char* newChars = new char[strlen(otherString)+1];
       int* newInts;
       try {
         newInts = new int[nInts];
       } catch (bad_alloc&) {
         delete [] newChars;
         throw;
       }
       try {
         // This example uses built-in types, so it won't
         // throw, but for class types it could throw, so we
         // use a try block for illustration. (This is the
         // point of the example!)
         strcpy(newChars, otherString);
         for (size_t i = 0; i&lt; nInts; ++i)
           newInts[i] = otherInts[i];
       } catch (...) {
         delete [] newInts;
         delete [] newChars;
         throw;
       }
       return new MyData(newChars, newInts, nInts);
     }
     static MyData* clone(const MyData* otherData) {
       return clone(otherData-&gt;theString,
     otherData-&gt;theInts,
     otherData-&gt;numInts);
     }
     static void cleanup(const MyData* theData) {
       delete [] theData-&gt;theString;
       delete [] theData-&gt;theInts;
       delete theData;
     }
   public:
     HasPointers(const char* someString, const int* someInts,
                 size_t numInts) {
       theData = clone(someString, someInts, numInts);
     }
     HasPointers(const HasPointers& source) {
       theData = clone(source.theData);
     }
     HasPointers& operator=(const HasPointers& rhs) {
       if (this !=&rhs) {
         MyData* newData =
         clone(rhs.theData-&gt;theString,
               rhs.theData-&gt;theInts,
               rhs.theData-&gt;numInts);
         cleanup(theData);
         theData = newData;
       }
       return *this;
     }
     ~HasPointers() {
       cleanup(theData);
     }
     friend ostream& operator&lt;&lt;(ostream& os,
                 const HasPointers& obj) {
       os&lt;&lt; obj.theData-&gt;theString&lt;&lt; ": ";
       for (size_t i = 0; i&lt; obj.theData-&gt;numInts; ++i)
         os&lt;&lt; obj.theData-&gt;theInts[i]&lt;&lt; ' ';
       return os;
     }
   };

   int main() {
     int someNums[] = {1, 2, 3, 4};
     size_t someCount = sizeof someNums / sizeof someNums[0];
     int someMoreNums[] = {5, 6, 7};
     size_t someMoreCount =
     sizeof someMoreNums / sizeof someMoreNums[0];
     HasPointers h1("Hello", someNums, someCount);
     HasPointers h2("Goodbye", someMoreNums, someMoreCount);
     cout&lt;&lt; h1&lt;&lt; endl;  // Hello: 1 2 3 4
     h1 = h2;
     cout&lt;&lt; h1&lt;&lt; endl;  // Goodbye: 5 6 7
   } ///:~

   For convenience,HasPointers uses theMyData class as a handle to the two pointers. Whenever it’s time to allocate more memory, whether during construction or assignment, the firstclone function is ultimately called to do the job. If memory fails for the first call to thenew operator, abad_alloc exception is thrown automatically. If it happens on the second allocation (fortheInts), we have to clean up the memory fortheString—hence the firsttry block that catches abad_alloc exception. The secondtry block isn’t crucial here because we’re just copyingints and pointers (so no exceptions will occur), but whenever you copy objects, their assignment operators can possibly cause an exception, in which case everything needs to be cleaned up. In both exception handlers, notice that werethrow the exception. That’s because we’re just managing resources here; the user still needs to know that something went wrong, so we let the exception propagate up the dynamic chain. Software libraries that don’t silently swallow exceptions are calledexception neutral. Always strive to write libraries that are both exception safe and exception neutral.[6]
   If you inspect the previous code closely, you’ll notice that none of thedelete operations will throw an exception. This code actually depends on that fact. Recall that when you calldelete on an object, the object’s destructor is called. It turns out to be practically impossible, therefore, to design exception-safe code without assuming that destructors don’t throw exceptions. Don’t let destructors throw exceptions! (We’re going to remind you about this once more before this chapter is done)[7] .
   Programming with exceptions
   For most programmers, especially C programmers, exceptions are not available in their existing language and take a bit of adjustment. Here are some guidelines for programming with exceptions.
   When to avoid exceptions
   Exceptions aren’t the answer to all problems. In fact, if you simply go looking for something to pound with your new hammer, you’ll cause trouble. The following sections point out situations in which exceptions arenot warranted. Probably the best advice for deciding when to use exceptions is to throw exceptions only when a function fails to meet its specification.
   Not for asynchronous events
   The Standard Csignal( ) system and any similar system handle asynchronous events: events that happen outside the flow of a program, and thus events the program cannot anticipate. You cannot use C++ exceptions to handle asynchronous events because the exception and its handler are on the same call stack. That is, exceptions rely on the dynamic chain of function calls on the program’s runtime stack (dynamic scope, if you will), whereas asynchronous events must be handled by completely separate code that is not part of the normal program flow (typically, interrupt service routines or event loops). Don’t throw exceptions from interrupt handlers.
   This is not to say that asynchronous events cannot beassociated with exceptions. But the interrupt handler should do its job as quickly as possible and then return. The typical way to handle this situation is to set a flag in the interrupt handler, and check it synchronously in the mainline code.
   Not for benign error conditions
   If you have enough information to handle an error, it’s not an exception. Take care of it in the current context rather than throwing an exception to a larger context.
   Also, C++ exceptions are not thrown for machine-level events such as divide-by-zero.[8] It’s assumed that some other mechanism, such as the operating system or hardware, deals with these events. In this way, C++ exceptions can be reasonably efficient, and their use is isolated to program-level exceptional conditions.
   Not for flow-of-control
   An exception looks somewhat like an alternate return mechanism and somewhat like aswitch statement, so you might be tempted to use an exception instead of these ordinary language mechanisms. This is a bad idea, partly because the exception-handling system is significantly less efficient than normal program execution; exceptions are a rare event, so the normal program shouldn’t pay for them. Also, exceptions from anything other than error conditions are quite confusing to the user of your class or function.
   You’re not forced to use exceptions
   Some programs are quite simple (small utilities, for example). You might only need to take input and perform some processing. In these programs, you might attempt to allocate memory and fail, try to open a file and fail, and so on. It is acceptable in these programs to display a message and exit the program, allowing the system to clean up the mess, rather than to work hard to catch all exceptions and recover all the resources yourself. Basically, if you don’t need to use exceptions, you don’t have to use them.
   New exceptions, old code
   Another situation that arises is the modification of an existing program that doesn’t use exceptions. You might introduce a library thatdoes use exceptions and wonder if you need to modify all your code throughout the program. Assuming you have an acceptable error-handling scheme already in place, the most straightforward thing to do is surround the largest block that uses the new library (this might be all the code inmain( )) with atry block, followed by acatch(...) and basic error message). You can refine this to whatever degree necessary by adding more specific handlers, but, in any case, the code you’re forced to add can be minimal. It’s even better, of course, to isolate your exception-generating code in atry block and write handlers to convert the exceptions into your existing error-handling scheme.
   It’s truly important to think about exceptions when you’re creating a library for someone else to use, especially in situations in which you can’t know how they need to respond to critical error conditions (recall the earlier discussions on exception safety and why there are no exception specifications in the Standard C++ Library).
   Typical uses of exceptions
   Do use exceptions to do the following:
   ·         Fix the problem and call the function which caused the exception again.
   ·         Patch things up and continue without retrying the function.
   ·         Do whatever you can in the current context and rethrow thesame exception to a higher context.
   ·         Do whatever you can in the current context and throw adifferent exception to a higher context.
   ·         Terminate the program.
   ·         Wrap functions (especially C library functions) that use ordinary error schemes so they produce exceptions instead.
   ·         Simplify. If your exception scheme makes things more complicated, it is painful and annoying to use.
   ·         Make your library and program safer. This is a short-term investment (for debugging) and a long-term investment (for application robustness).
   When to use exception specifications
   The exception specification is like a function prototype: it tells the user to write exception-handling code and what exceptions to handle. It tells the compiler the exceptions that might come out of this function so that it can detect violations at runtime.
   Of course, you can’t always look at the code and anticipate which exceptions will arise from a particular function. Sometimes, the functions it calls produce an unexpected exception, and sometimes an old function that didn’t throw an exception is replaced with a new one that does, and you get a call tounexpected( ). Any time you use exception specifications or call functions that do, consider creating your ownunexpected( ) function that logs a message and then either throws an exception or aborts the program.
   As we explained earlier, you should avoid using exception specifications in template classes, since you can’t anticipate what types of exceptions the template parameter classes might throw.
   Start with standard exceptions
   Check out the Standard C++ library exceptions before creating your own. If a standard exception does what you need, chances are it’s a lot easier for your user to understand and handle.
   If the exception type you want isn’t part of the standard library, try to derive one from an existing standard exception. It’s nice if your users can always write their code to expect thewhat( )function defined in theexception( ) class interface.
   Nest your own exceptions
   If you create exceptions for your particular class, it’s a good idea to nest the exception classes either inside your class or inside a namespace containing your class, to provide a clear message to the reader that this exception is used only for your class. In addition, it prevents the pollution of the global namespace.
   You can nest your exceptions even if you’re deriving them from C++ standard exceptions.
   Use exception hierarchies
   Using exception hierarchies is a valuable way to classify the types of critical errors that might be encountered with your class or library. This gives helpful information to users, assists them in organizing their code, and gives them the option of ignoring all the specific types of exceptions and just catching the base-class type. Also, any exceptions added later by inheriting from the same base class will not force all existing code to be rewritten—the base-class handler will catch the new exception.
   Of course, the Standard C++ exceptions are a good example of an exception hierarchy and one on which you can build.
   Multiple inheritance (MI)
   As you’ll read in Chapter 9, the onlyessentialplace for MI is if you need to upcast an object pointer to two different base classes—that is, if you need polymorphic behavior with both of those base classes. It turns out that exception hierarchies are useful places for multiple inheritance because a base-class handler from any of the roots of the multiply inherited exception class can handle the exception.
   Catch by reference, not by value
   We explained in the section "Exception matching" earlier that you should catch exceptions by reference for two reasons:
   ·         To avoid making a needless copy of the exception object when it is passed to the handler,
   ·         To avoid object slicing when catching a derived exception as a base class object
   Although you can also throw and catch pointers, by doing so you introduce more coupling—the thrower and the catcher must agree on how the exception object is allocated and cleaned up. This is a problem because the exception itself might have occurred from heap exhaustion. If you throw exception objects, the exception-handling system takes care of all storage.
   Throw exceptions in constructors
   Because a constructor has no return value, you’ve previously had two ways to report an error during construction:.
   ·         Set a nonlocal flag and hope the user checks it.
   ·         Return an incompletely created object and hope the user checks it.
   This problem is serious because C programmers have come to rely on an implied guarantee that object creation is always successful, which is not unreasonable in C in which types are so primitive. But continuing execution after construction fails in a C++ program is a guaranteed disaster, so constructors are one of the most important places to throw exceptions—now you have a safe, effective way to handle constructor errors. However, you must also pay attention to pointers inside objects and the way cleanup occurs when an exception is thrown inside a constructor.
   Don’t cause exceptions in destructors
   Because destructors are called in the process of throwing other exceptions, you’ll never want to throw an exception in a destructor or cause another exception to be thrown by some action you perform in the destructor. If this happens, a new exception can be thrownbefore the catch-clause for an existing exception is reached, which will cause a call toterminate( ).
   If you call any functions inside a destructor that can throw exceptions, those calls should be within atry block in the destructor, and the destructor must handle all exceptions itself. None must escape from the destructor.
   Avoid naked pointers
   SeeWrapped.cpp earlier in this chapter. A naked pointer usually means vulnerability in the constructor if resources are allocated for that pointer. A pointer doesn’t have a destructor, so those resources aren’t released if an exception is thrown in the constructor. Useauto_ptr for pointers that reference heap memory.
   Overhead
   When an exception is thrown, there’s considerable runtime overhead (but it’sgood overhead, since objects are cleaned up automatically!). For this reason, you never want to use exceptions as part of your normal flow-of-control, no matter how tempting and clever it may seem. Exceptions should occur only rarely, so the overhead is piled on the exception and not on the normally executing code. One of the important design goals for exception handling was that it could be implemented with no impact on execution speed when itwasn’t used; that is, as long as you don’t throw an exception, your code runs as fast as it would without exception handling. Whether this is actually true depends on the particular compiler implementation you’re using. (See the description of the "zero-cost model" later in this section.).
   You can think of athrow expression as a call to a special system function that takes the exception object as an argument and backtracks up the chain of execution. For this to work, extra information needs to be put on the stack by the compiler, to aid in stack unwinding. To understand this, you need to know about the runtime stack. Whenever a function is called, information about that function is pushed onto the runtime stack in anactivation record instance (ARI), also called astack frame. A typical stack frame contains the address of the calling function (so execution can return to it), a pointer to the ARI of the function’s static parent (the scope that lexically contains the called function, so variables global to the function can be accessed), and a pointer to the function that called it (itsdynamic parent). The path that logically results from repetitively following the dynamic parent links is thedynamic chain, orcall chain, that we’ve mentioned previously in this chapter. This is how execution can backtrack when an exception is thrown, and it is the mechanism that makes it possible for components developed without knowledge of one another to communicate errors at runtime.
   To enable stack unwinding for exception handling, extra exception-related information about each function needs to be available for each stack frame. This information describes which destructors need to be called (so that local objects can be cleaned up), indicates whether the current function has atry block, and lists which exceptions the associated catch clauses can handle. Naturally there is space penalty for this extra information, so programs that support exception handling can be somewhat larger than those that don’t.[9]Even the compile-time size of programs using exception handling is greater, since the logic of how to generate the expanded stack frames during runtime must be generated by the compiler.
   To illustrate this, we compiled the following program both with and without exception-handling support in Borland C++ Builder and Microsoft Visual C++[10].
   struct HasDestructor {
     ~HasDestructor(){}
   };

   void g();      // for all we know, g may throw

   void f() {
      HasDestructor h;
      g();
   }

   If exception handling is enabled, the compiler must keep information about~HasDestructor( ) available at runtime in the ARI forf( ) (so it can destroyh properly shouldg( ) throw an exception). The following table summarizes the result of the compilations in terms of the size of the compiled (.obj) files (in bytes).Compiler\ModeWith Exception SupportWithout Exception SupportBorland616234Microsoft1162680

   Don’t take the percentage differences between the two modes too seriously. Remember that exceptions (should) typically constitute a small part of a program, so the space overhead tends to be much smaller (usually between 5 and 15 percent).
   You might think that this extra housekeeping would slow down execution, and you’d be correct. A clever compiler implementation can avoid that cost, however. Since information about exception-handling code and the offsets of local objects can be computed once at compile time, such information can be kept in a single place associated with each function, but not in each ARI. You essentially remove exception overhead from each ARI and, therefore, avoid the extra time to push them onto the stack. This approach is called thezero-cost model[11] of exception handling, and the optimized storage mentioned earlier is known as theshadow stack.[12]
   Summary
   Error recovery is a fundamental concern for every program you write, and it’s especially important in C++, in which one of the goals is to create program components for others to use. To create a robust system, each component must be robust.
   The goals for exception handling in C++ are to simplify the creation of large, reliable programs using less code than currently possible, with more confidence that your application doesn’t have an unhandled error. This is accomplished with little or no performance penalty and with low impact on existing code.
   Basic exceptions are not terribly difficult to learn; begin using them in your programs as soon as you can. Exceptions are one of those features that provide immediate and significant benefits to your project.
   Exercises
                4.             Create a class with member functions that throw exceptions. Within this class, make a nested class to use as an exception object. It takes a singlechar* as its argument; this represents a description string. Create a member function that throws this exception. (State this in the function’s exception specification.) Write atry block that calls this function and acatch clause that handles the exception by displaying its description string.
                5.             Rewrite the Stash class from Chapter 13 of Volume 1 so that it throwsout_of_range exceptions foroperator[].
                6.             Write a genericmain( ) that takes all exceptions and reports them as errors.
                7.             Create a class with its ownoperator new. This operator should allocate ten objects, and on the eleventh object "run out of memory" and throw an exception. Also add astatic member function that reclaims this memory. Now create amain( ) with atry block and acatch clause that calls the memory-restoration routine. Put these inside awhile loop, to demonstrate recovering from an exception and continuing execution.
                8.             Create a destructor that throws an exception, and write code to prove to yourself that this is a bad idea by showing that if a new exception is thrown before the handler for the existing one is reached,terminate( ) is called.
                9.             Prove to yourself that all exception objects (the ones that are thrown) are properly destroyed.
           10.             Prove to yourself that if you create an exception object on the heap and throw the pointer to that object, it will not be cleaned up.
            11.             Write a function with an exception specification that can throw four exception types: achar, anint, abool, and your own exception class. Catch each inmain( ) and verify the catch. Derive your exception class from a standard exception. Write the function in such a way that the system recovers and tries to execute it again.
            12.             Modify your solution to the exercise 8 to throw a double from the function, violating the exception specification. Catch the violation with your own unexpected handler that displays a message and exits the program gracefully (meaningabort( ) is not called).
            13.             Write aGarage class that has aCar that is having troubles with itsMotor. Use a function-leveltry block in theGarage class constructor to catch an exception (thrown from theMotor class) when itsCar object is initialized. Throw a different exception from the body of theGarage constructor’s handler and catch it inmain( ).
   2: Defensive programming
   Writing "perfect software" may be an elusive Holy Grail for developers, but a few defensive techniques, routinely applied, can go a long way toward narrowing the gap between code and ideal.
   Although the complexity of typical production software guarantees that testers will always have a job, chances are you still yearn to produce defect-free software. (At least we hope you do!) Object-oriented design techniques do much to corral the difficulty of large projects, to be sure. Eventually, however, you have to get down to writing loops and functions. These details of "programming in the small" become the building blocks of the implementation of larger components called for by your design efforts. If your loops are off by one or your functions calculate the correct values only "most" of the time, you’re in deep trouble no matter how fancy your overall methodology. In this chapter, we’re interested in coding practices that keep you on track toward a working solution regardless of the size of your project.
   Your code is, among other things, an expression of your attempt to solve a problem. It should be clear to the reader (including yourself) exactly what you were thinking when you designed that loop. At certain points in your program, you should be able to make bold statements that some condition or other holds. (If you can’t, you really haven’t yet solved the problem.) Such statements are calledinvariants, since they should invariably be true at the point where they appear in the code; if not, either your design is faulty, or your code does not accurately reflect your design. (In other words, you’ve got bugs!).
   To illustrate, consider how to write a program that plays the guessing game of Hi-lo. You play this game by having one person think of a number between 1 and 100, and having the other person guess the number. (We’ll let the computer do the guessing.) The person who holds the number tells the guesser whether their guess is high, low or correct. The best strategy for the guesser is of coursebinary search, which chooses the midpoint of the range of numbers where the sought-after number resides. The high-low response tells the guesser which half of the list holds the number, and the process repeats, halving the size of the active search range on each iteration. So how do you write a loop to drive the repetition properly? It’s not sufficient to just say.
   bool guessed = false;
   while (!guessed) {
     …
   }

   because a malicious user might respond deceitfully, and you could spend all day guessing. What assumption, however simple, are you making each time you guess? In other words, what condition should holdby design on each loop iteration?.
   The simple assumption we’re after is, of course, that the secret number is within the current active range of unguessed numbers, beginning with the range [1, 100]. Suppose we label the endpoints of the range with the variableslow andhigh. Each time you pass through the loop you need to make sure that if the number was in the range [low,high] at the beginning of the loop, you calculate the new range so that it still contains the number at the end of the current loop iteration.
   The goal is to express the loop invariant in code so that a violation can be detected at runtime. Unfortunately, since the computer doesn’t know the secret number, you can’t express this condition directly in code, but you can at least make a comment to that effect:
   while (!guessed) {
     // INVARIANT: the number is in the range [low, high]
     …
   }

   If we were to stop this thread of discussion right here, we would have accomplished a great deal if it helps clarify how you design loops. Fortunately, we can do better than that. What happens when the user says that a guess is too high when it isn’t or that it’s too low when it in fact is not? The deception will in effect exclude the secret number from the new subrange. Because one lie always leads to another, eventually your range will diminish to nothing (since you shrink it by half each time and the secret number isn’t in there). We can easily express this condition concretely, as the following program illustrates.
   //: C02:HiLo.cpp
   // Plays the game of Hi-lo to illustrate a loop invariant
   #include&lt;cstdlib&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     cout&lt;&lt; "Think of a number between 1 and 100\n";
   cout&lt;&lt; "I will make a guess; ";
   cout&lt;&lt; "tell me if I'm (H)igh or (L)ow\n";
     int low = 1, high = 100;
     bool guessed = false;
     while (!guessed) {
       // Invariant: the number is in the range [low, high]
       if (low&gt; high) {  // Invariant violation
         cout&lt;&lt; "You cheated! I quit\n";
         return EXIT_FAILURE;
       }
       int guess = (low + high) / 2;
       cout&lt;&lt; "My guess is "&lt;&lt; guess&lt;&lt; ". ";
       cout&lt;&lt; "(H)igh, (L)ow, or (E)qual? ";
       string response;
       cin&gt;&gt; response;
       switch(toupper(response[0])) {
         case 'H':
           high = guess - 1;
           break;
         case 'L':
           low = guess + 1;
           break;
         case 'E':
           guessed = true;
           break;
         default:
           cout&lt;&lt; "Invalid response\n";
           continue;
       }
     }
     cout&lt;&lt; "I got it!\n";
     return EXIT_SUCCESS;
   } ///:~

   The violation of the invariant is easily detected with the conditionif (low&gt; high), because if the user always tells the truth, we will always find the secret number before we run out of numbers to guess from. (See the last paragraph of the text that follows the programextractCode.cpp at the end of Chapter 3 for an explanation of the macrosEXIT_FAILURE andEXIT_SUCCESS).
   Assertions
   The condition in the Hi-lo program depends on user input, so you’re powerless to always prevent a violation of the invariant. Most often, however, invariants depend only on the code you write, so they will always hold, if you’ve implemented your design correctly. In this case, it is clearer to make anassertion, which is a positive statement that reveals your design decisions.
   For example, suppose you are implementing a vector of integers, which, as you know, is an expandable array that grows on demand. The function that adds an element to the vector must first verify that there is an open slot in the underlying array that holds the elements; otherwise, it needs to request more heap space and copy the existing elements to the new space before adding the new element (and of course deleting the old array). Such a function might look like the following:.
   void MyVector::push_back(int x) {
      if (nextSlot == capacity)
         grow();
      assert(nextSlot&lt; capacity);
      data[nextSlot++] = x;
   }

   In this example,data is a dynamic array ofints withcapacity slots andnextSlot slots in use. The purpose ofgrow( ) is to expand the size ofdata so that the new value ofcapacity is strictly greater thannextSlot. Proper behavior ofMyVector depends on this design decision, and it will never fail if the rest of the supporting code is correct, so weassert the condition with theassert( ) macro (defined in the header&lt;cassert&gt;).
   The Standard C libraryassert( ) macro is brief, to the point, and portable. If the condition in its parameter evaluates to non-zero, execution continues uninterrupted; if it doesn’t, a message containing the text of the offending expression along with its source file name and line number is printed to the standard error channel and the program aborts. Is that too drastic? In practice, it is much more drastic to let execution continue when a basic design assumption has failed. Your program needs to be fixed.
   If all goes well, you will have thoroughly tested your code with all assertions intact by the time the final product is deployed. (We’ll say more about testing later.) Depending on the nature of your application, the machine cycles needed to test all assertions at runtime might be too much of a performance hit in the field. If that’s the case, you can remove all the assertion code automatically by defining the macroNDEBUG and rebuilding the application.
   To see how this works, note that a typical implementation ofassert( ) looks something like this:
   #ifdef NDEBUG
     #define assert(cond) ((void)0)
   #else
     void assertImpl(const char*, const char*, long);
   #define assert(cond) \
     ((cond) ? (void)0 : assertImpl(???))
   #endif

   When the macroNDEBUG is defined, the code decays to the expression(void) 0, so all that’s left in the compilation stream is an essentially empty statement as a result of the semicolon you appended to eachassert( ) invocation. IfNDEBUG is not defined,assert(cond) expands to a conditional statement that, whencond is zero, calls a compiler-dependent function (which we namedassertImpl( )) with a string argument representing the text ofcond, along with the file name and line number where the assertion appeared. (We used "???" as a place holder in the example, but the string mentioned is actually computed there, along with the file name and the line number where the macro occurs in that file. How these values are obtained is immaterial to our discussion.) If you want to turn assertions on and off at different points in your program, you not only have to#define or#undef NDEBUG, but you have to re-include&lt;cassert&gt;. Macros are evaluated as the preprocessor encounters them and therefore use whateverNDEBUG state applies at that point in time. The most common way to defineNDEBUG once for an entire program is as a compiler option, whether through project settings in your visual environment or via the command line, as in
   mycc–DNDEBUG myfile.cpp

   Most compilers use the–D flag to define macro names. (Substitute the name of your compiler’s executable formycc above.) The advantage of this approach is that you can leave your assertions in the source code as an invaluable bit of documentation, and yet there is no runtime penalty. Because the code in an assertion disappears whenNDEBUG is defined, it is important that younever do work in an assertion. Only test conditions that do not change the state of your program.
   Whether usingNDEBUG for released code is a good idea remains a subject of debate. Tony Hoare, one of the most influential computer scientists of all time,[13] has suggested that turning off runtime checks such as assertions is similar to a sailing enthusiast who wears a life jacket while training on land and then discards it when he actually goes to sea.[14] If an assertion fails in production, you have a problem much worse than degradation in performance, so choose wisely.
   Not all conditions should be enforced by assertions, of course. User errors and runtime resource failures should be signaled by throwing exceptions, as we explained in detail in Chapter 1. It is tempting to use assertions for most error conditions while roughing out code, with the intent to replace many of them later with robust exception handling. Like any other temptation, use caution, since you might forget to make all the necessary changes later. Remember: assertions are intended to verify design decisions that will only fail because of faulty programmer logic. The ideal is to solve all assertion violations during development. Don’t use assertions for conditions that aren’t totally in your control (for example, conditions that depend on user input). In particular, you wouldn’t want to use assertions to validate function arguments; throw alogic_error instead.
   The use of assertions as a tool to ensure program correctness was formalized by Bertrand Meyer in hisDesign by Contract methodology.[15] Every function has an implicit contract with clients that, given certainpre-conditions, guarantees certainpost-conditions. In other words, the pre-conditions are the requirements for using the function, such as supplying arguments within certain ranges, and the post-conditions are the results delivered by the function, either by return value or by side-effect.
   What should you do when clients fail to give you valid input? They have broken the contract, and you need to let them know. As we mentioned earlier, this is not the best time to abort the program (although you’re justified in doing so since the contract was violated), but an exception is certainly in order. This is why the Standard C++ library throws exceptions derived fromlogic_error, such asout_of_range.[16] If there are functions that only you call, however, such as private functions in a class of your own design, theassert( ) macro is appropriate, since you have total control over the situation and you certainly want to debug your code before shipping.
   Since post-conditions are totally your responsibility, you might think assertions also apply, and you would be partially right. It is appropriate to use an assertion forany invariant at any time, including when a function has finished its work. This especially applies to class member functions that maintain the state of an object. In theMyVector example earlier, for instance, a reasonable invariant for all public member functions would be
   assert(0&lt;= nextSlot&& nextSlot&lt;= capacity);

   or, ifnextSlot is an unsigned integer, simply
   assert(nextSlot&lt;= capacity);

   Such an invariant is called aclass invariant and can reasonably be enforced by an assertion. Subclasses play the role ofsubcontractor to their base classes in that they must maintain the original contract the base class has with its clients. For this reason, the pre-conditions in derived classes must impose no extra requirements beyond those in the base contract, and the post-conditions must deliver at least as much.[17] 
   Validating results returned to the client, however, is nothing more or less thantesting, so using post-condition assertions in this case would be duplicating work. There’s nothing wrong with it; it’s just an exercise in redundancy. Yes, it’s good documentation, but more than one developer has been fooled into using post-condition assertions as asubstitute for unit testing. Bad idea!.
   A simple unit test framework
   Writing software is all about meeting requirements.[18] It doesn’t take much experience, however, to figure out that coming up with requirements in the first place is no easy task, and, more important, requirements are not static. It’s not unheard of to discover at a weekly project meeting that what you just spent the week doing is not exactly what the users really want.
   Frustrating? Yes. Reasonable? Also, yes! It is unreasonable to expect mere humans to be able to articulate software requirements in detail without sampling an evolving, working system. It's much better to specify a little, design a little, code a little, test a little. Then, after evaluating the outcome, do it all over again. The ability to develop from soup to nuts in such an iterative fashion is one of the great advances of this object-oriented era in software history. It requires nimble programmers who can craft resilient code. Change is hard.
   Ironically, another impetus for change comes from you, the programmer. The craftsperson in you likely has the habit of continually improving the physical design of working code. What maintenance programmer hasn’t had occasion to curse the aging, flagship company product as a convoluted patchwork of spaghetti, wholly resistant to modification? Management’s knee-jerk reluctance to let you tamper with a functioning system, while not totally unfounded, robs code of the resilience it needs to endure. "If it’s not broken, don’t fix it" eventually gives way to, "We can’t fix it—rewrite it." Change is necessary.
   Fortunately, our industry has finally gotten used to the discipline ofrefactoring, the art of internally restructuring code to improve its design, without changing the functionality visible to the user.[19] Such tweaks include extracting a new function from another, or its inverse, combining member functions; replacing a member function with an object; parameterizing a member function or class; and replacing conditionals with polymorphism. Refactoring helps code embrace evolution.
   Whether the force for change comes from users or programmers, however, there is still the risk that changes today will break what worked yesterday. What is needed is a way to build code that withstands the winds of change and actually improves over time.
   Many practices purport to support such a quick-on-your-feet motif, of which Extreme Programming is only one.[20] In this section we explore what we think is the key to making flexible, incremental development succeed: a ridiculously easy-to-use automated unit test framework. (Please note that we in no way mean to de-emphasize the role oftesters, software professionals who test others’ code for a living. They are indispensable. We are merely describing a way to help developers write better code.).
   Developers writeunit tests to gain the confidence to say the two most important things that any developer can say:
   1.I understand the requirements.
   2.My code meets those requirements to the best of my knowledge.
   There is no better way to ensure that you know what the code you're about to write should do than to write the unit tests first. This simple exercise helps focus the mind on the task ahead and will likely lead to working code faster than just jumping into coding. Or, to express it in XP terms: Testing + Programming isfaster than just Programming. Writing tests first also puts you on guard up front against boundary conditions that might cause your code to break, so your code is more robust right out of the chute.
   Once your code passes all your tests, you have the peace of mind that if the system you contribute to isn't working, it's not your fault. The statement "All my tests pass" is a powerful trump card in the workplace that cuts through any amount of politics and hand waving.
   Automated testing
   So what does a unit test look like? Too often developers just use some well-behaved input to produce some expected output, which they inspect visually. Two dangers exist in this approach. First, programs don't always receive only well-behaved input. We all know that we should test the boundaries of program input, but it's hard to think about this when you're trying to just get things working. If you write the test for a function first before you start coding, you can wear your "tester hat" and ask yourself, "What could possibly make this break?" Code a test that will prove the function you'll write isn't broken, and then put on your developer hat and make it happen. You'll write better code than if you hadn't written the test first.
   The second danger is that inspecting output visually is tedious and error prone. Most any such thing a human can do a computer can do, but without human error. It's better to formulate tests as collections ofBoolean expressions and have a test program report any failures.
   For example, suppose you need to build aDate class that has the following properties:
   ·         A date can be initialized with a string (YYYYMMDD), three integers (Y, M, D), or nothing (giving today's date).
   ·         A date object can yield its year, month, and day or a string of the form "YYYYMMDD".
   ·         All relational comparisons are available, as well as computing the duration between two dates (in years, months, and days).
   ·         Dates to be compared need to be able to span an arbitrary number of centuries (for example, 1600–2200).
   Your class can store three integers representing the year, month, and day. (Just be sure the year is at least 16 bits in size to satisfy the last bulleted item.) The interface for yourDate class might look like this:.
   // A first pass at Date.h
   #ifndef DATE_H
   #define DATE_H
   #include&lt;string&gt;

   class Date {
   public:
     // A struct to hold elapsed time:
     struct Duration {
       int years;
       int months;
       int days;
       Duration(int y, int m, int d)
         : years(y), months(m), days(d) {}
     };
     Date();
     Date(int year, int month, int day);
     Date(const std::string&);
     int getYear() const;
     int getMonth() const;
     int getDay() const;
     std::string toString() const;
   friend bool operator&lt;(const Date&, const Date&);
   friend bool operator&gt;(const Date&, const Date&);
   friend bool operator&lt;=(const Date&, const Date&);
   friend bool operator&gt;=(const Date&, const Date&);
   friend bool operator==(const Date&, const Date&);
   friend bool operator!=(const Date&, const Date&);
     friend Duration duration(const Date&, const Date&);
   };
   #endif

   Before you even think about implementation, you can solidify your grasp of the requirements for this class by writing the beginnings of a test program. You might come up with something like the following:
   //: C02:SimpleDateTest.cpp
   //{L} Date
   // You’ll need the full Date.h from the Appendix:
   #include "Date.h"
   #include&lt;iostream&gt;
   using namespace std;

   // Test machinery
   int nPass = 0, nFail = 0;
   void test(bool t) {
     if(t) nPass++; else nFail++;
   }

   int main() {
     Date mybday(1951, 10, 1);
     test(mybday.getYear() == 1951);
     test(mybday.getMonth() == 10);
     test(mybday.getDay() == 1);
     cout&lt;&lt; "Passed: "&lt;&lt; nPass&lt;&lt; ", Failed: "
         &lt;&lt; nFail&lt;&lt; endl;
   }
   /* Expected output:
   Passed: 3, Failed: 0
   */ ///:~

   In this trivial case, the functiontest( ) maintains the global variablesnPass andnFail. The only visual inspection you do is to read the final score. If a test failed, a more sophisticatedtest( ) displays an appropriate message. The framework described later in this chapter has such a test function, among other things.
   You can now implement enough of theDate class to get these tests to pass, and then you can proceed iteratively in like fashion until all the requirements are met. By writing tests first, you are more likely to think of corner cases that might break your upcoming implementation, and you’re more likely to write the code correctly the first time. Such an exercise might produce the following "final" version of a test for theDate class:.
   //: C02:SimpleDateTest2.cpp
   //{L} Date
   #include&lt;iostream&gt;
   #include "Date.h"
   using namespace std;

   // Test machinery
   int nPass = 0, nFail = 0;
   void test(bool t) {
     if(t) nPass++; else nFail++;
   }

   int main() {
     Date mybday(1951, 10, 1);
     Date today;
   Date myevebday("19510930");

     // Test the operators
     test(mybday&lt; today);
     test(mybday&lt;= today);
     test(mybday != today);
     test(mybday == mybday);
     test(mybday&gt;= mybday);
     test(mybday&lt;= mybday);
     test(myevebday&lt; mybday);
     test(mybday&gt; myevebday);
     test(mybday&gt;= myevebday);
     test(mybday != myevebday);

     // Test the functions
     test(mybday.getYear() == 1951);
     test(mybday.getMonth() == 10);
     test(mybday.getDay() == 1);
     test(myevebday.getYear() == 1951);
     test(myevebday.getMonth() == 9);
     test(myevebday.getDay() == 30);
     test(mybday.toString() == "19511001");
     test(myevebday.toString() == "19510930");

     // Test duration
     Date d2(2003, 7, 4);
     Date::Duration dur = duration(mybday, d2);
     test(dur.years == 51);
     test(dur.months == 9);
     test(dur.days == 3);

     // Report results:
     cout&lt;&lt; "Passed: "&lt;&lt; nPass&lt;&lt; ", Failed: "
         &lt;&lt; nFail&lt;&lt; endl;
   } ///:~

   The word "final" above was quoted because this test can of course be more fully developed. For example we haven’t tested that long durations are handled correctly. To save space on the printed page we’ll stop here, but you get the idea. The full implementation for theDate class is available in the filesDate.h andDate.cpp in the appendix and on the MindView website.[21][ ]
   The TestSuite Framework
   Some automated C++ unit test tools are available on the World Wide Web for download, such asCppUnit.[22] These are well designed and implemented, but our purpose here is not only to present a test mechanism that is easy to use, but also easy to understand internally and even tweak if necessary. So, in the spirit of "TheSimplestThingThatCouldPossiblyWork," we have developed theTestSuite Framework, a namespace namedTestSuite that contains two key classes:Test andSuite.
   TheTest class is an abstract class you derive from to define a test object. It keeps track of the number of passes and failures for you and displays the text of any test condition that fails. Your main task in defining a test is simply to override therun( ) member function, which should in turn call thetest_( ) macro for each Boolean test condition you define.
   To define a test for theDate class using the framework, you can inherit fromTest as shown in the following program:
   //: C02:DateTest.h
   #ifndef DATE_TEST_H
   #define DATE_TEST_H
   #include "Date.h"
   #include "../TestSuite/Test.h"

   class DateTest : public TestSuite::Test {
     Date mybday;
     Date today;
     Date myevebday;
   public:
     DateTest() : mybday(1951, 10, 1), myevebday("19510930") {
     }
     void run() {
       testOps();
       testFunctions();
       testDuration();
     }
     void testOps() {
       test_(mybday&lt; today);
       test_(mybday&lt;= today);
       test_(mybday != today);
       test_(mybday == mybday);
       test_(mybday&gt;= mybday);
       test_(mybday&lt;= mybday);
       test_(myevebday&lt; mybday);
       test_(mybday&gt; myevebday);
       test_(mybday&gt;= myevebday);
       test_(mybday != myevebday);
     }
     void testFunctions() {
       test_(mybday.getYear() == 1951);
       test_(mybday.getMonth() == 10);
       test_(mybday.getDay() == 1);
       test_(myevebday.getYear() == 1951);
       test_(myevebday.getMonth() == 9);
       test_(myevebday.getDay() == 30);
       test_(mybday.toString() == "19511001");
       test_(myevebday.toString() == "19510930");
     }
     void testDuration() {
       Date d2(2003, 7, 4);
       Date::Duration dur = duration(mybday, d2);
       test_(dur.years == 51);
       test_(dur.months == 9);
       test_(dur.days == 3);
     }
   };
   #endif ///:~

   Running the test is a simple matter of instantiating aDateTest object and calling itsrun( ) member function.
   //: C02:DateTest.cpp
   // Automated Testing (with a Framework)
   //{L} Date ../TestSuite/Test
   #include&lt;iostream&gt;
   #include "DateTest.h"
   using namespace std;

   int main() {
     DateTest test;
     test.run();
     return test.report();
   }
   /* Output:
   Test "DateTest":
           Passed: 21,      Failed: 0
   */ ///:~

   TheTest::report( ) function displays the previous output and returns the number of failures, so it is suitable to use as a return value frommain( ).
   TheTest class uses RTTI[23] to get the name of your class (for example,DateTest) for the report. There is also asetStream( ) member function if you want the test results sent to a file instead of to the standard output (the default). You’ll see theTest class implementation later in this chapter.
   Thetest_ ( ) macro can extract the text of the Boolean condition that fails, along with its file name and line number.[24] To see what happens when a failure occurs, you can introduce an intentional error in the code, say by reversing the condition in the first call totest_( ) inDateTest::testOps( ) in the previous example code. The output indicates exactly what test was in error and where it happened:.
   DateTest failure: (mybday&gt; today) , DateTest.h (line 31)
   Test "DateTest":
           Passed: 20      Failed: 1

   In addition totest_( ), the framework includes the functionssucceed_( ) andfail_( ), for cases in which a Boolean test won't do. These functions apply when the class you’re testing might throw exceptions. During testing, you want to arrange an input set that will cause the exception to occur to make sure it’s doing its job. If it doesn’t, it’s an error, in which case you callfail_( ) explicitly to display a message and update the failure count. If it does throw the exception as expected, you callsucceed_ ( ) to update the success count.
   To illustrate, suppose we update the specification of the two non-defaultDate constructors to throw aDateError exception (a type nested insideDate and derived fromstd::logic_error) if the input parameters do not represent a valid date:.
   Date(const string& s) throw(DateError);
   Date(int year, int month, int day) throw(DateError);

   TheDateTest::run( ) member function can now call the following function to test the exception handling:
     void testExceptions() {
       try {
         Date d(0,0,0);  // Invalid
         fail_("Invalid date undetected in Date int ctor");
       }
       catch (Date::DateError&) {
         succeed_();
       }
       try {
         Date d("");  // Invalid
         fail_("Invalid date undetected in Date string ctor");
       }
       catch (Date::DateError&) {
         succeed_();
       }
     }

   In both cases, if an exception is not thrown, it is an error. Notice that you have to manually pass a message tofail_( ), since no Boolean expression is being evaluated.
   Test suites
   Real projects usually contain many classes, so you need a way to group tests so that you can just push a single button to test the entire project.[25] TheSuite class allows you to collect tests into a functional unit. You deriveTest objects to aSuite with theaddTest( ) member function, or you can swallow an entire existing suite withaddSuite( ). We have a number of date-related classes to illustrate how to use a test suite. Here's an actual test run:.
   // Illustrates a suite of related tests
   #include&lt;iostream&gt;
   #include "suite.h"         // includes test.h
   #include "JulianDateTest.h"
   #include "JulianTimeTest.h"
   #include "MonthInfoTest.h"
   #include "DateTest.h"
   #include "TimeTest.h"
   using namespace std;

   int main() {
       Suite s("Date and Time Tests");
       s.addTest(new MonthInfoTest);
       s.addTest(new JulianDateTest);
       s.addTest(new JulianTimeTest);
       s.addTest(new DateTest);
       s.addTest(new TimeTest);
       s.run();
       long nFail = s.report();
       s.free();
       return nFail;
   }
   /* Output:
   Suite "Date and Time Tests"
   ===========================
   Test "MonthInfoTest":
      Passed: 18  Failed: 0
   Test "JulianDateTest":
      Passed: 36  Failed: 0
   Test "JulianTimeTest":
      Passed: 29  Failed: 0
   Test "DateTest":
      Passed: 57  Failed: 0
   Test "TimeTest":
      Passed: 84  Failed: 0
   ===========================
   */

   Each of the five test files included as headers tests a unique date component. You must give the suite a name when you create it. TheSuite::run( ) member function callsTest::run( ) for each of its contained tests. Much the same thing happens forSuite::report( ), except that it is possible to send the individual test reports to a destination stream that is different from that of the suite report. If the test passed toaddSuite( ) has a stream pointer assigned already, it keeps it. Otherwise, it gets its stream from theSuite object. (As withTest, there is a second argument to the suite constructor that defaults tostd::cout.) The destructor forSuite does not automatically delete the containedTest pointers because they don’t have to reside on the heap; that’s the job ofSuite::free( ).
   The test framework code
   The test framework code library is in a subdirectory calledTestSuite in the code distribution available on the MindView website. To use it, include the search path for theTestSuite subdirectory in your header, link the object files, and include theTestSuite subdirectory in the library search path. Here is the header forTest.h:
   //: TestSuite:Test.h
   #ifndef TEST_H
   #define TEST_H
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include&lt;cassert&gt;
   using std::string;
   using std::ostream;
   using std::cout;

   // The following have underscores because
   // they are macros. For consistency,
   // succeed_() also has an underscore.

   #define test_(cond) \
     do_test(cond, #cond, __FILE__, __LINE__)
   #define fail_(str) \
     do_fail(str, __FILE__, __LINE__)

   namespace TestSuite {

   class Test {
   public:
     Test(ostream* osptr =&cout);
     virtual ~Test(){}
     virtual void run() = 0;
     long getNumPassed() const;
     long getNumFailed() const;
     const ostream* getStream() const;
     void setStream(ostream* osptr);
     void succeed_();
     long report() const;
     virtual void reset();
   protected:
     void do_test(bool cond, const string& lbl,
       const char* fname, long lineno);
     void do_fail(const string& lbl,
       const char* fname, long lineno);
   private:
     ostream* osptr;
     long nPass;
     long nFail;
     // Disallowed:
     Test(const Test&);
     Test& operator=(const Test&);
   };

   inline Test::Test(ostream* osptr) {
     this-&gt;osptr = osptr;
     nPass = nFail = 0;
   }

   inline long Test::getNumPassed() const {
     return nPass;
   }

   inline long Test::getNumFailed() const {
     return nFail;
   }

   inline const ostream* Test::getStream() const {
     return osptr;
   }

   inline void Test::setStream(ostream* osptr) {
     this-&gt;osptr = osptr;
   }

   inline void Test::succeed_() {
     ++nPass;
   }

   inline void Test::reset() {
     nPass = nFail = 0;
   }

   } // namespace TestSuite
   #endif // TEST_H ///:~

   There are three virtual functions in theTest class:
   ·         A virtual destructor
   ·         The functionreset( )
   ·         The pure virtual functionrun( )
   As explained in Volume 1, it is an error to delete a derived heap object through a base pointer unless the base class has a virtual destructor. Any class intended to be a base class (usually evidenced by the presence of at least one other virtual function) should have a virtual destructor. The default implementation of theTest::reset( ) resets the success and failure counters to zero. You might want to override this function to reset the state of the data in your derived test object; just be sure to callTest::reset( ) explicitly in your override so that the counters are reset. TheTest::run( ) member function is pure virtual, of course, since you are required to override it in your derived class.
   Thetest_( ) andfail_( ) macros can include file name and line number information available from the preprocessor. We originally omitted the trailing underscores in the names, but the originalfail( ) macro collided withios::fail( ), causing all kinds of compiler errors.
   Here is the implementation ofTest:
   //: TestSuite:Test.cpp {O}
   #include "Test.h"
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;  // Note: Visual C++ requires /GR
   using namespace std;
   using namespace TestSuite;

   void Test::do_test(bool cond,
     const std::string& lbl, const char* fname,
     long lineno) {
     if (!cond)
       do_fail(lbl, fname, lineno);
     else
       succeed_();
   }

   void Test::do_fail(const std::string& lbl,
     const char* fname, long lineno) {
     ++nFail;
     if (osptr) {
       *osptr&lt;&lt; typeid(*this).name()
             &lt;&lt; "failure: ("&lt;&lt; lbl&lt;&lt; ") , "
             &lt;&lt; fname
             &lt;&lt; " (line "&lt;&lt; lineno&lt;&lt; ")\n";
     }
   }

   long Test::report() const {
     if (osptr) {
       *osptr&lt;&lt; "Test \""&lt;&lt; typeid(*this).name()
              &lt;&lt; "\":\n\tPassed: "&lt;&lt; nPass
             &lt;&lt; "\tFailed: "&lt;&lt; nFail
             &lt;&lt; endl;
     }
     return nFail;
   } ///:~

   No rocket science here. TheTest class just keeps track of the number of successes and failures as well as the stream where you wantTest::report( ) to display the results. Thetest_( ) andfail_( ) macros extract the current file name and line number information from the preprocessor and pass the file name todo_test( ) and the line number todo_fail( ), which do the actual work of displaying a message and updating the appropriate counter. We can’t think of a good reason to allow copy and assignment of test objects, so we have disallowed these operations by making their prototypes private and omitting their respective function bodies.
   Here is the header file forSuite:.
   //: TestSuite:Suite.h
   #ifndef SUITE_H
   #define SUITE_H
   #include "../TestSuite/Test.h"
   #include&lt;vector&gt;
   #include&lt;stdexcept&gt;
   using std::vector;
   using std::logic_error;

   namespace TestSuite {

   class TestSuiteError : public logic_error {
   public:
     TestSuiteError(const string& s = "")
       : logic_error(s) {}
   };

   class Suite {
   public:
     Suite(const string& name, ostream* osptr =&cout);
     string getName() const;
     long getNumPassed() const;
     long getNumFailed() const;
     const ostream* getStream() const;
     void setStream(ostream* osptr);
     void addTest(Test* t) throw (TestSuiteError);
     void addSuite(const Suite&);
     void run();  // Calls Test::run() repeatedly
     long report() const;
     void free();  // Deletes tests
   private:
     string name;
     ostream* osptr;
     vector&lt;Test*&gt; tests;
     void reset();
     // Disallowed ops:
     Suite(const Suite&);
     Suite& operator=(const Suite&);
   };

   inline
   Suite::Suite(const string& name, ostream* osptr)
      : name(name) {
     this-&gt;osptr = osptr;
   }

   inline string Suite::getName() const {
     return name;
   }

   inline const ostream* Suite::getStream() const {
     return osptr;
   }

   inline void Suite::setStream(ostream* osptr) {
     this-&gt;osptr = osptr;
   }

   } // namespace TestSuite
   #endif // SUITE_H ///:~

   TheSuite class holds pointers to itsTest objects in a vector. Notice the exception specification on theaddTest( ) member function. When you add a test to a suite,Suite::addTest( ) verifies that the pointer you pass is not null; if it is null, it throws aTestSuiteError exception. Since this makes it impossible to add a null pointer to a suite,addSuite( ) asserts this condition on each of its tests, as do the other functions that traverse the vector of tests (see the following implementation). Copy and assignment are disallowed as they are in theTest class.
   //: TestSuite:Suite.cpp {O}
   #include "Suite.h"
   #include&lt;iostream&gt;
   #include&lt;cassert&gt;
   using namespace std;
   using namespace TestSuite;

   void Suite::addTest(Test* t) throw(TestSuiteError) {
     // Verify test is valid and has a stream:
     if (t == 0)
       throw TestSuiteError(
         "Null test in Suite::addTest");
     else if (osptr&& !t-&gt;getStream())
       t-&gt;setStream(osptr);
     tests.push_back(t);
     t-&gt;reset();
   }

   void Suite::addSuite(const Suite& s) {
   for (size_t i = 0; i&lt; s.tests.size(); ++i) {
     assert(tests[i]);
   addTest(s.tests[i]);
     }
   }

   void Suite::free() {
     for (size_t i = 0; i&lt; tests.size(); ++i) {
       delete tests[i];
       tests[i] = 0;
     }
   }

   void Suite::run() {
     reset();
     for (size_t i = 0; i&lt; tests.size(); ++i) {
       assert(tests[i]);
       tests[i]-&gt;run();
     }
   }

   long Suite::report() const {
     if (osptr) {
       long totFail = 0;
       *osptr&lt;&lt; "Suite \""&lt;&lt; name
               &lt;&lt; "\"\n=======";
       size_t i;
       for (i = 0; i&lt; name.size(); ++i)
         *osptr&lt;&lt; '=';
       *osptr&lt;&lt; "=\n";
       for (i = 0; i&lt; tests.size(); ++i) {
         assert(tests[i]);
         totFail += tests[i]-&gt;report();
       }
       *osptr&lt;&lt; "=======";
       for (i = 0; i&lt; name.size(); ++i)
         *osptr&lt;&lt; '=';
       *osptr&lt;&lt; "=\n";
       return totFail;
     }
     else
       return getNumFailed();
   }

   long Suite::getNumPassed() const {
     long totPass = 0;
     for (size_t i = 0; i&lt; tests.size(); ++i) {
       assert(tests[i]);
       totPass += tests[i]-&gt;getNumPassed();
     }
     return totPass;
   }

   long Suite::getNumFailed() const {
     long totFail = 0;
     for (size_t i = 0; i&lt; tests.size(); ++i) {
       assert(tests[i]);
       totFail += tests[i]-&gt;getNumFailed();
     }
     return totFail;
   }

   void Suite::reset() {
     for (size_t i = 0; i&lt; tests.size(); ++i) {
       assert(tests[i]);
       tests[i]-&gt;reset();
     }
   } ///:~

   We will be using theTestSuite framework wherever it applies throughout the rest of this book.
   Debugging techniques
   The best debugging habit to get into is to use assertions as explained in the beginning of this chapter; by doing so you’ll be more likely to find logic errors before they cause real trouble. This section contains some other tips and techniques that might help during debugging.
   Trace macros
   Sometimes it’s helpful to print the code of each statement as it is executed, either tocout or to a trace file. Here’s a preprocessor macro to accomplish this:.
   #define TRACE(ARG) cout&lt;&lt; #ARG&lt;&lt; endl; ARG

   Now you can go through and surround the statements you trace with this macro. Of course, it can introduce problems. For example, if you take the statement:.
   for(int i = 0; i&lt; 100; i++)
     cout&lt;&lt; i&lt;&lt; endl;

   and put both lines insideTRACE( ) macros, you get this:
   TRACE(for(int i = 0; i&lt; 100; i++))
   TRACE(  cout&lt;&lt; i&lt;&lt; endl;)

   which expands to this:
   cout&lt;&lt; "for(int i = 0; i&lt; 100; i++)"&lt;&lt; endl;
   for(int i = 0; i&lt; 100; i++)
     cout&lt;&lt; "cout&lt;&lt; i&lt;&lt; endl;"&lt;&lt; endl;
   cout&lt;&lt; i&lt;&lt; endl;

   which isn’t exactly what you want. Thus, you must use this technique carefully.
   The following is a variation on theTRACE( ) macro:
   #define D(a) cout&lt;&lt; #a "=["&lt;&lt; a&lt;&lt; "]"&lt;&lt; '\n';

   If you want to display an expression, you simply put it inside a call toD( ). The expression is displayed, followed by its value (assuming there’s an overloaded operator&lt;&lt; for the result type). For example, you can sayD(a + b). Thus, you can use this macro any time you want to test an intermediate value to make sure things are okay.
   Of course, these two macros are actually just the two most fundamental things you do with a debugger: trace through the code execution and display values. A good debugger is an excellent productivity tool, but sometimes debuggers are not available, or it’s not convenient to use them. These techniques always work, regardless of the situation.
   Trace file
   DISCLAIMER: This section and the next contain code which is officially unsanctioned by the C++ standard. In particular, we redefinecout andnew via macros, which can cause surprising results if you’re not careful. Our examples work on all the compilers we use, however, and provide useful information. This is the only place in this book where we will depart from the sanctity of standard-compliant coding practice. Use at your own risk!
   The following code allows you to easily create a trace file and send all the output that would normally go tocout into the file. All you have to do is#define TRACEON and include the header file (of course, it’s fairly easy just to write the two key lines right into your file):.
   //: C03:Trace.h
   // Creating a trace file
   #ifndef TRACE_H
   #define TRACE_H
   #include&lt;fstream&gt;

   #ifdef TRACEON
   ofstream TRACEFILE__("TRACE.OUT");
   #define cout TRACEFILE__
   #endif

   #endif // TRACE_H ///:~


   Here’s a simple test of the previous file:
   //: C03:Tracetst.cpp
   // Test of trace.h
   #include "../require.h"
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   using namespace std;

   #define TRACEON
   #include "Trace.h"

   int main() {
     ifstream f("Tracetst.cpp");
     assure(f, "Tracetst.cpp");
     cout&lt;&lt; f.rdbuf(); // Dumps file contents to file
   } ///:~


   Finding memory leaks
   The following straightforward debugging techniques are explained Volume 1.
   1.       For array bounds checking, use theArray template inC16:Array3.cpp of Volume 1 for all arrays. You can turn off the checking and increase efficiency when you’re ready to ship. (This doesn’t deal with the case of taking a pointer to an array, though—perhaps that could be made into a template somehow as well).
   2.      Check for non-virtual destructors in base classes.
   Tracking new/delete and malloc/free
   Common problems with memory allocation include mistakenly callingdelete for memory not on the free store, deleting the free store more than once, and, most often, forgetting to delete such a pointer at all. This section discusses a system that can help you track down these kinds of problems.
   As anadditional disclaimer beyond that of the preceding section: because of the way we overloadnew, the following technique may not work on all platforms, and will only work for programs that do not call thefunctionoperator new( ) explicitly. We have been quite careful in this book to only present code that fully conforms to the C++ standard, but in this one instance we’re making an exception for the following reasons:
                1.             Even though it’s technically illegal, it works on many compilers.[26]
                2.             We illustrate some useful thinking along the way.

   To use the memory checking system, you simply include the header fileMemCheck.h, link theMemCheck.obj file into your application, so that all the calls tonew anddelete are intercepted, and call the macroMEM_ON( ) (explained later in this section) to initiate memory tracing. A trace of all allocations and deallocations is printed to the standard output (viastdout). When you use this system, all calls tonew store information about the file and line where they were called. This is accomplished by using theplacement syntax foroperator new.[27] Although you typically use the placement syntax when you need to place objects at a specific point in memory, it also allows you to create anoperator new( ) with any number of arguments. This is used to advantage in the following example to store the results of the__FILE__ and__LINE__ macros whenevernew is called:.
   //: C02:MemCheck.h
   #ifndef MEMCHECK_H
   #define MEMCHECK_H
   #include&lt;cstddef&gt;  // for size_t

   // Hijack the new operator (both scalar and array versions)
   void* operator new(std::size_t, const char*, long);
   void* operator new[](std::size_t, const char*, long);
   #define new new (__FILE__, __LINE__)

   extern bool traceFlag;
   #define TRACE_ON() traceFlag = true
   #define TRACE_OFF() traceFlag = false

   extern bool activeFlag;
   #define MEM_ON() activeFlag = true
   #define MEM_OFF() activeFlag = false

   #endif
   ///:~

   It is important that you include this file in any source file in which you want to track free store activity, but include itlast (after your other#include directives). Most headers in the standard library are templates, and since most compilers use theinclusion model of template compilation (meaning all source code is in the headers), the macro that replacesnew inMemCheck.h would usurp all instances of thenew operator in the library source code (and would likely result in compile errors). Besides, you are only interested in tracking your own memory errors, not the library’s.
   In the following file, which contains the memory tracking implementation, everything is done with C standard I/O rather than with C++ iostreams. It shouldn’t make a difference, really, since we’re not interfering with iostreams’ use of the free store, but it’s safer to not take a chance. (Besides, we tried it. Some compilers complained, but all compilers were happy with the&lt;stdio&gt; version.).
   //: C02:MemCheck.cpp {O}
   #include&lt;cstdio&gt;
   #include&lt;cstdlib&gt;
   #include&lt;cassert&gt;
   using namespace std;
   #undef new

   // Global flags set by macros in MemCheck.h
   bool traceFlag = true;
   bool activeFlag = false;

   namespace {

   // Memory map entry type
   struct Info {
     void* ptr;
     const char* file;
     long line;
   };

   // Memory map data
   const size_t MAXPTRS = 10000u;
   Info memMap[MAXPTRS];
   size_t nptrs = 0;

   // Searches the map for an address
   int findPtr(void* p) {
     for (int i = 0; i&lt; nptrs; ++i)
       if (memMap[i].ptr == p)
         return i;
     return -1;
   }

   void delPtr(void* p) {
     int pos = findPtr(p);
     assert(p&gt;= 0);
     // Remove pointer from map
     for (size_t i = pos; i&lt; nptrs-1; ++i)
       memMap[i] = memMap[i+1];
     --nptrs;
   }

   // Dummy type for static destructor
   struct Sentinel {
     ~Sentinel() {
       if (nptrs&gt; 0) {
         printf("Leaked memory at:\n");
         for (size_t i = 0; i&lt; nptrs; ++i)
           printf("\t%p (file: %s, line %ld)\n",
             memMap[i].ptr, memMap[i].file, memMap[i].line);
       }
       else
         printf("No user memory leaks!\n");
     }
   };

   // Static dummy object
   Sentinel s;

   } // End anonymous namespace

   // Overload scalar new
   void* operator new(size_t siz, const char* file,
     long line) {
     void* p = malloc(siz);
     if (activeFlag) {
       if (nptrs == MAXPTRS) {
         printf("memory map too small (increase MAXPTRS)\n");
         exit(1);
       }
       memMap[nptrs].ptr = p;
       memMap[nptrs].file = file;
       memMap[nptrs].line = line;
       ++nptrs;
     }
     if (traceFlag) {
       printf("Allocated %u bytes at address %p ", siz, p);
       printf("(file: %s, line: %ld)\n", file, line);
     }
     return p;
   }

   // Overload array new
   void* operator new[](size_t siz, const char* file,
     long line) {
     return operator new(siz, file, line);
   }

   // Override scalar delete
   void operator delete(void* p) {
     if (findPtr(p)&gt;= 0) {
       free(p);
       assert(nptrs&gt; 0);
       delPtr(p);
       if (traceFlag)
         printf("Deleted memory at address %p\n", p);
     }
     else if (!p&& activeFlag)
       printf("Attempt to delete unknown pointer: %p\n", p);
   }

   // Override array delete
   void operator delete[](void* p) {
     operator delete(p);
   } ///:~

   The Boolean flagstraceFlag andactiveFlag are global, so they can be modified in your code by the macrosTRACE_ON( ),TRACE_OFF( ),MEM_ON( ), andMEM_OFF( ). In general, enclose all the code in yourmain( ) within aMEM_ON( )-MEM_OFF( ) pair so that memory is always tracked. Tracing, which echoes the activity of the replacement functions foroperator new( ) andoperator delete( ), is on by default, but you can turn it off withTRACE_OFF( ). In any case, the final results are always printed (see the test runs later in this chapter).
   TheMemCheck facility tracks memory by keeping all addresses allocated byoperator new( ) in an array ofInfo structures, which also holds the file name and line number where the call tonew occurred. As much information as possible is kept inside the anonymous namespace so as not to collide with any names you might have placed in the global namespace. TheSentinel class exists solely to have a static object’s destructor called as the program shuts down. This destructor inspectsmemMap to see if any pointers are waiting to be deleted (in which case you have a memory leak).
   Ouroperator new( ) usesmalloc( ) to get memory, and then adds the pointer and its associated file information tomemMap. Theoperator delete( ) function undoes all that work by callingfree( ) and decrementingnptrs, but first it checks to see if the pointer in question is in the map in the first place. If it isn’t, either you’re trying to delete an address that isn’t on the free store, or you’re trying to delete one that’s already been deleted and therefore previously removed from the map. TheactiveFlag variable is important here because we don’t want to process any deallocations from any system shutdown activity. By callingMEM_OFF( ) at the end of your code,activeFlag will be set tofalse, and such subsequent calls todelete will be ignored. (Of course, that’s bad in a real program, but as we said earlier, our purpose here is to findyour leaks; we’re not debugging the library.) For simplicity, we forward all work for arraynew anddelete to their scalar counterparts.
   The following is a simple test using theMemCheck facility.
   //: C02:MemTest.cpp
   //{L} MemCheck
   // Test of MemCheck system
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;cstring&gt;
   #include "MemCheck.h"   // Must appear last!
   using namespace std;

   class Foo {
     char* s;
   public:
     Foo(const char*s ) {
       this-&gt;s = new char[strlen(s) + 1];
       strcpy(this-&gt;s, s);
     }
     ~Foo() {
       delete [] s;
     }
   };

   int main() {
     MEM_ON();
     cout&lt;&lt; "hello\n";
     int* p = new int;
     delete p;
     int* q = new int[3];
     delete [] q;
     int* r;
     delete r;
     vector&lt;int&gt; v;
     v.push_back(1);
     Foo s("goodbye");
     MEM_OFF();
   } ///:~

   This example verifies that you can useMemCheck in the presence of streams, standard containers, and classes that allocate memory in constructors. The pointersp andq are allocated and deallocated without any problem, butr is not a valid heap pointer, so the output indicates the error as an attempt to delete an unknown pointer.
   hello
   Allocated 4 bytes at address 0xa010778 (file: memtest.cpp, line: 25)
   Deleted memory at address 0xa010778
   Allocated 12 bytes at address 0xa010778 (file: memtest.cpp, line: 27)
   Deleted memory at address 0xa010778
   Attempt to delete unknown pointer: 0x1
   Allocated 8 bytes at address 0xa0108c0 (file: memtest.cpp, line: 14)
   Deleted memory at address 0xa0108c0
   No user memory leaks!

   Because of the call toMEM_OFF( ), no subsequent calls tooperator delete( ) byvector orostream are processed. You still might get some calls todelete from reallocations performed by the containers.
   If you callTRACE_OFF( ) at the beginning of the program, the output is as follows:
   hello
   Attempt to delete unknown pointer: 0x1
   No user memory leaks!.

   Summary
   Much of the headache of software engineering can be avoided by being deliberate about what you’re doing. You’ve probably been using mental assertions as you’ve crafted your loops and functions anyway, even if you haven’t routinely used theassert( ) macro. If you’ll useassert( ), you’ll find logic errors sooner and end up with more readable code as well. Remember to only use assertions for invariants, though, and not for runtime error handling.
   Nothing will give you more peace of mind than thoroughly tested code. If it’s been a hassle for you in the past, use an automated framework, such as the one we’ve presented here, to integrate routine testing into your daily work. You (and your users!) will be glad you did.
   Exercises
                1.             Write a test program using theTestSuite Framework for the standard vector class that thoroughly tests the following member functions with a vector of integers:push_back( ) (appends an element to the end of the vector),front( ) (returns the first element in the vector),back( ) (returns the last element in the vector),pop_back( ) (removes the last element without returning it),at( ) (returns the element in a specified index position), andsize( ) (returns the number of elements). Be sure to verify thatvector::at( ) throws astd::out_of_range exception if the supplied index is out of range.
            14.             Suppose you are asked to develop a class namedRational that supports rational numbers (fractions). The fraction in aRational object should always be stored in lowest terms, and a denominator of zero is an error. Here is a sample interface for such aRational class:
   class Rational {
   public:
      Rational(int numerator = 0, int denominator = 1);
      Rational operator-() const;
      friend Rational operator+(const Rational&,
                 const Rational&);
      friend Rational operator-(const Rational&,
                 const Rational&);
      friend Rational operator*(const Rational&,
                 const Rational&);
      friend Rational operator/(const Rational&,
                 const Rational&);
      friend ostream& operator&lt;&lt;(ostream&,
                  const Rational&);
      friend istream& operator&gt;&gt;(istream&, Rational&);
      Rational& operator+=(const Rational&);
      Rational& operator-=(const Rational&);
      Rational& operator*=(const Rational&);
      Rational& operator/=(const Rational&);
      friend bool operator&lt;(const Rational&,
             const Rational&);
      friend bool operator&gt;(const Rational&,
             const Rational&);
      friend bool operator&lt;=(const Rational&,
                             const Rational&);
      friend bool operator&gt;=(const Rational&,
              const Rational&);
      friend bool operator==(const Rational&,
              const Rational&);
      friend bool operator!=(const Rational&,
              const Rational&);
   };

   Write a complete specification for this class, including pre-conditions, post-conditions, and exception specifications.
            15.             Write a test using theTestSuite framework that thoroughly tests all the specifications from the previous exercise, including testing exceptions.
            16.             Implement theRational class so that all the tests from the previous exercise pass. Use assertions only for invariants.
            17.             The fileBuggedSearch.cpp below contains a binary search function that searches the range[beg, end) forwhat. There are some bugs in the algorithm. Use the trace techniques from this chapter to debug the search function.

   // BuggedSearch.cpp
   #include "../TestSuite/Test.h"
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;cassert&gt;
   #include&lt;fstream&gt;
   using namespace std;

   // This function is only one with bugs
   int* binarySearch(int* beg, int* end, int what) {
     while(end - beg != 1) {
       if(*beg == what) return beg;
       int mid = (end - beg) / 2;
       if(what&lt;= beg[mid]) end = beg + mid;
       else beg = beg + mid;
     }
     return 0;
   }
   class BinarySearchTest : public TestSuite::Test {
     enum { sz = 10 };
     int* data;
     int max; //Track largest number
     int current; // Current non-contained number
   // Used in notContained()
     // Find the next number not contained in the array
     int notContained() {
       while(data[current] + 1 == data[current + 1])
        current++;
       if(current&gt;= sz) return max + 1;
       int retValue = data[current++] + 1;
       return retValue;
     }
     void setData() {
       data = new int[sz];
       assert(!max);
       // Input values with increments of one.  Leave
       // out some values on both odd and even indexes.
       for(int i = 0; i&lt; sz;
           rand() % 2 == 0 ? max += 1 : max += 2)
         data[i++] = max;
     }
     void testInBound() {
       // Test locations both odd and even
       // not contained and contained
       for(int i = sz; --i&gt;=0;)
         test_(binarySearch(data, data + sz, data[i]));
       for(int i = notContained(); i&lt; max;
                      i = notContained())
         test_(!binarySearch(data, data + sz, i));
     }
     void testOutBounds() {
       // Test lower values
       for(int i = data[0]; --i&gt; data[0] - 100;)
         test_(!binarySearch(data, data + sz, i));
       // Test higher values
       for(int i = data[sz - 1];
           ++i&lt; data[sz -1] + 100;)
         test_(!binarySearch(data, data + sz, i));
     }
   public:
     BinarySearchTest() {
       max = current = 0;
     }
     void run() {
       srand(time(0));
       setData();
       testInBound();
       testOutBounds();
       delete [] data;
     }
   };
   int main() {
     BinarySearchTest t;
     t.run();
     return t.report();
   }
   Part 2.The Standard C++ Library
   Standard C++ not only incorporates all the Standard C libraries (with small additions and changes to support type safety), it also adds libraries of its own. These libraries are far more powerful than those in Standard C; the leverage you get from them is analogous to the leverage you get from changing from C to C++.
   This part of the book gives you an in-depth introduction to key portions of the Standard C++ library.
   The most complete and also the most obscure reference to the full libraries is the Standard itself. Bjarne Stroustrup’sThe C++ Programming Language, Third Edition(Addison-Wesley, 2000) remains a reliable reference for both the language and the library. The most celebrated library-only reference isThe C++ Standard Library: A Tutorial and Reference, by Nicolai Josuttis (Addison-Wesley, 1999). The goal of the chapters in this part of the book is to provide you with an encyclopedia of descriptions and examples so that you’ll have a good starting point for solving any problem that requires the use of the Standard libraries. However, some techniques and topics are rarely used and are not covered here. If you can’t find it in these chapters, reach for the other two books; this book is not intended to replace thosebooks but rather to complement them. In particular, we hope that after going through the material in the following chapters you’ll have a much easier time understanding those books.
   You will notice that these chapters do not contain exhaustive documentation describing every function and class in the Standard C++ library. We’ve left the full descriptions to others; in particular to P.J. Plauger’sDinkumware C/C++ Library Reference at http://www.dinkumware.com. This is an excellent online source of standard library documentation in HTML format that you can keep resident on your computer and view with a Web browser whenever you need to look up something. . You can view this online and purchase it for local viewing. It contains complete reference pages for the both the C and C++ libraries (so it’s good to use for all your Standard C/C++ programming questions). Electronic documentation is effective not only because you can always have it with you, but also because you can do an electronic search for what you want.
   When you’re actively programming, these resources should adequately satisfy your reference needs (and you can use them to look up anything in this chapter that isn’t clear to you). Appendix A lists additional references.
   The first chapter in this section introduces the Standard C++string class, which is a powerful tool that simplifies most of the text-processing chores you might have. Thestring class might be the most thorough string manipulation tool you’ve ever seen. Chances are, anything you’ve done to character strings with lines of code in C can be done with a member function call in the string class.
   Chapter 4 covers theiostreams library, which contains classes for processing input and output with files, string targets, and the system console.
   Although Chapter 5, "Templates in Depth," is not explicitly a library chapter, it is necessary preparation for the two that follow. In Chapter 6 we examine the generic algorithms offered by the Standard C++ library. Because they are implemented with templates, these algorithms can be applied to anysequence of objects. Chapter 7 covers the standard containers and their associated iterators. We cover algorithms first because they can be fully explored by using only arrays and the vector container (which we have been using since early in Volume 1). It is also natural to use the standard algorithms in connection with containers, so it’s a good idea to be familiar with the algorithm before studying the containers.

   [ ]
   3: Strings in depth
   One of the biggest time-wasters in C is using character arrays for string processing: keeping track of the difference between static quoted strings and arrays created on the stack and the heap, and the fact that sometimes you’re passing around achar* and sometimes you must copy the whole array.
   Especially because string manipulation is so common, character arrays are a great source of misunderstandings and bugs. Despite this, creating string classes remained a common exercise for beginning C++ programmers for many years. The Standard C++ librarystring class solves the problem of character array manipulation once and for all, keeping track of memory even during assignments and copy-constructions. You simply don’t need to think about it.
   This chapter examines the Standard C++string class, beginning with a look at what constitutes a C++ string and how the C++ version differs from a traditional C character array. You’ll learn about operations and manipulations usingstring objects, and you’ll see how C++strings accommodate variation in character sets and string data conversion.[28] 
   Handling text is perhaps one of the oldest of all programming applications, so it’s not surprising that the C++string draws heavily on the ideas and terminology that have long been used for this purpose in C and other languages. As you begin to acquaint yourself with C++strings, this fact should be reassuring. No matter which programming idiom you choose, there are really only about three things you want to do with astring:
   ·         Create or modify the sequence of characters stored in thestring.
   ·         Detect the presence or absence of elements within thestring.
   ·         Translate between various schemes for representingstring characters.
   You’ll see how each of these jobs is accomplished using C++string objects.
   What’s in a string?
   In C, a string is simply an array of characters that always includes a binary zero (often called thenull terminator) as its final array element. There are significant differences between C++strings and their C progenitors. First, and most important, C++ strings hide the physical representation of the sequence of characters they contain. You don’t have to be concerned at all about array dimensions or null terminators. Astring also contains certain "housekeeping" information about the size and storage location of its data. Specifically, a C++string object knows its starting location in memory, its content, its length in characters, and the length in characters to which it can grow before thestring object must resize its internal data buffer. C++ strings therefore greatly reduce the likelihood of making three of the most common and destructive C programming errors: overwriting array bounds, trying to access arrays through uninitialized or incorrectly valued pointers, and leaving pointers "dangling" after an array ceases to occupy the storage that was once allocated to it.
   The exact implementation of memory layout for the string class is not defined by the C++ Standard. This architecture is intended to be flexible enough to allow differing implementations by compiler vendors, yet guarantee predictable behavior for users. In particular, the exact conditions under which storage is allocated to hold data for a string object are not defined. String allocation rules were formulated to allow but not require a reference-counted implementation, but whether or not the implementation uses reference counting, the semantics must be the same. To put this a bit differently, in C, everychar array occupies a unique physical region of memory. In C++, individualstring objects may or may not occupy unique physical regions of memory, but if reference counting is used to avoid storing duplicate copies of data, the individual objects must look and act as though they do exclusively own unique regions of storage. For example:.
   //: C03:StringStorage.cpp
   //{L} ../TestSuite/Test
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include "../TestSuite/Test.h"
   using namespace std;

   class StringStorageTest : public TestSuite::Test {
   public:
     void run() {
       string s1("12345");
       // This may copy the first to the second or
       // use reference counting to simulate a copy
       string s2 = s1;
       test_(s1 == s2);
       // Either way, this statement must ONLY modify s1
       s1[0] = '6';
       cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; endl;
       cout&lt;&lt; "s2 = "&lt;&lt; s2&lt;&lt; endl;
       test_(s1 != s2);
     }
   };

   int main() {
     StringStorageTest t;
     t.run();
     return t.report();
   } ///:~

   An implementation that only makes unique copies when a string is modified is said to use acopy-on-write strategy. This approach saves time and space when strings are used only as value parameters or in other read-only situations.
   Whether a library implementation uses reference counting or not should be transparent to users of thestring class. Unfortunately, this is not always the case. In multithreaded programs, it is practically impossible to use a reference-counting implementation safely.[29] 
   Creating and initializing C++ strings
   Creating and initializing strings is a straightforward proposition and fairly flexible. In theSmallString.cpp example in this section, the firststring,imBlank, is declared but contains no initial value. Unlike a Cchar array, which would contain a random and meaningless bit pattern until initialization,imBlank does contain meaningful information. Thisstring object is initialized to hold "no characters" and can properly report its zero length and absence of data elements through the use of class member functions.
   The next string,heyMom, is initialized by the literal argument "Where are my socks?" This form of initialization uses a quoted character array as a parameter to thestring constructor. By contrast,standardReply is simply initialized with an assignment. The last string of the group,useThisOneAgain, is initialized using an existing C++string object. Put another way, this example illustrates thatstring objects let you do the following:.
   ·         Create an emptystring and defer initializing it with character data.
   ·         Initialize astring by passing a literal, quoted character array as an argument to the constructor.
   ·         Initialize astring using the equal sign (=).
   ·         Use onestring to initialize another.
   //: C03:SmallString.cpp
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string imBlank;
     string heyMom("Where are my socks?");
     string standardReply = "Beamed into deep "
       "space on wide angle dispersion?";
     string useThisOneAgain(standardReply);
   } ///:~

   These are the simplest forms ofstring initialization, but variations offer more flexibility and control. You can do the following:
   ? Use a portion of either a Cchar array or a C++string.
   ? Combine different sources of initialization data usingoperator+.
   ? Use thestring object’ssubstr( ) member function to create a substring.
   Here’s a program that illustrates these features.
   //: C03:SmallString2.cpp
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   using namespace std;

   int main() {
     string s1
       ("What is the sound of one clam napping?");
     string s2
       ("Anything worth doing is worth overdoing.");
     string s3("I saw Elvis in a UFO");
     // Copy the first 8 chars
     string s4(s1, 0, 8);
     cout&lt;&lt; s4&lt;&lt; endl;
     // Copy 6 chars from the middle of the source
     string s5(s2, 15, 6);
     cout&lt;&lt; s5&lt;&lt; endl;
     // Copy from middle to end
     string s6(s3, 6, 15);
     cout&lt;&lt; s6&lt;&lt; endl;
     // Copy all sorts of stuff
     string quoteMe = s4 + "that" +
     // substr() copies 10 chars at element 20
     s1.substr(20, 10) + s5 +
     // substr() copies up to either 100 char
     // or eos starting at element 5
     "with" + s3.substr(5, 100) +
     // OK to copy a single char this way
     s1.substr(37, 1);
     cout&lt;&lt; quoteMe&lt;&lt; endl;
   } ///:~

   Thestring member functionsubstr( ) takes a starting position as its first argument and the number of characters to select as the second argument. Both arguments have default values. If you saysubstr( ) with an empty argument list, you produce a copy of the entirestring; so this is a convenient way to duplicate astring.
   Here’s the output from the program:
   What is
   doing
   Elvis in a UFO
   What is that one clam doing with Elvis in a UFO?

   Notice the final line of the example. C++ allowsstring initialization techniques to be mixed in a single statement, a flexible and convenient feature. Also notice that the last initializer copiesjust one character from the sourcestring.
   Another slightly more subtle initialization technique involves the use of thestring iteratorsstring::begin( ) andstring::end( ). This technique treats astring like acontainer object (which you’ve seen primarily in the form ofvector so far—you’ll see many more containers in Chapter 7), which usesiterators to indicate the start and end of a sequence of characters. In this way you can hand astring constructor two iterators, and it copies from one to the other into the newstring:.
   //: C03:StringIterators.cpp
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include&lt;cassert&gt;
   using namespace std;

   int main() {
     string source("xxx");
     string s(source.begin(), source.end());
     assert(s == source);
   } ///:~

   The iterators are not restricted tobegin( ) andend( ); you can increment, decrement, and add integer offsets to them, allowing you to extract a subset of characters from the sourcestring.
   C++ strings maynot be initialized with single characters or with ASCII or other integer values. You can initialize a string with a number of copies of a single character, however.
   //: C03:UhOh.cpp
   #include&lt;string&gt;
   #include&lt;cassert&gt;
   using namespace std;

   int main() {
     // Error: no single char inits
     //! string nothingDoing1('a');
     // Error: no integer inits
     //! string nothingDoing2(0x37);
     // The following is legal:
     string okay(5, 'a');
     assert(okay == string("aaaaa"));
   } ///:~

   Operating on strings
   If you’ve programmed in C, you are accustomed to the convenience of a large family of functions for writing, searching, modifying, and copyingchar arrays. However, there are two unfortunate aspects of the Standard C library functions for handlingchar arrays. First, there are two loosely organized families of them: the "plain" group, and the ones that require you to supply a count of the number of characters to be considered in the operation at hand. The roster of functions in the Cchar array handling library shocks the unsuspecting user with a long list of cryptic, mostly unpronounceable names. Although the kinds and number of arguments to the functions are somewhat consistent, to use them properly you must be attentive to details of function naming and parameter passing.
   The second inherent trap of the standard Cchar array tools is that they all rely explicitly on the assumption that the character array includes a null terminator. If by oversight or error the null is omitted or overwritten, there’s little to keep the Cchar array handling functions from manipulating the memory beyond the limits of the allocated space, sometimes with disastrous results.
   C++ provides a vast improvement in the convenience and safety ofstring objects. For purposes of actual string handling operations, there are about the same number of distinct member function names in thestring class as there are functions in the C library, but because of overloading there is much more functionality. Coupled with sensible naming practices and the judicious use of default arguments, these features combine to make thestring class much easier to use than the C library.
   Appending, inserting, and concatenating strings
   One of the most valuable and convenient aspects of C++ strings is that they grow as needed, without intervention on the part of the programmer. Not only does this make string-handling code inherently more trustworthy, it also almost entirely eliminates a tedious "housekeeping" chore—keeping track of the bounds of the storage in which your strings live. For example, if you create a string object and initialize it with a string of 50 copies of ‘X’, and later store in it 50 copies of "Zowie", the object itself will reallocate sufficient storage to accommodate the growth ofthe data. Perhaps nowhere is this property more appreciated than when the strings manipulated in your code change size and you don’t know how big the change is. Appending, concatenating, and inserting strings often give rise to this circumstance, but the string member functionsappend( ) andinsert( ) transparently reallocate storage when a string grows.
   //: C03:StrSize.cpp
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   using namespace std;

   int main() {
     string bigNews("I saw Elvis in a UFO. ");
     cout&lt;&lt; bigNews&lt;&lt; endl;
     // How much data have we actually got?
     cout&lt;&lt; "Size = "&lt;&lt; bigNews.size()&lt;&lt; endl;
     // How much can we store without reallocating
     cout&lt;&lt; "Capacity = "
      &lt;&lt; bigNews.capacity()&lt;&lt; endl;
     // Insert this string in bigNews immediately
     // before bigNews[1]
     bigNews.insert(1, " thought I");
     cout&lt;&lt; bigNews&lt;&lt; endl;
     cout&lt;&lt; "Size = "&lt;&lt; bigNews.size()&lt;&lt; endl;
     cout&lt;&lt; "Capacity = "
      &lt;&lt; bigNews.capacity()&lt;&lt; endl;
     // Make sure that there will be this much space
     bigNews.reserve(500);
     // Add this to the end of the string
     bigNews.append("I've been working too hard.");
     cout&lt;&lt; bigNews&lt;&lt; endl;
     cout&lt;&lt; "Size = "&lt;&lt; bigNews.size()&lt;&lt; endl;
     cout&lt;&lt; "Capacity = "
      &lt;&lt; bigNews.capacity()&lt;&lt; endl;
   } ///:~

   Here is the output from one particular compiler:.
   I saw Elvis in a UFO.
   Size = 22
   Capacity = 31
   I thought I saw Elvis in a UFO.
   Size = 32
   Capacity = 47
   I thought I saw Elvis in a UFO. I've been
   working too hard.
   Size = 59
   Capacity = 511

   This example demonstrates that even though you can safely relinquish much of the responsibility for allocating and managing the memory yourstrings occupy, C++strings provide you with several tools to monitor and manage their size. Notice the ease with which we changed the size of the storage allocated to the string. Thesize( )function, of course, returns the number of characters currently stored in the string and is identical to thelength( ) member function. Thecapacity( )function returns the size of the current underlying allocation, meaning the number of characters the string can hold without requesting more storage. Thereserve( ) function is an optimization mechanism that allows you to indicate your intention to specify a certain amount of storage for future use;capacity( ) always returns a value at least as large as the most recent call toreserve( ). Aresize( ) function appends spaces if the new size is greater than the current string size or truncates the string otherwise. (An overload ofresize( ) allows you to specify a different character to append.).
   The exact fashion in which thestring member functions allocate space for your data depends on the implementation of the library. When we tested one implementation with the previous example, it appeared that reallocations occurred on even word (that is, full-integer) boundaries, with one byte held back. The architects of thestring class have endeavored to make it possible to mix the use of Cchar arrays and C++ string objects, so it is likely that figures reported byStrSize.cpp for capacity reflect that, in this particular implementation, a byte is set aside to easily accommodate the insertion of a null terminator.
   Replacing string characters
   Theinsert( )function is particularly nice because it absolves you of making sure the insertion of characters in a string won’t overrun the storage space or overwrite the characters immediately following the insertion point. Space grows, and existing characters politely move over to accommodate the new elements. Sometimes, however, this might not be what you want to happen. If you want the size of the string to remain unchanged, use thereplace( ) function to overwrite characters. There are quite a number of overloaded versions ofreplace( ), but the simplest one takes three arguments: an integer indicating where to start in the string, an integer indicating how many characters to eliminate from the original string, and the replacement string (which can be a different number of characters than the eliminated quantity). Here’s a simple example:.
   //: C03:StringReplace.cpp
   // Simple find-and-replace in strings
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string s("A piece of text");
     string tag("$tag$");
     s.insert(8, tag + ' ');
     assert(s == "A piece $tag$ of text");
     int start = s.find(tag);
     assert(start == 8);
     assert(tag.size() == 5);
     s.replace(start, tag.size(), "hello there");
     assert(s == "A piece hello there of text");
   } ///:~

   Thetag is first inserted intos (notice that the insert happensbefore the value indicating the insert point and that an extra space was added aftertag), and then it is found and replaced.
   You should actually check to see if you’ve found anything before you perform areplace( ). The previous example replaces with achar*, but there’s an overloaded version that replaces with astring. Here’s a more complete demonstrationreplace( ):
   //: C03:Replace.cpp
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;  // for size_t
   #include&lt;string&gt;
   using namespace std;

   void replaceChars(string& modifyMe,
     const string& findMe, const string& newChars) {
     // Look in modifyMe for the "find string"
     // starting at position 0
     size_t i = modifyMe.find(findMe, 0);
     // Did we find the string to replace?
     if (i != string::npos)
       // Replace the find string with newChars
       modifyMe.replace(i, findMe.size(), newChars);
   }

   int main() {
     string bigNews =
      "I thought I saw Elvis in a UFO. "
      "I have been working too hard.";
     string replacement("wig");
     string findMe("UFO");
     // Find "UFO" in bigNews and overwrite it:
     replaceChars(bigNews, findMe, replacement);
     assert(bigNews == "I thought I saw Elvis in a "
            "wig. I have been working too hard.");
   } ///:~

   Ifreplace doesn’t find the search string, it returnsstring::npos. Thenpos data member is a static constant member of thestring class that represents a nonexistent character position.[30] 
   Unlikeinsert( ),replace( ) won’t grow thestring’s storage space if you copy new characters into the middle of an existing series of array elements. However, itwill grow the storage space if needed, for example, when you make a "replacement" that would expand the original string beyond the end of the current allocation. Here’s an example:.
   //: C03:ReplaceAndGrow.cpp
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string bigNews("I have been working the grave.");
     string replacement("yard shift.");
     // The first arg says "replace chars
     // beyond the end of the existing string":
     bigNews.replace(bigNews.size() - 1,
       replacement.size(), replacement);
     assert(bigNews == "I have been working the "
            "graveyard shift.");
   } ///:~

   The call toreplace( )begins "replacing" beyond the end of the existing array, which is equivalent to an append operation. Notice that in this examplereplace( ) expands the array accordingly.
   You may have been hunting through this chapter trying to do something relatively simple such as replace all the instances of one character with a different character. Upon finding the previous material on replacing, you thought you found the answer, but then you started seeing groups of characters and counts and other things that looked a bit too complex. Doesn’tstring have a way to just replace one character with another everywhere?.
   You can easily write such a function using thefind( ) andreplace( ) member functions as follows:
   //: C03:ReplaceAll.cpp {O}
   #include&lt;cstddef&gt;
   #include&lt;string&gt;
   using namespace std;

   string& replaceAll(string& context, const string& from,
     const string& to) {
     size_t lookHere = 0;
     size_t foundHere;
   while ((foundHere = context.find(from, lookHere))
     != string::npos) {
       context.replace(foundHere, from.size(), to);
   lookHere = foundHere + to.size();
     }
     return context;
   } ///:~

   The version offind( ) used here takes as a second argument the position to start looking in and returnsstring::npos if it doesn’t find it. It is important to advance the position held in the variablelookHere past the replacement string, of course, in casefrom is a substring ofto. The following program tests thereplaceAll function:.
   //: C03:ReplaceAllTest.cpp
   //{-msc}
   //{L} ReplaceAll
   #include&lt;iostream&gt;
   #include&lt;cassert&gt;
   using namespace std;

   string& replaceAll(string& context, const string& from,
     const string& to);

   int main() {
     string text = "a man, a plan, a canal, panama";
     replaceAll(text, "an", "XXX");
     assert(text == "a mXXX, a plXXX, a cXXXal, pXXXama");
   } ///:~

   As you can see, thestring class by itself doesn’t solve all possible problems. Many solutions have been left to the algorithms in the Standard library,[31] because thestring class can look just like an STL sequence (by virtue of the iterators discussed earlier). All the generic algorithms work on a "range" of elements within a container. Usually that range is just "from the beginning of the container to the end." Astring object looks like a container of characters: to get the beginning of the range you usestring::begin( ), and to get the end of the range you usestring::end( ). The following example shows the use of thereplace( ) algorithm to replace all the instances of the single character‘X’ with ‘Y’:.
   //: C03:StringCharReplace.cpp
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string s("aaaXaaaXXaaXXXaXXXXaaa");
     replace(s.begin(), s.end(), 'X', 'Y');
     assert(s == "aaaYaaaYYaaYYYaYYYYaaa");
   } ///:~

   Notice that thisreplace( ) isnot called as a member function ofstring. Also, unlike thestring::replace( ) functions that only perform one replacement, thereplace( ) algorithm replacesall instances of one character with another.
   Thereplace( ) algorithm only works with single objects (in this case,char objects) and will not replace quotedchar arrays orstring objects. Since astring behaves like an STL sequence, a number of other algorithms can be applied to it, which might solve other problems that are not directly addressed by thestring member functions.
   Concatenation using nonmember overloaded operators
   One of the most delightful discoveries awaiting a C programmer learning about C++string handling is how simplystrings can be combined and appended usingoperator+ andoperator+=. These operators make combiningstrings syntactically similar to adding numeric data.
   //: C03:AddStrings.cpp
   #include&lt;string&gt;
   #include&lt;cassert&gt;
   using namespace std;

   int main() {
     string s1("This ");
     string s2("That ");
     string s3("The other ");
     // operator+ concatenates strings
     s1 = s1 + s2;
     assert(s1 == "This That ");
     // Another way to concatenates strings
     s1 += s3;
     assert(s1 == "This That The other ");
     // You can index the string on the right
     s1 += s3 + s3[4] + "ooh lala";
     assert(s1 == "This That The other The other "
           "oooh lala");
   } ///:~


   Using theoperator+ andoperator+=operators is a flexible and convenient way to combinestring data. On the right side of the statement, you can use almost any type that evaluates to a group of one or more characters.
   Searching in strings
   Thefind family ofstring member functions allows you to locate a character or group of characters within a given string. Here are the members of thefind family and their general usage :string find member functionWhat/how it finds find( )Searches a string for a specified character or group of characters and returns the starting position of the first occurrence found or npos if no match is found. (npos is aconst of–1 [cast as astd::size_t] and indicates that a search failed.) find_first_of( )Searches a target string and returns the position of the first match ofany character in a specified group. If no match is found, it returns npos. find_last_of( )Searches a target string and returns the position of the last match ofany character in a specified group. If no match is found, it returns npos. find_first_not_of( )Searches a target string and returns the position of the first element thatdoesn’t matchany character in a specified group. If no such element is found, it returns npos. find_last_not_of( )Searches a target string and returns the position of the element with the largest subscript thatdoesn’t matchany character in a specified group. If no such element is found, it returns npos. rfind( )Searches a string from end to beginning for a specified character or group of characters and returns the starting position of the match if one is found. If no match is found, it returnsnpos.

   The simplest use offind( )searches for one or more characters in astring. This overloaded version offind( )takes a parameter that specifies the character(s) for which to search and optionally a parameter that tells it where in the string to begin searching for the occurrence of a substring. (The default position at which to begin searching is 0.) By setting the call tofindinside a loop, you can easily move through a string, repeating a search to find all the occurrences of a given character or group of characters within the string.
   The following program uses the method ofThe Sieve of Eratosthenes to find prime numbers less than 50. This method starts with the number 2, marks all subsequent multiples of 2 as not prime, and repeats the process for the next prime candidate. Notice that we define the string objectsieveChars using a constructor idiom that sets the initial size of the character array and writes the value‘P’ to each of its member.
   //: C03:Sieve.cpp
   //{L} ../TestSuite/Test
   #include&lt;cmath&gt;
   #include&lt;cstddef&gt;
   #include&lt;string&gt;
   #include "../TestSuite/Test.h"
   using namespace std;

   class SieveTest : public TestSuite::Test {
     string sieveChars;
   public:
     // Create a 50 char string and set each
     // element to 'P' for Prime
   SieveTest() : sieveChars(50, 'P') {}
     void run() {
       findPrimes();
       testPrimes();
     }
     bool isPrime(int p) {
       if (p == 0 || p == 1) return false;
       int root = int(sqrt(double(p)));
       for (int i = 2; i&lt;= root; ++i)
         if (p % i == 0) return false;
       return true;
     }
     void findPrimes() {
       // By definition neither 0 nor 1 is prime.
       // Change these elements to "N" for Not Prime
       sieveChars.replace(0, 2, "NN");
       // Walk through the array:
       size_t sieveSize = sieveChars.size();
       int root = int(sqrt(double(sieveSize)));
       for (int i = 2; i&lt;= root; ++i)
         // Find all the multiples:
         for (size_t factor = 2; factor * i&lt; sieveSize;
              ++factor)
           sieveChars[factor * i] = 'N';
     }
     void testPrimes() {
       size_t i = sieveChars.find('P');
       while (i != string::npos) {
         test_(isPrime(i++));
         i = sieveChars.find('P', i);
       }
       i = sieveChars.find_first_not_of('P');
       while (i != string::npos) {
         test_(!isPrime(i++));
         i = sieveChars.find_first_not_of('P', i);
       }
     }
   };

   int main() {
     SieveTest t;
     t.run();
     return t.report();
   } ///:~

   Thefind( ) function allows you to walk forward through astring, detecting multiple occurrences of a character or a group of characters, andfind_first_not_of( ) allows you to find other characters or substrings.
   There are no functions in thestringclass to change the case of a string, but you can easily create these functions using the Standard C library functionstoupper( ) andtolower( ), which change the case of one character at a time. The following example illustrates a case-insensitive search:.
   //: C03:Find.cpp
   //{L} ../TestSuite/Test
   #include&lt;cctype&gt;
   #include&lt;cstddef&gt;
   #include&lt;string&gt;
   #include "../TestSuite/Test.h"
   using namespace std;

   // Make an uppercase copy of s
   string upperCase(const string& s) {
     string upper(s);
     for(size_t i = 0; i&lt; s.length(); ++i)
       upper[i] = toupper(upper[i]);
     return upper;
   }

   // Make a lowercase copy of s
   string lowerCase(const string& s) {
     string lower(s);
     for(size_t i = 0; i&lt; s.length(); ++i)
       lower[i] = tolower(lower[i]);
     return lower;
   }

   class FindTest : public TestSuite::Test {
     string chooseOne;
   public:
     FindTest() : chooseOne("Eenie, Meenie, Miney, Mo") {}
     void testUpper() {
       string upper = upperCase(chooseOne);
       const string LOWER = "abcdefghijklmnopqrstuvwxyz";
       test_(upper.find_first_of(LOWER) == string::npos);
     }
     void testLower() {
       string lower = lowerCase(chooseOne);
       const string UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
       test_(lower.find_first_of(UPPER) == string::npos);
     }
     void testSearch() {
       // Case sensitive search
       size_t i = chooseOne.find("een");
       test_(i == 8);
       // Search lowercase:
       string test = lowerCase(chooseOne);
       i = test.find("een");
       test_(i == 0);
       i = test.find("een", ++i);
       test_(i == 8);
       i = test.find("een", ++i);
       test_(i == string::npos);
       // Search uppercase:
       test = upperCase(chooseOne);
       i = test.find("EEN");
       test_(i == 0);
       i = test.find("EEN", ++i);
       test_(i == 8);
       i = test.find("EEN", ++i);
       test_(i == string::npos);
     }
     void run() {
       testUpper();
       testLower();
       testSearch();
     }
   };

   int main() {
     FindTest t;
     t.run();
     return t.report();
   } ///:~

   Both theupperCase( ) andlowerCase( ) functions follow the same form: they make a copy of the argumentstring and change the case. TheNewFind.cpp program isn’t the best solution to the case-sensitivity problem, so we’ll revisit it when we examinestring comparisons.
   Finding in reverse
   Sometimes it’s necessary to search through astring from end to beginning, if you need to find the data in "last in / first out" order. The string member functionrfind( ) handles this job.
   //: C03:Rparse.cpp
   //{L} ../TestSuite/Test
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../TestSuite/Test.h"
   using namespace std;

   class RparseTest : public TestSuite::Test {
     // To store the words:
     vector&lt;string&gt; strings;
   public:
     void parseForData() {
       // The ';' characters will be delimiters
       string s("now.;sense;make;to;going;is;This");
       // The last element of the string:
       int last = s.size();
       // The beginning of the current word:
       int current = s.rfind(';');
       // Walk backward through the string:
       while(current != string::npos){
         // Push each word into the vector.
         // Current is incremented before copying to
         // avoid copying the delimiter:
         ++current;
         strings.push_back(
           s.substr(current, last - current));
         // Back over the delimiter we just found,
         // and set last to the end of the next word:
         current -= 2;
         last = current + 1;
         // Find the next delimiter
         current = s.rfind(';', current);
       }
       // Pick up the first word - it's not
       // preceded by a delimiter
       strings.push_back(s.substr(0, last));
     }
     void testData() {
       // Test order them in the new order:
       test_(strings[0] == "This");
       test_(strings[1] == "is");
       test_(strings[2] == "going");
       test_(strings[3] == "to");
       test_(strings[4] == "make");
       test_(strings[5] == "sense");
       test_(strings[6] == "now.");
       string sentence;
       for(int i = 0; i&lt; strings.size() - 1; i++)
         sentence += strings[i] += " ";
       // Manually put last word in to avoid an extra space
       sentence += strings[strings.size() - 1];
       test_(sentence == "This is going to make sense now.");
     }
     void run() {
       parseForData();
       testData();
     }
   };

   int main() {
     RparseTest t;
     t.run();
     return t.report();
   } ///:~

   The string member functionrfind( ) backs through the string looking for tokens and reporting the array index of matching characters orstring::npos if it is unsuccessful.
   Finding first/last of a set of characters
   Thefind_first_of( ) andfind_last_of( ) member functions can be conveniently put to work to create a little utility that will strip whitespace characters from both ends of a string. Notice that it doesn’t touch the original string, but instead returns a new string:.
   //: C03:Trim.h
   #ifndef TRIM_H
   #define TRIM_H
   #include&lt;string&gt;
   // General tool to strip spaces from both ends:
   inline std::string trim(const std::string& s) {
     if(s.length() == 0)
       return s;
     int beg = s.find_first_not_of(" \a\b\f\n\r\t\v");
     int end = s.find_last_not_of(" \a\b\f\n\r\t\v");
     if(beg == std::string::npos) // No non-spaces
       return "";
     return std::string(s, beg, end - beg + 1);
   }
   #endif // TRIM_H ///:~

   The first test checks for an emptystring; in that case, no tests are made, and a copy is returned. Notice that once the end points are found, thestring constructor builds a newstring from the old one, giving the starting count and the length.
   Testing such a general-purpose tool needs to be thorough:.
   //: C03:TrimTest.cpp
   //{L} ../TestSuite/Test
   #include&lt;iostream&gt;
   #include "Trim.h"
   #include "../TestSuite/Test.h"
   using namespace std;

   string s[] = {
     " \t abcdefghijklmnop \t ",
     "abcdefghijklmnop \t ",
     " \t abcdefghijklmnop",
     "a", "ab", "abc", "a b c",
     " \t a b c \t ", " \t a \t b \t c \t ",
     "\t \n \r \v \f",
     "" // Must also test the empty string
   };

   class TrimTest : public TestSuite::Test {
   public:
     void testTrim() {
       test_(trim(s[0]) == "abcdefghijklmnop");
       test_(trim(s[1]) == "abcdefghijklmnop");
       test_(trim(s[2]) == "abcdefghijklmnop");
       test_(trim(s[3]) == "a");
       test_(trim(s[4]) == "ab");
       test_(trim(s[5]) == "abc");
       test_(trim(s[6]) == "a b c");
       test_(trim(s[7]) == "a b c");
       test_(trim(s[8]) == "a \t b \t c");
       test_(trim(s[9]) == "");
       test_(trim(s[10]) == "");
     }
     void run() {
       testTrim();
     }
   };

   int main() {
     TrimTest t;
     t.run();
     return t.report();
   } ///:~

   In the array ofstrings, you can see that the character arrays are automatically converted tostring objects. This array provides cases to check the removal of spaces and tabs from both ends, as well as ensuring that spaces and tabs are not removed from the middle of astring.
   Removing characters from strings
   Removing characters is easy and efficient with theerase( ) member function, which takes two arguments: where to start removing characters (which defaults to0), and how many to remove (which defaults tostring::npos). If you specify more characters than remain in the string, the remaining characters are all erased anyway (so callingerase( ) without any arguments removes all characters from a string). Sometimes it’s useful to take an HTML file and strip its tags and special characters so that you have something approximating the text that would be displayed in the Web browser, only as a plain text file. The following useserase( ) to do the job:.
   //: C03:HTMLStripper.cpp
   //{L} ReplaceAll
   // Filter to remove html tags and markers
   #include&lt;cassert&gt;
   #include&lt;cmath&gt;
   #include&lt;cstddef&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   string& replaceAll(string& context, const string& from,
     const string& to);

   string& stripHTMLTags(string& s) {
     static bool inTag = false;
     bool done = false;
     while (!done) {
       if (inTag) {
         // The previous line started an HTML tag
         // but didn't finish. Must search for '&gt;'.
         size_t rightPos = s.find('&gt;');
         if (rightPos != string::npos) {
           inTag = false;
           s.erase(0, rightPos + 1);
         }
         else {
           done = true;
           s.erase();
         }
       }
       else {
         // Look for start of tag:
         size_t leftPos = s.find('&lt;');
         if (leftPos != string::npos) {
           // See if tag close is in this line
           size_t rightPos = s.find('&gt;');
           if (rightPos == string::npos) {
             inTag = done = true;
             s.erase(leftPos);
           }
           else
             s.erase(leftPos, rightPos - leftPos + 1);
         }
         else
           done = true;
       }
     }
     // Remove all special HTML characters
     replaceAll(s, "&lt;", "&lt;");
     replaceAll(s, "&gt;", "&gt;");
     replaceAll(s, "&amp;", "&");
     replaceAll(s, "&nbsp;", " ");
     // Etc...
     return s;
   }

   int main(int argc, char* argv[]) {
     requireArgs(argc, 1,
       "usage: HTMLStripper InputFile");
     ifstream in(argv[1]);
     assure(in, argv[1]);
     string s;
     while(getline(in, s))
       if (!stripHTMLTags(s).empty())
         cout&lt;&lt; s&lt;&lt; endl;
   } ///:~

   This example will even strip HTML tags that span multiple lines.[32] This is accomplished with the static flag,inTag, which istrue whenever the start of a tag is found, but the accompanying tag end is not found in the same line. All forms oferase( ) appear in thestripHTMLFlags( ) function.[33] The version ofgetline( ) we use here is a global function declared in the&lt;string&gt; header and is handy because it stores an arbitrarily long line in itsstring argument. You don’t have to worry about the dimension of a character array as you do withistream::getline( ). Notice that this program uses thereplaceAll( ) function from earlier in this chapter. In the next chapter, we’ll use string streams to create a more elegant solution.
   Comparing strings
   Comparing strings is inherently different from comparing numbers. Numbers have constant, universally meaningful values. To evaluate the relationship between the magnitudes of two strings, you must make alexical comparison. Lexical comparison means that when you test a character to see if it is "greater than" or "less than" another character, you are actually comparing the numeric representation of those characters as specified in the collating sequence of the character set being used. Most often this will be the ASCII collating sequence, which assigns the printable characters for the English language numbers in the range 32 through 127 decimal. In the ASCII collating sequence, the first "character" in the list is the space, followed by several common punctuation marks, and then uppercase and lowercase letters. With respect to the alphabet, this means that the letters nearer the front have lower ASCII values than those nearer the end. With these details in mind, it becomes easier to remember that when a lexical comparison that reportss1 is "greater than"s2, it simply means that when the two were compared, the first differing character ins1 came later in the alphabet than the character in that same position ins2.
   C++ provides several ways to compare strings, and each has advantages. The simplest to use are the nonmember, overloaded operator functions:operator ==, operator != operator&gt;, operator&lt;, operator&gt;=,andoperator&lt;=.
   //: C03:CompStr.cpp
   //{L} ../TestSuite/Test
   #include&lt;string&gt;
   #include "../TestSuite/Test.h"
   using namespace std;

   class CompStrTest : public TestSuite::Test {
   public:
     void run() {
       // Strings to compare
       string s1("This");
       string s2("That");
       test_(s1 == s1);
       test_(s1 != s2);
       test_(s1&gt; s2);
       test_(s1&gt;= s2);
       test_(s1&gt;= s1);
       test_(s2&lt; s1);
       test_(s2&lt;= s1);
       test_(s1&lt;= s1);
     }
   };

   int main() {
     CompStrTest t;
     t.run();
     return t.report();
   } ///:~

   The overloaded comparison operators are useful for comparing both full strings and individual string character elements.
   Notice in the following code fragment the flexibility of argument types on both the left and right side of the comparison operators. For efficiency, thestring class provides overloaded operators for the direct comparison of string objects, quoted literals, and pointers to C-style strings without having to create temporarystring objects.
   // The lvalue is a quoted literal and
   // the rvalue is a string
   if("That" == s2)
     cout&lt;&lt; "A match"&lt;&lt; endl;
   // The left operand below is a string and the right is a
   // pointer to a C-style null terminated string
   if(s1 != s2.c_str())
     cout&lt;&lt; "No match"&lt;&lt; endl;

   Thec_str( ) function returns aconst char* that points to a C-style, null-terminated string equivalent to the contents of thestring object. This comes in handy when you want to pass a string to a standard C function, such asatoi( ) or any of the functions defined in the&lt;cstring&gt; header. It is an error to use the value returned byc_str( ) as non-const argument to any function.
   You won’t find the logical not (!) or the logical comparison operators (&& and||) among operators for a string. (Neither will you find overloaded versions of the bitwise C operators&,|,^, or~.) The overloaded nonmember comparison operators for the string class are limited to the subset that has clear, unambiguous application to single characters or groups of characters.
   Thecompare( ) member function offers you a great deal more sophisticated and precise comparison than the nonmember operator set. It provides overloaded versions that allow you to compare two complete strings, part of either string to a complete string, and subsets of two strings. The following example compares complete strings:.
   //: C03:Compare.cpp
   // Demonstrates compare(), swap()
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string first("This");
     string second("That");
     assert(first.compare(first) == 0);
     assert(second.compare(second) == 0);
     // Which is lexically greater?
     assert(first.compare(second)&gt; 0);
     assert(second.compare(first)&lt; 0);
     first.swap(second);
     assert(first.compare(second)&lt; 0);
     assert(second.compare(first)&gt; 0);
   } ///:~

   Theswap( ) function in this example does what its name implies: it exchanges the contents of its object and argument. To compare a subset of the characters in one or both strings, you add arguments that define where to start the comparison and how many characters to consider. For example, we can use the overloaded version ofcompare( ):.
   s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos, s2NumberChars);.
   Here’s an example:.
   //: C03:Compare2.cpp
   // Illustrate overloaded compare()
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string first("This is a day that will live in infamy");
     string second("I don't believe that this is what "
    "I signed up for");
     // Compare "his is" in both strings:
     assert(first.compare(1, 7, second, 22, 7) == 0);
     // Compare "his is a" to "his is w":
     assert(first.compare(1, 9, second, 22, 9)&lt; 0);
   } ///:~

   In the examples so far, we have used C-style array indexing syntax to refer to an individual character in a string. C++ strings provide an alternative to thes[n]notation: theat( ) member. These two indexing mechanisms produce the same result in C++ if all goes well:.
   //: C03:StringIndexing.cpp
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using namespace std;
   int main(){
     string s("1234");
     assert(s[1] == '2');
     assert(s.at(1) == '2');
   } ///:~

   There is one important difference, however, between[ ] andat( ). When you try to reference an array element that is out of bounds,at( )will do you the kindness of throwing an exception, while ordinary[ ]subscripting syntax will leave you to your own devices:.
   //: C03:BadStringIndexing.cpp
   #include&lt;exception&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main(){
     string s("1234");
     // at() saves you by throwing an exception:
     try {
       s.at(5);
     } catch(exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Responsible programmers will not use errant indexes, but should you want to benefits of automatic index checking, usingat( )in place of[ ]will give you a chance to gracefully recover from references to array elements that don’t exist. Execution of this program on one of our test compilers gave the following output:
   invalid string position

   Theat( ) member throws an object of classout_of_range, which derives (ultimately) fromstd::exception.By catching this object in an exception handler, you can take appropriate remedial actions such as recalculating the offending subscript or growing the array. Usingstring::operator[]( ) gives no such protection and is as dangerous aschar array processing in C.[34] 
   Strings and character traits
   The programFind.cpp earlier in this chapter leads us to ask the obvious question: Why isn’t case-insensitive comparison part of the standardstring class? The answer provides interesting background on the true nature of C++ string objects.
   Consider what it means for a character to have "case." Written Hebrew, Farsi, and Kanji don’t use the concept of upper- and lowercase, so for those languages this idea has no meaning. It would seem that if there were a way to designate some languages as "all uppercase" or "all lowercase," we could design a generalized solution. However, some languages that employ the concept of "case"also change the meaning of particular characters with diacritical marks: for example, the cedilla in Spanish, the circumflex in French, and the umlaut in German. For this reason, any case-sensitive collating scheme that attempts to be comprehensive will be nightmarishly complex to use.
   Although we usually treat the C++string as a class, this is really not the case. Thestring type is actually a specialization of a more general constituent, thebasic_string&lt; &gt; template. Observe howstring is declared in the standard C++ header file:[35] 
   typedef basic_string&lt;char&gt; string;

   To really understand the nature of the string class, it’s helpful to delve a bit deeper and look at the template on which it is based. Here’s the declaration of thebasic_string&lt; &gt; template:.
   template&lt;class charT,
     class traits = char_traits&lt;charT&gt;,
     class allocator = allocator&lt;charT&gt;&gt;
     class basic_string;

   In Chapter 5, we examine templates in great detail (much more than in Chapter 16 of Volume 1). For now, the main thing to notice about the two previous declarations is that thestring type is created when thebasic_string template is instantiated withchar.Inside thebasic_string&lt; &gt;template declaration, the line.
   class traits = char_traits&lt;charT&gt;,

   tells us that the behavior of the class made from thebasic_string&lt; &gt;template is specified by a class based on the templatechar_traits&lt; &gt;. Thus, thebasic_string&lt; &gt; template provides for cases in which you need string-oriented classes that manipulate types other thanchar (wide characters, for example). To do this, thechar_traits&lt; &gt;template controls the content and collating behaviors of a variety of character sets using the character comparison functionseq( ) (equal),ne( ) (not equal), andlt( ) (less than) upon which thebasic_string&lt; &gt;string comparison functions rely.
   This is why the string class doesn’t include case-insensitive member functions: that’s not in its job description. To change the way the string class treats character comparison, you must supply a differentchar_traits&lt; &gt; template, because that defines the behavior of the individual character comparison member functions.
   You can use this information to make a new type ofstringclass that ignores case. First, we’ll define a new case-insensitivechar_traits&lt; &gt; template that inherits from the existing template. Next, we’ll override only the members we need to change to make character-by-character comparison case insensitive. (In addition to the three lexical character comparison members mentioned earlier, we’ll also have to supply a new implementation for thechar_traits functionsfind( ) andcompare( ).) Finally, we’lltypedef a new class based onbasic_string, but using the case-insensitiveichar_traits template for its second argument.
   //: C03:ichar_traits.h
   // Creating your own character traits
   #ifndef ICHAR_TRAITS_H
   #define ICHAR_TRAITS_H
   #include&lt;cassert&gt;
   #include&lt;cctype&gt;
   #include&lt;cmath&gt;
   #include&lt;ostream&gt;
   #include&lt;string&gt;

   using std::toupper;
   using std::tolower;
   using std::ostream;
   using std::string;
   using std::char_traits;
   using std::allocator;
   using std::basic_string;

   struct ichar_traits : char_traits&lt;char&gt; {
     // We'll only change character-by-
     // character comparison functions
     static bool eq(char c1st, char c2nd) {
       return toupper(c1st) == toupper(c2nd);
     }
     static bool ne(char c1st, char c2nd) {
       return !eq(c1st, c2nd);
     }
     static bool lt(char c1st, char c2nd) {
       return toupper(c1st)&lt; toupper(c2nd);
     }
     static int compare(const char* str1,
       const char* str2, size_t n) {
       for(size_t i = 0; i&lt; n; i++) {
         if(str1 == 0)
           return -1;
         else if(str2 == 0)
           return 1;
         else if(tolower(*str1)&lt; tolower(*str2))
           return -1;
         else if(tolower(*str1)&gt; tolower(*str2))
           return 1;
         assert(tolower(*str1) == tolower(*str2));
         str1++; str2++; // Compare the other chars
       }
       return 0;
     }
     static const char* find(const char* s1,
       size_t n, char c) {
       while(n--&gt; 0)
         if(toupper(*s1) == toupper(c))
           return s1;
         else
           ++s1;
       return 0;
     }
   };

   typedef basic_string&lt;char, ichar_traits&gt; istring;

   inline ostream& operator&lt;&lt;(ostream& os, const istring& s) {
     return os&lt;&lt; string(s.c_str(), s.length());
   }
   #endif // ICHAR_TRAITS_H  ///:~

   We provide atypedef namedistring so that our class will act like an ordinarystring in every way, except that it will make all comparisons without respect to case. For convenience, we’ve also provided an overloadedoperator&lt;&lt;( ) so that you can printistrings. Here’s an example:.
   //: C03:ICompare.cpp
   #include&lt;cassert&gt;
   #include&lt;iostream&gt;
   #include "ichar_traits.h"
   using namespace std;

   int main() {
     // The same letters except for case:
     istring first = "tHis";
     istring second = "ThIS";
     cout&lt;&lt; first&lt;&lt; endl;
     cout&lt;&lt; second&lt;&lt; endl;
     assert(first.compare(second) == 0);
     assert(first.find('h') == 1);
     assert(first.find('I') == 2);
     assert(first.find('x') == string::npos);
   } ///:~

   This is just a toy example, of course. To makeistring fully equivalent tostring, we’d have to create the other functions necessary to support the newistring type.
   The&lt;string&gt; header provides a wide string class via the followingtypedef:
   typedef basic_string&lt;wchar_t&gt; wstring;

   Wide string support also reveals itself inwide streams (wostream in place ofostream, also defined in&lt;iostream&gt;) and in the header&lt;cwctype&gt;, a wide-character version of&lt;cctype&gt;. This along with thewchar_t specialization ofchar_traits in the standard library allows us to do a wide-character version ofichar_traits:
   //: C03:iwchar_traits.h
   //{-bor}
   //{-g++}
   // Creating your own wide-character traits
   #ifndef IWCHAR_TRAITS_H
   #define IWCHAR_TRAITS_H
   #include&lt;cassert&gt;
   #include&lt;cwctype&gt;
   #include&lt;cmath&gt;
   #include&lt;ostream&gt;
   #include&lt;string&gt;

   using std::towupper;
   using std::towlower;
   using std::wostream;
   using std::wstring;
   using std::char_traits;
   using std::allocator;
   using std::basic_string;

   struct iwchar_traits : char_traits&lt;wchar_t&gt; {
     // We'll only change character-by-
     // character comparison functions
     static bool eq(wchar_t c1st, wchar_t c2nd) {
       return towupper(c1st) == towupper(c2nd);
     }
     static bool ne(wchar_t c1st, wchar_t c2nd) {
       return towupper(c1st) != towupper(c2nd);
     }
     static bool lt(wchar_t c1st, wchar_t c2nd) {
       return towupper(c1st)&lt; towupper(c2nd);
     }
     static int compare(const wchar_t* str1,
       const wchar_t* str2, size_t n) {
       for(size_t i = 0; i&lt; n; i++) {
         if(str1 == 0)
           return -1;
         else if(str2 == 0)
           return 1;
         else if(towlower(*str1)&lt; towlower(*str2))
           return -1;
         else if(towlower(*str1)&gt; towlower(*str2))
           return 1;
         assert(towlower(*str1) == towlower(*str2));
         str1++; str2++; // Compare the other wchar_ts
       }
       return 0;
     }
     static const wchar_t* find(const wchar_t* s1,
       size_t n, wchar_t c) {
       while(n--&gt; 0)
         if(towupper(*s1) == towupper(c))
           return s1;
         else
           ++s1;
       return 0;
     }
   };

   typedef basic_string&lt;wchar_t, iwchar_traits&gt; iwstring;

   inline wostream& operator&lt;&lt;(wostream& os,
     const iwstring& s) {
     return os&lt;&lt; wstring(s.c_str(), s.length());
   }
   #endif // IWCHAR_TRAITS_H  ///:~

   As you can see, this is mostly an exercise in placing a‘w’ in the appropriate place in the source code. The test program looks like this:
   //: C03:IWCompare.cpp
   //{-g++}
   #include&lt;cassert&gt;
   #include&lt;iostream&gt;
   #include "iwchar_traits.h"
   using namespace std;

   int main() {
     // The same letters except for case:
     iwstring wfirst = L"tHis";
     iwstring wsecond = L"ThIS";
     wcout&lt;&lt; wfirst&lt;&lt; endl;
     wcout&lt;&lt; wsecond&lt;&lt; endl;
     assert(wfirst.compare(wsecond) == 0);
     assert(wfirst.find('h') == 1);
     assert(wfirst.find('I') == 2);
     assert(wfirst.find('x') == wstring::npos);
   } ///:~

   Unfortunately, some compilers still do not provide robust support for wide characters.
   A string application
   If you’ve looked at the sample code in this book closely, you’ve noticed that certain tokens in the comments surround the code. These are used by a Python program that Bruce wrote to extract the code into files and set up makefiles for building the code. For example, a double-slash followed by a colon at the beginning of a line denotes the first line of a source file. The rest of the line contains information describing the file’s name and location and whether it should be only compiled rather than fully built into an executable file. For example, the first line in the previous program above contains the stringC03:IWCompare.cpp, indicating that the fileIWCompare.cpp should be extracted into the directoryC03.
   The last line of a source file contains a triple-slash followed by a colon and a tilde. If the first line has an exclamation point immediately after the colon, the first and last lines of the source code are not to be output to the file (this is for data-only files). (If you’re wondering why we’re avoiding showing you these tokens, it’s because we don’t want to break the code extractor when applied to the text of the book!).
   Bruce’s Python program does a lot more than just extract code. If the token "{O}" follows the file name, its makefile entry will only be set up to compile the file and not to link it into an executable. (The Test Framework in Chapter 2 is built this way.) To link such a file with another source example, the target executable’s source file will contain an "{L}" directive, as in.
   //{L} ../TestSuite/Test

   This section will present a program to just extract all the code so that you can compile and inspect it manually. You can use this program to extract all the code in this book by saving the document file as a text file[36] (let’s call it TICV2.txt) and by executing something like the following on a shell command line:.
   C:&gt; extractCode TICV2.txt /TheCode

   This command reads the text fileTICV2.txt and writes all the source code files in subdirectories under the top-level directory/TheCode. The directory tree will look like the following:
   TheCode/
      C0B/
      C01/
      C02/
      C03/
      C04/
      C05/
      C06/
      C07/
      C08/
      C09/
      C10/
      C11/
      TestSuite/

   The source files containing the examples from each chapter will be in the corresponding directory.
   Here’s the program:
   //: C03:ExtractCode.cpp
   // Extracts code from text
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;cstdio&gt;
   #include&lt;cstdlib&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;
   // Legacy non-standard C header for mkdir()
   #ifdef __GNUC__
   #include&lt;sys/stat.h&gt;
   #elif defined(__BORLANDC__) || defined(_MSC_VER)
   #include&lt;direct.h&gt;
   #else
   #error Compiler not supported
   #endif

   // Check to see if directory exists
   // by attempting to open a new file
   // for output within it.
   bool exists(string fname) {
     size_t len = fname.length();
     if(fname[len-1] != '/'&& fname[len-1] != '\\')
       fname.append("/");
     fname.append("000.tmp");
     ofstream outf(fname.c_str());
     bool existFlag = outf;
     if (outf) {
       outf.close();
       remove(fname.c_str());
     }
     return existFlag;
   }

   int main(int argc, char* argv[]) {
     // See if input file name provided
     if(argc == 1) {
       cerr&lt;&lt; "usage: extractCode file [dir]\n";
       exit(EXIT_FAILURE);
     }
     // See if input file exists
     ifstream inf(argv[1]);
     if(!inf) {
       cerr&lt;&lt; "error opening file: "&lt;&lt; argv[1]&lt;&lt; endl;
       exit(EXIT_FAILURE);
     }
     // Check for optional output directory
     string root("./");  // current is default
     if(argc == 3) {
       // See if output directory exists
       root = argv[2];
       if(!exists(root)) {
         cerr&lt;&lt; "no such directory: "&lt;&lt; root&lt;&lt; endl;
         exit(EXIT_FAILURE);
       }
       size_t rootLen = root.length();
       if(root[rootLen-1] != '/'&& root[rootLen-1] != '\\')
         root.append("/");
     }
     // Read input file line by line
     // checking for code delimiters
     string line;
     bool inCode = false;
     bool printDelims = true;
     ofstream outf;
     while (getline(inf, line)) {
       size_t findDelim = line.find("//" "/:~");
       if(findDelim != string::npos) {
         // Output last line and close file
         if (!inCode) {
           cerr&lt;&lt; "Lines out of order\n";
           exit(EXIT_FAILURE);
         }
         assert(outf);
         if (printDelims)
           outf&lt;&lt; line&lt;&lt; endl;
         outf.close();
         inCode = false;
         printDelims = true;
       } else {
         findDelim = line.find("//" ":");
         if(findDelim == 0) {
           // Check for '!' directive
           if(line[3] == '!') {
             printDelims = false;
             ++findDelim;  // To skip '!' for next search
           }
           // Extract subdirectory name, if any
           size_t startOfSubdir =
             line.find_first_not_of(" \t", findDelim+3);
           findDelim = line.find(':', startOfSubdir);
           if (findDelim == string::npos) {
             cerr&lt;&lt; "missing filename information\n"&lt;&lt; endl;
             exit(EXIT_FAILURE);
           }
           string subdir;
           if(findDelim&gt; startOfSubdir)
             subdir = line.substr(startOfSubdir,
                   findDelim - startOfSubdir);
           // Extract file name (better be one!)
           size_t startOfFile = findDelim + 1;
           size_t endOfFile =
             line.find_first_of(" \t", startOfFile);
           if(endOfFile == startOfFile) {
             cerr&lt;&lt; "missing filename\n";
             exit(EXIT_FAILURE);
           }
           // We have all the pieces; build fullPath name
           string fullPath(root);
           if(subdir.length()&gt; 0)
             fullPath.append(subdir).append("/");
           assert(fullPath[fullPath.length()-1] == '/');
           if (!exists(fullPath))
   #ifdef __GNUC__
             mkdir(fullPath.c_str(), 0);  // Create subdir
   #else
             mkdir(fullPath.c_str());  // Create subdir
   #endif
           fullPath.append(line.substr(startOfFile,
            endOfFile - startOfFile));
           outf.open(fullPath.c_str());
           if(!outf) {
             cerr&lt;&lt; "error opening "&lt;&lt; fullPath
   &lt;&lt; " for output\n";
             exit(EXIT_FAILURE);
           }
           inCode = true;
           cout&lt;&lt; "Processing "&lt;&lt; fullPath&lt;&lt; endl;
           if(printDelims)
             outf&lt;&lt; line&lt;&lt; endl;
         }
         else if(inCode) {
           assert(outf);
           outf&lt;&lt; line&lt;&lt; endl;  // output middle code line
         }
       }
     }
     exit(EXIT_SUCCESS);
   } ///:~

   First, you’ll notice some conditional compilation directives. Themkdir( ) function, which creates a directory in the file system, is defined by the POSIX[37] standard in the header&lt;sys/stat.h&gt;. Unfortunately, many compilers still use a different header (&lt;direct.h&gt;). The respective signatures formkdir( ) also differ: POSIX specifies two arguments, the older versions just one. For this reason, there is more conditional compilation later in the program to choose the right call tomkdir( ). We normally don’t use conditional compilation in the examples in this book, but this particular program is too useful not to put a little extra work into, since you can use it to extract all the code with it.
   Theexists( ) function inExtractCode.cpp tests whether a directory exists by opening a temporary file in it. If the open fails, the directory doesn’t exist. You remove a file by sending its name as achar* tostd::remove( ).
   The main program validates the command-line arguments and then reads the input file a line at a time, looking for the special source code delimiters. The Boolean flaginCode indicates that the program is in the middle of a source file, so lines should be output. TheprintDelims flag will be true if the opening token is not followed by an exclamation point; otherwise the first and last lines are not written. It is important to check for the closing delimiter first, because the start token is a subset of it, and searching for the start token first would return a successful find for both cases. If we encounter the closing token, we verify that we are in the middle of processing a source file; otherwise, something is wrong with the way the delimiters are laid out in the text file. IfinCode is true, all is well, and we (optionally) write the last line and close the file. When the opening token is found, we parse the directory and file name components and open the file. The followingstring-related functions were used in this example:length( ),append( ),getline( ),find( ) (two versions),find_first_not_of( ),substr( ),find_first_of( ),c_str( ), and, of course,operator&lt;&lt;( ).
   We also use a standard C technique for reporting program status to the calling context by returning different values frommain( ). It is portable to use the statementreturn 0; to indicate success, but there is no portable value to indicate failure. For this reason we use the macro declared for this very purpose in&lt;cstdlib&gt;:EXIT_FAILURE. As a matter of consistency, whenever we useEXIT_FAILURE we also useEXIT_SUCCESS, even though the latter is always defined as zero.
   Summary
   C++ string objects provide developers with a number of great advantages over their C counterparts. For the most part, thestring class makes referring to strings through the use of character pointers unnecessary. This eliminates an entire class of software defects that arise from the use of uninitialized and incorrectly valued pointers. C++ strings dynamically and transparently grow their internal data storage space to accommodate increases in the size of the string data. This means that when the data in a string grows beyond the limits of the memory initially allocated to it, the string object will make the memory management calls that take space from and return space to the heap. Consistent allocation schemes prevent memory leaks and have the potential to be much more efficient than "roll your own" memory management.
   Thestring class member functions provide a fairly comprehensive set of tools for creating, modifying, and searching in strings. String comparisons are always case sensitive, but you can work around this by copying string data to C-style null-terminated strings and using case-insensitive string comparison functions, temporarily converting the data held in string objects to a single case, or by creating a case-insensitive string class that overrides the character traits used to create thebasic_string object.
   Exercises
                1.             Write a program that reverses the order of the characters in a string.
            18.             A palindrome is a word or group of words that read the same forward and backward. For example "madam" or "wow." Write a program that takes a string argument from the command line and prints whether the string was a palindrome or not.
            19.             Make your program from exercise 2 returntrue even if symmetric letters differ in case. For example, "Civic" would still returntrue although the first letter is capitalized.
           20.             Make your program from exercise 3 report true even if the string contains punctuation and spaces. For example "Able was I, ere I saw Elba." would reporttrue.
            21.             Using the following strings and onlychars (no string literals or magic numbers):
   string one("I walked down the canyon with the moving mountain bikers.");
   string two("The bikers passed by me too close for comfort."); string three("I went hiking instead.")
            produce the following sentence:
   "I moved down the canyon with the mountain bikers. The mountain bikers passed by me too close for comfort. So I went hiking instead."
           22.             Write a program namedreplace that takes three command-line arguments representing an input text file, a string to replace (call itfrom), and a replacement string (call itto). The program should write a new file to standard output with all occurrences offrom replaced byto.
           23.             Repeat the previous exercise but replace all instances offrom regardless of case.

   4: Iostreams
   You can do much more with the general I/O problem than just take standard I/O and turn it into a class.
   Wouldn’t it be nice if you could make all the usual "receptacles"—standard I/O, files, and even blocks of memory—look the same so that you need to remember only one interface? That’s the idea behind iostreams. They’re much easier, safer, and sometimes even more efficient than the assorted functions from the Standard Cstdio library.
   The iostreams classes are usually the first part of the C++ library that new C++ programmers learn to use. This chapter discusses how iostreams are an improvement over C’sstdio facilities and explores the behavior of file and string streams in addition to the standard console streams.
   Why iostreams?
   You might wonder what’s wrong with the good old C library. Why not "wrap" the C library in a class and be done with it? Indeed, this is the perfect thing to do in some situations. For example, suppose you want to make sure the file represented by astdio FILE pointer is always safely opened and properly closed, without having to rely on the user to remember to call theclose( ) function. The following program is such an attempt.
   //: C04:FileClass.h
   // stdio files wrapped
   #ifndef FILECLASS_H
   #define FILECLASS_H
   #include&lt;cstdio&gt;
   #include&lt;stdexcept&gt;

   class FileClass {
     std::FILE* f;
   public:
     struct FileClassError : std::runtime_error {
     public:
       FileClassError(const char* msg)
         : std::runtime_error(msg) {}
     };
     FileClass(const char* fname, const char* mode = "r");
     ~FileClass();
     std::FILE* fp();
   };
   #endif // FILECLASS_H ///:~

   When you perform file I/O in C, you work with a naked pointer to a FILEstruct, but this class wraps around the pointer and guarantees it is properly initialized and cleaned up using the constructor and destructor. The second constructor argument is the file mode, which defaults to "r" for "read.".
   To fetch the value of the pointer to use in the file I/O functions, you use thefp( ) access function. Here are the member function definitions:.
   //: C04:FileClass.cpp {O}
   // FileClassImplementation
   #include "FileClass.h"
   #include&lt;cstdlib&gt;
   #include&lt;cstdio&gt;
   using namespace std;

   FileClass::FileClass(const char* fname, const char* mode) {
     if((f = fopen(fname, mode)) == 0)
       throw FileClassError("Error opening file");
   }

   FileClass::~FileClass() { fclose(f); }

   FILE* FileClass::fp() { return f; } ///:~

   The constructor callsfopen( ), as you would normally do, but it also ensures that the result isn’t zero, which indicates a failure upon opening the file. If the file does not open as expected, an exception is thrown.
   The destructor closes the file, and the access functionfp( )returnsf. Here’s a simple example usingclass FileClass:.
   //: C04:FileClassTest.cpp
   // Tests FileClass
   //{L} FileClass
   #include&lt;cstdlib&gt;
   #include&lt;iostream&gt;
   #include "FileClass.h"
   using namespace std;

   int main() {
     try {
       FileClass f("FileClassTest.cpp");
       const int BSIZE = 100;
       char buf[BSIZE];
       while(fgets(buf, BSIZE, f.fp()))
         fputs(buf, stdout);
     }
     catch(FileClass::FileClassError& e) {
       cout&lt;&lt; e.what()&lt;&lt; endl;
       return EXIT_FAILURE;
     }
     return EXIT_SUCCESS;
   } // File automatically closed by destructor
   ///:~

   You create theFileClass object and use it in normal C file I/O function calls by callingfp( ). When you’re done with it, just forget about it; the file is closed by the destructor at the end of its scope.
   Even though theFILE pointer is private, it isn’t particularly safe becausefp( ) retrieves it. Since the only effect seems to be guaranteed initialization and cleanup, why not make it public or use astruct instead? Notice that while you can get a copy off usingfp( ), you cannot assign tof— that’s completely under the control of the class. Of course, after capturing the pointer returned byfp( ), the client programmer can still assign to the structure elements or even close it, so the safety is in guaranteeing a validFILE pointer rather than proper contents of the structure.
   If you want complete safety, you must prevent the user from directly accessing theFILE pointer. Some version of all the normal file I/O functions must show up as class members so that everything you can do with the C approach is available in the C++ class:.
   //: C04:Fullwrap.h
   // Completely hidden file IO
   #ifndef FULLWRAP_H
   #define FULLWRAP_H

   class File {
     std::FILE* f;
     std::FILE* F(); // Produces checked pointer to f
   public:
     File(); // Create object but don't open file
     File(const char* path,
          const char* mode = "r");
     ~File();
     int open(const char* path,
              const char* mode = "r");
     int reopen(const char* path,
                const char* mode);
     int getc();
     int ungetc(int c);
     int putc(int c);
     int puts(const char* s);
     char* gets(char* s, int n);
     int printf(const char* format, ...);
     size_t read(void* ptr, size_t size,
                 size_t n);
     size_t write(const void* ptr,
   size_t size, size_t n);
     int eof();
     int close();
     int flush();
     int seek(long offset, int whence);
     int getpos(fpos_t* pos);
     int setpos(const fpos_t* pos);
     long tell();
     void rewind();
     void setbuf(char* buf);
     int setvbuf(char* buf, int type, size_t sz);
     int error();
     void clearErr();
   };
   #endif // FULLWRAP_H ///:~

   This class contains almost all the file I/O functions from&lt;cstdio&gt;. (vfprintf( ) is missing; it is used to implement theprintf( ) member function.).
   File has the same constructor as in the previous example, and it also has a default constructor. The default constructor is important if you want to create an array ofFile objects or use aFile object as a member of another class in which the initialization doesn’t happen in the constructor, but some time after the enclosing object is created.
   The default constructor sets the privateFILE pointerf to zero. But now, before any reference tof, its value must be checked to ensure it isn’t zero. This is accomplished withF( ), which isprivate because it is intended to be used only by other member functions. (We don’t want to give the user direct access to the underlyingFILE structure in this class.)[38] 
   This approach is not a terrible solution by any means. It’s quite functional, and you could imagine making similar classes for standard (console) I/O and for in-core formatting (reading/writing a piece of memory rather than a file or the console).
   The big stumbling block is the runtime interpreter used for the variable argument list functions. This is the code that parses your format string at runtime and grabs and interprets arguments from the variable argument list. It’s a problem for four reasons.
   1.Even if you use only a fraction of the functionality of the interpreter, the whole thing gets loaded into your executable. So if you say printf("%c", 'x');, you’ll get the whole package, including the parts that print floating-point numbers and strings. There’s no standard option for reducing the amount of space used by the program.
   2.Because the interpretation happens at runtime, you can’t get rid of a performance overhead. It’s frustrating because all the information isthere in the format string at compile time, but it’s not evaluated until runtime. However, if you could parse the arguments in the format string at compile time, you could make direct function calls that have the potential to be much faster than a runtime interpreter (although theprintf( ) family of functions is usually quite well optimized).
   3.A worse problem is that the format string is not evaluated until runtime: there can be no compile-time error checking. You’re probably familiar with this problem if you’ve tried to find bugs that came from using the wrong number or type of arguments in aprintf( ) statement. C++ makes a big deal out of compile-time error checking to find errors early and make your life easier. It seems a shame to throw type safety away for an I/O library, especially because I/O is used a lot.
   4.For C++, the most crucial problem is that theprintf( ) family of functions is not particularly extensible. They’re really designed to handle only the four basic data types in C (char,int,float,double,wchar_t,char*,wchar_t*, andvoid*) and their variations. You might think that every time you add a new class, you could add overloadedprintf( ) andscanf( ) functions (and their variants for files and strings), but remember, overloaded functions must have different types in their argument lists, and theprintf( ) family hides its type information in the format string and in the variable argument list. For a language such as C++, whose goal is to be able to easily add new data types, this is an ungainly restriction.
   Iostreams to the rescue
   All these issues make it clear that one of the first priorities for the standard class libraries for C++ should handle I/O. Because "hello, world" is the first program just about everyone writes in a new language, and because I/O is part of virtually every program, the I/O library in C++ must be particularly easy to use. It also has the much greater challenge that it must accommodate any new class. Thus, its constraints require that this foundation class library be a truly inspired design. In addition to gaining a great deal of leverage and clarity in your dealings with I/O and formatting, you’ll also see in this chapter how a really powerful C++ library can work.
   Inserters and extractors
   Astream is an object that transports and formats characters of a fixed width. You can have an input stream (via descendants of theistream class), an output stream (withostream objects), or a stream that does both simultaneously (with objects derived fromiostream). The iostreams library provides different types of such classes:ifstream,ofstream, andfstream for files, andistringstream,ostringstream, andstringstream for interfacing with the Standard C++string class. All these stream classes have nearly identical interfaces, so you can use streams in a uniform manner, whether you’re working with a file, standard I/O, a region of memory, or astring object. The single interface you learn also works for extensions added to support new classes. Some functions implement your formatting commands, and some functions read and write characters without formatting.
   The stream classes mentioned earlier are actually template specializations,[39] much like the standardstring class is a specialization of thebasic_string template. The basic classes in the iostreams inheritance hierarchy are shown in the following figure.
    [Êàðòèíêà: img_1.png] 
   Theios_base class declares everything that is common to all streams, independent of the type of character the stream handles. These declarations are mostly constants and functions to manage them, some of which you’ll see throughout this chapter. The rest of the classes are templates that have the underlying character type as a parameter. Theistream class, for example, is defined as follows:.
   typedef basic_istream&lt;char&gt; istream;

   All the classes mentioned earlier are defined via similar type definitions. There are also type definitions for all stream classes usingwchar_t (the wide character type discussed in Chapter 3) instead ofchar. We’ll look at these at the end of this chapter. Thebasic_ios template defines functions common to both input and output, but that depends on the underlying character type (we won’t use these much). The templatebasic_istream defines generic functions for input, andbasic_ostream does the same for output. The classes for file and string streams introduced later add functionality for their specific stream types.
   In the iostreams library, two operators are overloaded to simplify the use of iostreams. The operator&lt;&lt; is often referred to as aninserter for iostreams, and the operator&gt;&gt; is often referred to as anextractor.
   Extractors parse the information that’s expected by the destination object according to its type. To see an example of this, you can use thecin object, which is the iostream equivalent ofstdin in C, that is, redirectable standard input. This object is predefined whenever you include the&lt;iostream&gt;header.
     int i;
     cin&gt;&gt; i;

     float f;
     cin&gt;&gt; f;

     char c;
     cin&gt;&gt; c;

     char buf[100];
     cin&gt;&gt; buf;

   There’s an overloadedoperator&gt;&gt; for every built-in data type. You can also overload your own, as you’ll see later.
   To find out what you have in the various variables, you can use thecout object (corresponding to standard output; there’s also acerr object corresponding to standard error) with the inserter&lt;&lt;:.
     cout&lt;&lt; "i = ";
     cout&lt;&lt; i;
     cout&lt;&lt; "\n";
     cout&lt;&lt; "f = ";
     cout&lt;&lt; f;
     cout&lt;&lt; "\n";
     cout&lt;&lt; "c = ";
     cout&lt;&lt; c;
     cout&lt;&lt; "\n";
     cout&lt;&lt; "buf = ";
     cout&lt;&lt; buf;
     cout&lt;&lt; "\n";

   This is notably tedious and doesn’t seem like much of an improvement overprintf( ), despite improved type checking. Fortunately, the overloaded inserters and extractors are designed to be chained together into a more complicated expression that is much easier to write (and read):.
     cout&lt;&lt; "i = "&lt;&lt; i&lt;&lt; endl;
     cout&lt;&lt; "f = "&lt;&lt; f&lt;&lt; endl;
     cout&lt;&lt; "c = "&lt;&lt; c&lt;&lt; endl;
     cout&lt;&lt; "buf = "&lt;&lt; buf&lt;&lt; endl;

   Defining inserters and extractors for your own classes is just a matter of overloading the associated operators to do the right things, namely:
   ·         Make the first parameter a non-const reference to the stream (istream for input,ostream for output)
   ·         Perform the operation by insert/extracting data to/from the stream (by processing the components of the object, of course)
   ·         Return a reference to the stream
   The stream should be non-const because processing stream data changes the state of the stream. By returning the stream, you allow for chaining stream operations in a single statement, as shown earlier.
   As an example, consider how to output the representation of aDate object in MM-DD-YYYY format. The following inserter does the job:
   ostream& operator&lt;&lt;(ostream& os, const Date& d) {
     char fillc = os.fill('0');
     os&lt;&lt; setw(2)&lt;&lt; d.getMonth()&lt;&lt; '-'
       &lt;&lt; setw(2)&lt;&lt; d.getDay()&lt;&lt; '-'
       &lt;&lt; setw(4)&lt;&lt; setfill(fillc)&lt;&lt; d.getYear();
     return os;
   }

   This function cannot be a member of theDate class, of course, because the left operand of the&lt;&lt; operator must be the output stream. Thefill( ) member function ofostream changes the padding character used when the width of an output field, determined by themanipulatorsetw( ), is greater than needed for the data. We use a‘0’ character so that months before October will display with a leading zero, such as "09" for September. Thefill( ) function also returns the previous fill character (which defaults to a single space) so that we can restore it later with the manipulatorsetfill( ). We discuss manipulators in depth later in this chapter.
   Extractors require a little more care because things sometimes go wrong with input data. The way to signal a stream error is to set the stream’sfail bit, as follows:
   istream& operator&gt;&gt;(istream& is, Date& d) {
     is&gt;&gt; d.month;
     char dash;
     is&gt;&gt; dash;
     if (dash != '-')
       is.setstate(ios::failbit);
     is&gt;&gt; d.day;
     is&gt;&gt; dash;
     if (dash != '-')
       is.setstate(ios::failbit);
     is&gt;&gt; d.year;
     return is;
   }

   When an error bit is set in a stream, all further streams operations are ignored until the stream is restored to a good state (explained shortly). That’s why the code above continues extracting even ifios::failbit gets set. This implementation is somewhat forgiving in that it allows white space between the numbers and dashes in a date string (because the&gt;&gt; operator skips white space by default when reading built-in types). The following are valid date strings for this extractor:.
   "08-10-2003"
   "8-10-2003"
   "08 - 10 - 2003"

   but these are not:
   "A-10-2003"    // No alpha characters allowed
   "08%10/2003"   // Only dashes allowed as a delimiter

   We’ll discuss stream state in more depth in the section "Handling stream errors" later in this chapter.
   Common usage
   As theDate extractor illustrated, you must be on guard for erroneous input. If the input produces an unexpected value, the process is skewed, and it’s difficult to recover. In addition, formatted input defaults to white space delimiters. Consider what happens when we collect the code fragments from earlier in this chapter into a single program:.
   //: C04:Iosexamp.cpp
   // Iostream examples
   #include&lt;iostream&gt;
   using namespace std;

   int main() {
     int i;
     cin&gt;&gt; i;

     float f;
     cin&gt;&gt; f;

     char c;
     cin&gt;&gt; c;

     char buf[100];
     cin&gt;&gt; buf;

     cout&lt;&lt; "i = "&lt;&lt; i&lt;&lt; endl;
     cout&lt;&lt; "f = "&lt;&lt; f&lt;&lt; endl;
     cout&lt;&lt; "c = "&lt;&lt; c&lt;&lt; endl;
     cout&lt;&lt; "buf = "&lt;&lt; buf&lt;&lt; endl;

     cout&lt;&lt; flush;
     cout&lt;&lt; hex&lt;&lt; "0x"&lt;&lt; i&lt;&lt; endl;
   } ///:~

   and give it the following input:.
   12 1.4 c this is a test

   We expect the same output as if we gave it:
   12
   1.4
   c
   this is a test

   but the output is, somewhat unexpectedly
   i = 12
   f = 1.4
   c = c
   buf = this
   0xc

   Notice thatbuf got only the first word because the input routine looked for a space to delimit the input, which it saw after "this." In addition, if the continuous input string is longer than the storage allocated forbuf, we overrun the buffer.
   In practice, you’ll usually want to get input from interactive programs a line at a time as a sequence of characters, scan them, and then perform conversions once they’re safely in a buffer. This way you don’t have to worry about the input routine choking on unexpected data.
   Another thing to consider is the whole concept of a command-line interface. This made sense in the past when the console was little more than a glass typewriter, but the world is rapidly changing to one in which the graphical user interface (GUI) dominates. What is the meaning of console I/O in such a world? It makes much more sense to ignorecin altogether, other than for simple examples or tests, and take the following approaches:.
   1.If your program requires input, read that input from a file—you’ll soon see that it’s remarkably easy to use files with iostreams. Iostreams for files still works fine with a GUI.
   2.Read the input without attempting to convert it, as we just suggested. When the input is some place where it can’t foul things up during conversion, you can safely scan it.
   3.Output is different. If you’re using a GUI,cout doesn’t necessarily work, and you must send it to a file (which is identical to sending it tocout) or use the GUI facilities for data display. Otherwise it often makes sense to send it tocout. In both cases, the output formatting functions of iostreams are highly useful.
   Another common practice saves compile time on large projects. Consider, for example, how you would declare the Date stream operators introduced earlier in the chapter in a header file. You only need to include the prototypes for the functions, so it’s not really necessary to include the entire&lt;iostream&gt; header inDate.h. The standard practice is to only declare classes, something like this:.
   class ostream;

   This is an age-old technique for separating interface from implementation and is often called aforward declaration (andostream at this point would be considered anincomplete type, since the class definition has not yet been seen by the compiler).
   This will not work as is, however, for two reasons:
   1.       The stream classes are defined in thestd namespace.
   2.      They are templates.
   The proper declaration would be:
   namespace std {
     template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
       class basic_ostream;
     typedef basic_ostream&lt;char&gt; ostream;
   }

   (As you can see, like thestring class, the streams classes use the character traits classes mentioned in Chapter 3). Since it would be terribly tedious to type all that for every stream class you want to reference, the standard provides a header that does it for you:&lt;iosfwd&gt;. TheDate header would then look something like this:.
   // Date.h
   #include&lt;iosfwd&gt;
   class Date {
     friend std::ostream& operator&lt;&lt;(std::ostream&,
                      const Date&);
     friend std::istream& operator&gt;&gt;(std::istream&, Date&);
     // etc.

   Line-oriented input
   To grab input a line at a time, you have three choices:
   The member functionget( )
   The member functiongetline( )
   The global functiongetline( ) defined in the&lt;string&gt; header
   The first two functions take three arguments:
   A pointer to a character buffer in which to store the result
   The size of that buffer (so it’s not overrun)
   The terminating character, to know when to stop reading input
   The terminating character has a default value of'\n', which is what you’ll usually use. Both functions store a zero in the result buffer when they encounter the terminating character in the input.
   So what’s the difference? Subtle, but important:get( ) stops when itsees the delimiter in the input stream, but it doesn’t extract it from the input stream. Thus, if you did anotherget( ) using the same delimiter, it would immediately return with no fetched input. (Presumably, you either use a different delimiter in the nextget( ) statement or a different input function.) Thegetline( )function, on the other hand, extracts the delimiter from the input stream, but still doesn’t store it in the result buffer.
   Thegetline( ) function defined in&lt;string&gt; is convenient. It is not a member function, but rather a stand-alone function declared in the namespacestd. It takes only two non-default arguments, the input stream and thestring object to populate. Like its namesake, it reads characters until it encounters the first occurrence of the delimiter ('\n' by default) and consumes and discards the delimiter. The advantage of this function is that it reads into astring object, so you don’t have to worry about buffer size.
   Generally, when you’re processing a text file that you read a line at a time, you’ll want to use one of thegetline( ) functions.
   Overloaded versions of get( )
   Theget( ) function also comes in three other overloaded versions: one with no arguments that returns the next character, using anint return value; one that stuffs a character into itschar argument, using areference; and one that stores directly into the underlying buffer structure of another iostream object. The latter is explored later in the chapter.
   Reading raw bytes
   If you know exactly what you’re dealing with and want to move the bytes directly into a variable, an array, or a structure in memory, you can use the unformatted I/O functionread( ). The first argument is a pointer to the destination memory, and the second is the number of bytes to read. This is especially useful if you’ve previously stored the information to a file, for example, in binary form using the complementarywrite( ) member function for an output stream (using the same compiler, of course). You’ll see examples of all these functions later.
   Handling stream errors
   TheDate extractor shown earlier sets a stream’s fail bit under certain conditions. How does the user know when such a failure occurs? You can detect stream errors by either calling certain stream member functions to see if an error state has occurred, or if you don’t care what the particular error was, you can just evaluate the stream in a Boolean context. Both techniques derive from the state of a stream’s error bits.
   Stream state
   Theios_base class, from whichios derives,[40] defines four flags that you can use to test the state of a stream:
FlagMeaningbadbitSome fatal (perhaps physical) error occurred. The stream should be considered unusable.eofbitEnd-of-input has occurred (either by encountering the physical end of a file stream or by the user terminating a console stream, such as with Ctrl-Z or Ctrl-D).failbitAn I/O operation failed, most likely because of invalid data (e.g., letters were found when trying to read a number). The stream is still usable. The failbit flag is also set when end-of-input occurs.goodbitAll is well; no errors. End-of-input has not yet occurred.

   You can test whether any of these conditions have occurred by calling corresponding member functions that return a Boolean value indicating whether any of these have been set. Thegood( ) stream member function returns true if none of the other three bits are set. Theeof( ) function returns true ifeofbit is set, which happens with an attempt to read from a stream that has no more data (usually a file). Because end-of-input happens in C++ when trying to read past the end of the physical medium,failbit is also set to indicate that the "expected" data was not successfully read. Thefail( ) function returns true ifeitherfailbit orbadbit is set, andbad( ) returns true only if thebadbit is set.
   Once any of the error bits in a stream’s state are set, they remain set, which is not always what you want. When reading a file for example, you might want to reposition to an earlier place in the file before end-of-file occurred. Just moving the file pointer doesn’t automatically reseteofbit orfailbit; you have to do it yourself with theclear( ) function, like this:.
   myStream.clear();    // Clears all error bits

   After callingclear( ),good( ) will returntrue if called immediately. As you saw in theDate extractor earlier, thesetstate( ) function sets the bits you pass it. It turns out thatsetstate( ) doesn’t affect any other bits—if they’re already set, they stay set. If you want to set certain bits but at the same time reset all the rest, you can call an overloaded version ofclear( ), passing it a bitwise expression representing the bits you want to set, as in:.
   myStream.clear(ios::failbit | ios::eofbit);

   Most of the time you won’t be interested in checking the stream state bits individually. Usually you just want to know if everything is okay. This is the case when you read a file from beginning to end; you just want to know when the input data is exhausted. In cases such as these, a conversion operator is defined forvoid* that is automatically called when a stream occurs in a Boolean expression. To read a stream until end-of-input using this idiom looks like the following:.
   int i;
   while (myStream&gt;&gt; i)
     cout&lt;&lt; i&lt;&lt; endl;

   Remember thatoperator&gt;&gt;( ) returns its stream argument, so thewhile statement above tests the stream as a Boolean expression. This particular example assumes that the input streammyStream contains integers separated by white space. The functionios_base::operator void*( ) simply callsgood( ) on its stream and returns the result.[41] Because most stream operations return their stream, using this idiom is convenient.
   Streams and exceptions
   Iostreams existed as part of C++ long before there were exceptions, so checking stream state manually was just the way things were done. For backward compatibility, this is still the status quo, but iostreams can throw exceptions instead. Theexceptions( ) stream member function takes a parameter representing the state bits for which you want exceptions to be thrown. Whenever the stream encounters such a state, it throws an exception of typestd::ios_base::failure, which inherits fromstd::exception.
   Although you can trigger a failure exception for any of the four stream states, it’s not necessarily a good idea to enable exceptions for all of them. As Chapter 1 explains, use exceptions for truly exceptional conditions, but end-of-file is not onlynot exceptional—it’sexpected! For that reason, you might want to enable exceptions only for the errors represented bybadbit, which you would do like this:.
   myStream.exceptions(ios::badbit);

   You enable exceptions on a stream-by-stream basis, sinceexceptions( ) is a member function for streams. Theexceptions( ) function returns a bitmask[42] (of typeiostate, which is some compiler-dependent type convertible toint) indicating which stream states will cause exceptions. If those states have already been set, an exception is thrown immediately. Of course, if you use exceptions in connection with streams, you had better be ready to catch them, which means that you need to wrap all stream processing with atry block that has anios::failure handler. Many programmers find this tedious and just check states manually where they expect errors to occur (since, for example, they don’t expectbad( ) to returntrue most of the time anyway). This is another reason that having streams throw exceptions is optional and not the default. In any case, you can choose how you want to handle stream errors.
   File iostreams
   Manipulating files with iostreams is much easier and safer than usingstdioin C. All you do to open a file is create an object; the constructor does the work. You don’t have to explicitly close a file (although you can, using theclose( ) member function) because the destructor will close it when the object goes out of scope. To create a file that defaults to input, make anifstream object. To create one that defaults to output, make anofstream object. Anfstream object can do both input and output.
   The file stream classes fit into the iostreams classes as shown in the following figure.



    [Êàðòèíêà: img_2.png] 
   As before, the classes you actually use are template specializations defined by type definitions. For example,ifstream, which processes files ofchar, is defined as.
   typedef basic_ifstream&lt;char&gt; ifstream;

   A File-Processing Example
   Here’s an example that shows many of the features discussed so far. Notice the inclusion of&lt;fstream&gt;to declare the file I/O classes. Although on many platforms this will also include&lt;iostream&gt; automatically, compilers are not required to do so. If you want portable code, always include both headers.
   //: C04:Strfile.cpp
   // Stream I/O with files
   // The difference between get()& getline()
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     const int sz = 100; // Buffer size;
     char buf[sz];
     {
       ifstream in("Strfile.cpp"); // Read
       assure(in, "Strfile.cpp"); // Verify open
       ofstream out("Strfile.out"); // Write
       assure(out, "Strfile.out");
       int i = 1; // Line counter

       // A less-convenient approach for line input:
       while(in.get(buf, sz)) { // Leaves \n in input
         in.get(); // Throw away next character (\n)
         cout&lt;&lt; buf&lt;&lt; endl; // Must add \n
         // File output just like standard I/O:
         out&lt;&lt; i++&lt;&lt; ": "&lt;&lt; buf&lt;&lt; endl;
       }
     } // Destructors close in& out

     ifstream in("Strfile.out");
     assure(in, "Strfile.out");
     // More convenient line input:
     while(in.getline(buf, sz)) { // Removes \n
       char* cp = buf;
       while(*cp != ':')
         cp++;
       cp += 2; // Past ": "
       cout&lt;&lt; cp&lt;&lt; endl; // Must still add \n
     }
   } ///:~

   The creation of both theifstream andofstream are followed by anassure( ) to guarantee the file was successfully opened. Here again the object, used in a situation in which the compiler expects a Boolean result, produces a value that indicates success or failure.
   The firstwhile loop demonstrates the use of two forms of theget( ) function. The first gets characters into a buffer and puts a zero terminator in the buffer when eithersz-1 characters have been read or the third argument (defaulted to'\n') is encountered. Theget( ) function leaves the terminator character in the input stream, so this terminator must be thrown away viain.get( ) using the form ofget( ) with no argument, which fetches a single byte and returns it as anint. You can also use theignore( ) member function, which has two default arguments. The first argument is the number of characters to throw away and defaults to one. The second argument is the character at which theignore( ) function quits (after extracting it) and defaults toEOF.
   Next, you see two output statements that look similar: one tocoutand one to the fileout. Notice the convenience here; you don’t need to worry about what kind of object you’re dealing with because the formatting statements work the same with allostream objects. The first one echoes the line to standard output, and the second writes the line out to the new file and includes a line number.
   To demonstrategetline( ), open the file we just created and strip off the line numbers. To ensure the file is properly closed before opening it to read, you have two choices. You can surround the first part of the program with braces to force theout object out of scope, thus calling the destructor and closing the file, which is done here. You can also callclose( ) for both files; if you do this, you can even reuse thein object by calling theopen( ) member function.
   The secondwhile loop shows howgetline( ) removes the terminator character (its third argument, which defaults to'\n') from the input stream when it’s encountered. Althoughgetline( ), likeget( ), puts a zero in the buffer, it still doesn’t insert the terminating character.
   This example, as well as most of the examples in this chapter, assumes that each call to any overload ofgetline( ) will actually encounter a newline character. If this is not the case, the eofbit state of the stream will be set and the call togetline( ) will returnfalse, causing the program to lose the last line of input.
   Open modes
   You can control the way a file is opened by overriding the constructor’s default arguments. The following table shows the flags that control the mode of the file:.FlagFunctionios::inOpens an input file. Use this as an open mode for anofstream to prevent truncating an existing file.ios::outOpens an output file. When used for anofstream withoutios::app,ios::ate orios::in,ios::trunc is implied.ios::appOpens an output file for appending only.ios::ateOpens an existing file (either input or output) and seeks to the end.ios::truncTruncates the old file, if it already exists.ios::binaryOpens a file inbinary mode. The default istext mode.

   You can combine these flags using a bitwiseor operation.
   The binary flag, while portable, only has an effect on some non-UNIX systems, such as operating systems derived from MS-DOS, that have special conventions for storing end-of-line delimiters. For example, on MS-DOS systems in text mode (which is the default), every time you output a newline character ('\n'), the file system actually outputs two characters, a carriage-return/linefeed pair (CRLF), which is the pair of ASCII characters0x0D and0x0A. Conversely, when you read such a file back into memory in text mode, each occurrence of this pair of bytes causes a'\n' to be sent to the program in its place. If you want to bypass this special processing, you open files in binary mode. Binary mode has nothing whatsoever to do with whether youcan write raw bytes to a file—youalways can (by callingwrite( )) . You should, however, open a file in binary mode when you’ll be usingread( ) orwrite( ), because these functions take a byte count parameter. Having the extra'\r' characters will throw your byte count off in those instances. You should also open a file in binary mode if you’re going to use the stream-positioning commands discussed later in this chapter.
   You can open a file for both input and output by declaring anfstream object. When declaring anfstream object, you must use enough of the open mode flags mentioned earlier to let the file system know whether you want to input, output, or both. To switch from output to input, you need to either flush the stream or change the file position. To change from input to output, change the file position. To create a file via anfstream object, you need to use theios::trunc open mode flag in the constructor call if you will actually do both input and output.
   Iostream buffering
   Good design practice dictates that whenever you create a new class, you should endeavor to hide the details of the underlying implementation as much possible from the user of the class. You show them only what they need to know and make the restprivateto avoid confusion. When using inserters and extractors, you normally don’t know or care where the bytes are being produced or consumed, whether you’re dealing with standard I/O, files, memory, or some newly created class or device.
   A time comes, however, when it is important to communicate with the part of the iostream that produces and consumes bytes. To provide this part with a common interface and still hide its underlying implementation, the standard library abstracts it into its own class, calledstreambuf. Each iostream object contains a pointer to some kind ofstreambuf. (The kind depends on whether it deals with standard I/O, files, memory, and so on.) You can access thestreambufdirectly; for example, you can move raw bytes into and out of thestreambuf, without formatting them through the enclosing iostream. This is accomplished by calling member functions for thestreambuf object.
   Currently, the most important thing for you to know is that every iostream object contains a pointer to astreambuf object, and thestreambuf object has some member functions you can call if necessary. For file and string streams, there are specialized types of stream buffers, as the following figure illustrates.
    [Êàðòèíêà: img_3.png] 
   To allow you to access thestreambuf, every iostream object has a member function calledrdbuf( ) that returns the pointer to the object’sstreambuf. This way you can call any member function for the underlyingstreambuf. However, one of the most interesting things you can do with thestreambuf pointer is to connect it to another iostream object using the&lt;&lt; operator. This drains all the characters from your object into the one on the left side of the&lt;&lt;. If you want to move all the characters from one iostream to another, you don’t have to go through the tedium (and potential coding errors) of reading them one character or one line at a time. It’s a much more elegant approach.
   For example, here’s a simple program that opens a file and sends the contents to standard output (similar to the previous example):.
   //: C04:Stype.cpp
   // Type a file to standard output
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream in("Stype.cpp");
     assure(in, "Stype.cpp");
     cout&lt;&lt; in.rdbuf(); // Outputs entire file
   } ///:~

   Anifstream is created using the source code file for this program as an argument. Theassure( )function reports a failure if the file cannot be opened. All the work really happens in the statement:.
   cout&lt;&lt; in.rdbuf();

   which sends the entire contents of the file tocout. This is not only more succinct to code, it is often more efficient than moving the bytes one at a time.
   A form ofget( ) allows you to write directly into thestreambuf of another object. The first argument is a reference to the destinationstreambuf, and the second is the terminating character (‘\n’ by default), which stops theget( ) function. So there is yet another way to print a file to standard output:.
   //: C04:Sbufget.cpp
   // Copies a file to standard output
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream in("Sbufget.cpp");
     assure(in);
     streambuf& sb = *cout.rdbuf();
     while (!in.get(sb).eof()) {
       if (in.fail())          // Found blank line
         in.clear();
       cout&lt;&lt; char(in.get()); // Process '\n'
     }
   } ///:~

   Therdbuf( ) function returns a pointer, so it must be dereferenced to satisfy the function’s need to see an object. Stream buffers are not meant to be copied (they have no copy constructor), so we definesb as areference tocout’s stream buffer. We need the calls tofail( ) andclear( ) in case the input file has a blank line (this one does). When this particular overloaded version ofget( ) sees two newlines in a row (evidence of a blank line), it sets the input stream’s fail bit, so we must callclear( ) to reset it so that the stream can continue to be read. The second call toget( ) extracts and echoes each newline delimiter. (Remember, theget( ) function doesn’t extract its delimiter likegetline( ) does.).
   You probably won’t need to use a technique like this often, but it’s nice to know it exists.[43]
   Seeking in iostreams
   Each type of iostream has a concept of where its "next" character will come from (if it’s anistream) or go (if it’s anostream). In some situations, you might want to move this stream position. You can do so using two models: one uses an absolute location in the stream called thestreampos; the second works like the Standard C library functionsfseek( ) for a file and moves a given number of bytes from the beginning, end, or current position in the file.
   Thestreampos approach requires that you first call a "tell" function:tellp( ) for anostream ortellg( ) for anistream. (The "p" refers to the "put pointer," and the "g" refers to the "get pointer.") This function returns astreampos you can later use in calls toseekp( ) for anostream orseekg( ) for anistream, when you want to return to that position in the stream.
   The second approach is a relative seek and uses overloaded versions ofseekp( ) andseekg( ). The first argument is the number of characters to move: it can be positive or negative. The second argument is the seek direction:.ios::begFrom beginning of streamios::curCurrent position in streamios::endFrom end of stream

   Here’s an example that shows the movement through a file, but remember, you’re not limited to seeking within files, as you are with C andcstdio. With C++, you can seek in any type of iostream (although the standard stream objects, such ascin andcout, explicitly disallow it):.
   //: C04:Seeking.cpp
   // Seeking in iostreams
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;cstring&gt;
   #include&lt;fstream&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     const int STR_NUM = 5, STR_LEN = 30;
     char origData[STR_NUM][STR_LEN] = {
       "Hickory dickory dus. . .",
       "Are you tired of C++?",
       "Well, if you have,",
       "That's just too bad,",
       "There's plenty more for us!"
     };
     char readData[STR_NUM][STR_LEN] = { 0 };
     ofstream out("Poem.bin", ios::out | ios::binary);
     assure(out, "Poem.bin");
     for(size_t i = 0; i&lt; STR_NUM; i++)
       out.write(origData[i], STR_LEN);
     out.close();
     ifstream in("Poem.bin", ios::in | ios::binary);
     assure(in, "Poem.bin");
     in.read(readData[0], STR_LEN);
     assert(strcmp(readData[0], "Hickory dickory dus. . .")
       == 0);
     // Seek -STR_LEN bytes from the end of file
     in.seekg(-STR_LEN, ios::end);
     in.read(readData[1], STR_LEN);
     assert(strcmp(readData[1], "There's plenty more for us!")
       == 0);
     // Absolute seek (like using operator[] with a file)
     in.seekg(3 * STR_LEN);
     in.read(readData[2], STR_LEN);
     assert(strcmp(readData[2], "That's just too bad,") == 0);
     // Seek backwards from current position
     in.seekg(-STR_LEN * 2, ios::cur);
     in.read(readData[3], STR_LEN);
     assert(strcmp(readData[3], "Well, if you have,") == 0);
     // Seek from the begining of the file
     in.seekg(1 * STR_LEN, ios::beg);
     in.read(readData[4], STR_LEN);
     assert(strcmp(readData[4], "Are you tired of C++?")
       == 0);
   } ///:~

   This program writes a (very clever?) poem to a file using a binary output stream. Since we reopen it as anifstream, we useseekg( ) to position the "get pointer." As you can see, you can seek from the beginning or end of the file or from the current file position. Obviously, you must provide a positive number to move from the beginning of the file and a negative number to move back from the end.
   Now that you know about thestreambuf and how to seek, you can understand an alternative method (besides using anfstream object) for creating a stream object that will both read and write a file. The following code first creates anifstream with flags that say it’s both an input and an output file. You can’t write to anifstream, of course, so you need to create anostream with the underlying stream buffer:.
   ifstream in("filename", ios::in | ios::out);
   ostream out(in.rdbuf());

   You might wonder what happens when you write to one of these objects. Here’s an example:.
   //: C04:Iofile.cpp
   // Reading& writing one file
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream in("Iofile.cpp");
     assure(in, "Iofile.cpp");
     ofstream out("Iofile.out");
     assure(out, "Iofile.out");
     out&lt;&lt; in.rdbuf(); // Copy file
     in.close();
     out.close();
     // Open for reading and writing:
     ifstream in2("Iofile.out", ios::in | ios::out);
     assure(in2, "Iofile.out");
     ostream out2(in2.rdbuf());
     cout&lt;&lt; in2.rdbuf();  // Print whole file
     out2&lt;&lt; "Where does this end up?";
     out2.seekp(0, ios::beg);
     out2&lt;&lt; "And what about this?";
     in2.seekg(0, ios::beg);
     cout&lt;&lt; in2.rdbuf();
   } ///:~

   The first five lines copy the source code for this program into a file callediofile.out and then close the files. This gives us a safe text file to play with. Then the aforementioned technique is used to create two objects that read and write to the same file. Incout&lt;&lt; in2.rdbuf( ), you can see the "get" pointer is initialized to the beginning of the file. The "put" pointer, however, is set to the end of the file because "Where does this end up?" appears appended to the file. However, if the put pointer is moved to the beginning with aseekp( ), all the inserted textoverwritesthe existing text. Both writes are seen when the get pointer is moved back to the beginning with aseekg( ), and the file is displayed. Of course, the file is automatically saved and closed whenout2 goes out of scope and its destructor is called.
   String iostreams
   A string stream works directly with memory instead of a file or standard output. It allows you to use the same reading and formatting functions that you use withcin andcout to manipulate bytes in memory. On old computers, the memory was referred to ascore, so this type of functionality is often calledin-core formatting.
   The class names for string streams echo those for file streams. If you want to create a string stream to extract characters from, you create anistringstream. If you want to put characters into a string stream, you create anostringstream. All declarations for string stream are in the standard header&lt;sstream&gt;. As usual, there are class templates that fit into the iostreams hierarchy, as shown in the following figure:.
    [Êàðòèíêà: img_4.png] 
   Input string streams
   To read from a string using stream operations, you create anistringstream object initialized with the string. The following program shows how to use anistringstream object.
   //: C04:Istring.cpp
   // Input string streams
   #include&lt;cassert&gt;
   #include&lt;cmath&gt;  // For fabs()
   #include&lt;iostream&gt;
   #include&lt;limits&gt; // For epsilon()
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     istringstream s("47 1.414 This is a test");
     int i;
     double f;
     s&gt;&gt; i&gt;&gt; f; // Whitespace-delimited input
     assert(i == 47);
     double relerr = (fabs(f) - 1.414) / 1.414;
     assert(relerr&lt;= numeric_limits&lt;double&gt;::epsilon());
     string buf2;
     s&gt;&gt; buf2;
     assert(buf2 == "This");
     cout&lt;&lt; s.rdbuf(); // " is a test"
   } ///:~

   You can see that this is a more flexible and general approach to transforming character strings to typed values than the standard C library functions such asatof( ),atoi( ), even though the latter may be more efficient for single conversions.
   In the expressions&gt;&gt; i&gt;&gt; f, the first number is extracted intoi, and the second intof. This isn’t "the first whitespace-delimited set of characters" because it depends on the data type it’s being extracted into. For example, if the string were instead, "1.414 47 This is a test," theni would get the value 1 because the input routine would stop at the decimal point. Thenf would get0.414. This could be useful if you want to break a floating-point number into a whole number and a fraction part. Otherwise it would seem to be an error. The secondassert( ) calculates the relative error between what we read and what we expected; it’s always better to do this than to compare floating-point numbers for equality. The constant returned byepsilon( ), defined in&lt;limits&gt;, represents themachine epsilon for double-precision numbers, which is the best tolerance you can expect comparisons ofdoubles to satisfy.[44] 
   As you may already have guessed,buf2 doesn’t get the rest of the string, just the next white-space-delimited word. In general, it’s best to use the extractor in iostreams when you know the exact sequence of data in the input stream and you’re converting to some type other than a character string. However, if you want to extract the rest of the string all at once and send it to another iostream, you can userdbuf( ) as shown.
   To test theDate extractor at the beginning of this chapter, we used an input string stream with the following test program:
   //: C04:DateIOTest.cpp
   //{L} ../C02/Date
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include "../C02/Date.h"
   using namespace std;

   void testDate(const string& s) {
     istringstream os(s);
     Date d;
     os&gt;&gt; d;
     if (os)
       cout&lt;&lt; d&lt;&lt; endl;
     else
       cout&lt;&lt; "input error with \""&lt;&lt; s&lt;&lt; "\"\n";
   }

   int main() {
     testDate("08-10-2003");
     testDate("8-10-2003");
     testDate("08 - 10 - 2003");
     testDate("A-10-2003");
     testDate("08%10/2003");
   } ///:~

   Each string literal inmain( ) is passed by reference totestDate( ), which in turn wraps it in anistringstream so we can test the stream extractor we wrote forDate objects. The functiontestDate( ) also begins to test the inserter,operator&lt;&lt;( ).
   Output string streams
   To create an output string stream to put data into, you just create anostringstream object, which manages a dynamically sized character buffer to hold whatever you insert. To get the formatted result as astring object, you call thestr( ) member function. Here’s an example:.
   //: C04:Ostring.cpp
   // Illustrates ostringstream
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     cout&lt;&lt; "type an int, a float and a string: ";
     int i;
     float f;
     cin&gt;&gt; i&gt;&gt; f;
     cin&gt;&gt; ws; // Throw away white space
     string stuff;
     getline(cin, stuff); // Get rest of the line
     ostringstream os;
     os&lt;&lt; "integer = "&lt;&lt; i&lt;&lt; endl;
     os&lt;&lt; "float = "&lt;&lt; f&lt;&lt; endl;
     os&lt;&lt; "string = "&lt;&lt; stuff&lt;&lt; endl;
     string result = os.str();
     cout&lt;&lt; result&lt;&lt; endl;
   } ///:~

   This is similar to theIstring.cpp example earlier that fetched anint and afloat. A sample execution follows (the keyboard input is in bold type).
   type an int, a float and a string:10 20.5 the end
   integer = 10
   float = 20.5
   string = the end

   You can see that, like the other output streams, you can use the ordinary formatting tools, such as the&lt;&lt; operator andendl, to send bytes to theostringstream. Thestr( ) function returns a newstring object every time you call it so the underlyingstringbuf object owned by the string stream is left undisturbed.
   In the previous chapter, we presented a program,HTMLStripper.cpp, that removed all HTML tags and special codes from a text file. As promised, here is a more elegant version using string streams.
   //: C04:HTMLStripper2.cpp
   //{L} ../C03/ReplaceAll
   // Filter to remove html tags and markers
   #include&lt;cstddef&gt;
   #include&lt;cstdlib&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;stdexcept&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   string& replaceAll(string& context, const string& from,
     const string& to);

   string& stripHTMLTags(string& s) throw(runtime_error) {
     size_t leftPos;
     while ((leftPos = s.find('&lt;')) != string::npos) {
       size_t rightPos = s.find('&gt;', leftPos+1);
       if (rightPos == string::npos) {
         ostringstream msg;
         msg&lt;&lt; "Incomplete HTML tag starting in position "
            &lt;&lt; leftPos;
         throw runtime_error(msg.str());
       }
       s.erase(leftPos, rightPos - leftPos + 1);
     }
     // Remove all special HTML characters
     replaceAll(s, "&lt;", "&lt;");
     replaceAll(s, "&gt;", "&gt;");
     replaceAll(s, "&amp;", "&");
     replaceAll(s, "&nbsp;", " ");
     // Etc...
     return s;
   }

   int main(int argc, char* argv[]) {
     requireArgs(argc, 1,
       "usage: HTMLStripper2 InputFile");
     ifstream in(argv[1]);
     assure(in, argv[1]);
     // Read entire file into string; then strip
     ostringstream ss;
     ss&lt;&lt; in.rdbuf();
     try {
       string s = ss.str();
       cout&lt;&lt; stripHTMLTags(s)&lt;&lt; endl;
       return EXIT_SUCCESS;
     }
     catch (runtime_error& x) {
       cout&lt;&lt; x.what()&lt;&lt; endl;
       return EXIT_FAILURE;
     }
   } ///:~

   In this program we read the entire file into a string by inserting ardbuf( ) call to the file stream into anostringstream. Now it’s an easy matter to search for HTML delimiter pairs and erase them without having to worry about crossing line boundaries like we had to with the previous version in Chapter 3.
   The following example shows how to use a bidirectional (that is, read/write) string stream.
   //: C04:StringSeeking.cpp
   // Reads and writes a string stream
   //{-bor}
   #include&lt;cassert&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string text = "We will sell no wine";
     stringstream ss(text);
     ss.seekp(0, ios::end);
     ss&lt;&lt; " before its time.";
     assert(ss.str() ==
       "We will sell no wine before its time.");
     // Change "sell" to "ship"
     ss.seekg(9, ios::beg);
     string word;
     ss&gt;&gt; word;
     assert(word == "ell");
     ss.seekp(9, ios::beg);
     ss&lt;&lt; "hip";
     // Change "wine" to "code"
     ss.seekg(16, ios::beg);
     ss&gt;&gt; word;
     assert(word == "wine");
     ss.seekp(16, ios::beg);
     ss&lt;&lt; "code";
     assert(ss.str() ==
       "We will ship no code before its time.");
     ss.str("A horse of a different color.");
     assert(ss.str() == "A horse of a different color.");
   } ///:~

   As always, to move the put pointer, you callseekp( ), and to reposition the get pointer, you callseekg( ). Even though we didn’t show it with this example, string streams are a little more forgiving than file streams in that you can switch from reading to writing or vice-versa at any time. You don’t need to reposition the get or put pointers or flush the stream. This program also illustrates the overload ofstr( ) that replaces the stream’s underlyingstringbuf with a new string.
   Output stream formatting
   The goal of the iostreams design is to allow you to easily move and/or format characters. It certainly wouldn’t be useful if you couldn’t do most of the formatting provided by C’sprintf( ) family of functions. In this section, you’ll learn all the output formatting functions that are available for iostreams, so you can format your bytes the way you want them.
   The formatting functions in iostreams can be somewhat confusing at first because there’s often more than one way to control the formatting: through both member functions and manipulators. To further confuse things, a generic member function sets state flags to control formatting, such as left or right justification, to use uppercase letters for hex notation, to always use a decimal point for floating-point values, and so on. On the other hand, separate member functions set and read values for the fill character, the field width, and the precision.
   In an attempt to clarify all this, we’ll first examine the internal formatting data of an iostream , along with the member functions that can modify that data. (Everything can be controlled through the member functions, if desired.) We’ll cover the manipulators separately.
   Format flags
   The classios contains data members to store all the formatting information pertaining to a stream. Some of this data has a range of values and is stored in variables: the floating-point precision, the output field width, and the character used to pad the output (normally a space). The rest of the formatting is determined by flags, which are usually combined to save space and are referred to collectively as theformat flags. You can find out the value of the format flags with theios::flags( ) member function, which takes no arguments and returns an object of typefmtflags (usually a synonym forlong) that contains the current format flags. All the rest of the functions make changes to the format flags and return the previous value of the format flags.
   fmtflags ios::flags(fmtflags newflags);
   fmtflags ios::setf(fmtflags ored_flag);
   fmtflags ios::unsetf(fmtflags clear_flag);
   fmtflags ios::setf(fmtflags bits, fmtflags field);

   The first function forcesall the flags to change, which you do sometimes. More often, you change one flag at a time using the remaining three functions.
   The use ofsetf( ) can seem somewhat confusing. To know which overloaded version to use, you must know what type of flag you’re changing. There are two types of flags: those that are simply on or off, and those that work in a group with other flags. The on/off flags are the simplest to understand because you turn them on withsetf(fmtflags) and off withunsetf(fmtflags). These flags are shown in the following table.on/off flagEffectios::skipwsSkip white space. (For input; this is the default.)ios::showbaseIndicate the numeric base (as set, for example, bydec,oct, orhex) when printing an integral value. Input streams also recognize the base prefix whenshowbase is on.ios::showpointShow decimal point and trailing zeros for floating-point values.ios::uppercaseDisplay uppercase A-F for hexadecimal values and E for scientific values.ios::showposShow plus sign (+) for positive values.ios::unitbuf"Unit buffering." The stream is flushed after each insertion.

   For example, to show the plus sign forcout, you saycout.setf(ios::showpos). To stop showing the plus sign, you saycout.unsetf(ios::showpos).
   Theunitbuf flag controlsunit buffering, which means that each insertion is flushed to its output stream immediately. This is handy for error tracing, so that in case of a program crash, your data is still written to the log file. The following program illustrates unit buffering.
   //: C04:Unitbuf.cpp
   #include&lt;cstdlib&gt;  // For abort()
   #include&lt;fstream&gt;
   using namespace std;

   int main() {
     ofstream out("log.txt");
     out.setf(ios::unitbuf);
     out&lt;&lt; "one\n";
     out&lt;&lt; "two\n";
     abort();
   } ///:~

   It is necessary to turn on unit buffering before any insertions are made to the stream. When we commented out the call tosetf( ), one particular compiler had written only the letter‘o’ to the filelog.txt. With unit buffering, no data was lost.
   The standard error output streamcerr has unit buffering turned on by default. There is a cost for unit buffering, of course, so if an output stream is heavily used, don’t enable unit buffering unless efficiency is not a consideration.
   Format fields
   The second type of formatting flags work in a group. Only one of these flags can be, like the buttons on old car radios—you push one in, the rest pop out. Unfortunately this doesn’t happen automatically, and you have to pay attention to what flags you’re setting so that you don’t accidentally call the wrongsetf( ) function. For example, there’s a flag for each of the number bases: hexadecimal, decimal, and octal. Collectively, these flags are referred to as theios::basefield. If theios::dec flag is set and you callsetf(ios::hex), you’ll set theios::hex flag, but youwon’t clear theios::dec bit, resulting in undefined behavior. The proper thing to do is call the second form ofsetf( ) like this:setf(ios::hex, ios::basefield). This function first clears all the bits in theios::basefield andthen setsios::hex. Thus, this form ofsetf( ) ensures that the other flags in the group "pop out" whenever you set one. Of course, theios::hex manipulator does all this for you, automatically, so you don’t have to concern yourself with the internal details of the implementation of this class or to evencare that it’s a set of binary flags. Later you’ll see that there are manipulators to provide equivalent functionality in all the places you would usesetf( ).
   Here are the flag groups and their effects:ios::basefieldeffectios::decFormat integral values in base 10 (decimal) (the default radix—no prefix is visible).ios::hexFormat integral values in base 16 (hexadecimal).ios::octFormat integral values in base 8 (octal).
ios::floatfieldeffectios::scientificDisplay floating-point numbers in scientific format. Precision field indicates number of digits after the decimal point.ios::fixedDisplay floating-point numbers in fixed format. Precision field indicates number of digits after the decimal point."automatic" (Neither bit is set.)Precision field indicates the total number of significant digits.
ios::adjustfieldEffectios::leftLeft-align values; pad on the right with the fill character.ios::rightRight-align values. Pad on the left with the fill character. This is the default alignment.ios::internalAdd fill characters after any leading sign or base indicator, but before the value. (In other words, the sign, if printed, is left-justified while the number is right-justified).
   Width, fill, and precision
   The internal variables that control the width of the output field, the fill character used to pad an output field, and the precision for printing floating-point numbers are read and written by member functions of the same name.Functioneffectint ios::width( )Returns the current width. (Default is 0.) Used for both insertion and extraction.int ios::width(int n)Sets the width, returns the previous width.int ios::fill( )Returns the current fill character. (Default is space.)int ios::fill(int n)Sets the fill character, returns the previous fill character.int ios::precision( )Returns current floating-point precision. (Default is 6.)int ios::precision(int n)Sets floating-point precision, returns previous precision. Seeios::floatfield table for the meaning of "precision."
   Thefill andprecision values are fairly straightforward, butwidth requires some explanation. When the width is zero, inserting a value produces the minimum number of characters necessary to represent that value. A positive width means that inserting a value will produce at least as many characters as the width; if the value has fewer than width characters, the fill character is used to pad the field. However, the value will never be truncated, so if you try to print 123 with a width of two, you’ll still get 123. The field width specifies aminimum number of characters; there’s no way to specify a maximum number.
   The width is also distinctly different because it’s reset to zero by each inserter or extractor that could be influenced by its value. It’s really not a state variable, but rather an implicit argument to the inserters and extractors. If you want a constant width, callwidth( ) after each insertion or extraction.
   An exhaustive example
   To make sure you know how to call all the functions previously discussed, here’s an example that calls them all:.
   //: C04:Format.cpp
   // Formatting Functions
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include "../require.h"
   using namespace std;
   #define D(A) T&lt;&lt; #A&lt;&lt; endl; A

   int main() {
     ofstream T("format.out");
     assure(T);
     D(int i = 47;)
     D(float f = 2300114.414159;)
     const char* s = "Is there any more?";

     D(T.setf(ios::unitbuf);)
     D(T.setf(ios::showbase);)
     D(T.setf(ios::uppercase | ios::showpos);)
     D(T&lt;&lt; i&lt;&lt; endl;) // Default is dec
     D(T.setf(ios::hex, ios::basefield);)
     D(T&lt;&lt; i&lt;&lt; endl;)
     D(T.setf(ios::oct, ios::basefield);)
     D(T&lt;&lt; i&lt;&lt; endl;)
     D(T.unsetf(ios::showbase);)
     D(T.setf(ios::dec, ios::basefield);)
     D(T.setf(ios::left, ios::adjustfield);)
     D(T.fill('0');)
     D(T&lt;&lt; "fill char: "&lt;&lt; T.fill()&lt;&lt; endl;)
     D(T.width(10);)
     T&lt;&lt; i&lt;&lt; endl;
     D(T.setf(ios::right, ios::adjustfield);)
     D(T.width(10);)
     T&lt;&lt; i&lt;&lt; endl;
     D(T.setf(ios::internal, ios::adjustfield);)
     D(T.width(10);)
     T&lt;&lt; i&lt;&lt; endl;
     D(T&lt;&lt; i&lt;&lt; endl;) // Without width(10)

     D(T.unsetf(ios::showpos);)
     D(T.setf(ios::showpoint);)
     D(T&lt;&lt; "prec = "&lt;&lt; T.precision()&lt;&lt; endl;)
     D(T.setf(ios::scientific, ios::floatfield);)
     D(T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;)
     D(T.unsetf(ios::uppercase);)
     D(T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;)
     D(T.setf(ios::fixed, ios::floatfield);)
     D(T&lt;&lt; f&lt;&lt; endl;)
     D(T.precision(20);)
     D(T&lt;&lt; "prec = "&lt;&lt; T.precision()&lt;&lt; endl;)
     D(T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;)
     D(T.setf(ios::scientific, ios::floatfield);)
     D(T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;)
     D(T.setf(ios::fixed, ios::floatfield);)
     D(T&lt;&lt; f&lt;&lt; endl;)

     D(T.width(10);)
     T&lt;&lt; s&lt;&lt; endl;
     D(T.width(40);)
     T&lt;&lt; s&lt;&lt; endl;
     D(T.setf(ios::left, ios::adjustfield);)
     D(T.width(40);)
     T&lt;&lt; s&lt;&lt; endl;
   } ///:~

   This example uses a trick to create a trace file so that you can monitor what’s happening. The macroD(a) uses the preprocessor "stringizing" to turna into a string to display. Then it reiteratesa so the statement is executed. The macro sends all the information to a file calledT, which is the trace file. The output is:.
   int i = 47;
   float f = 2300114.414159;
   T.setf(ios::unitbuf);
   T.setf(ios::showbase);
   T.setf(ios::uppercase | ios::showpos);
   T&lt;&lt; i&lt;&lt; endl;
   +47
   T.setf(ios::hex, ios::basefield);
   T&lt;&lt; i&lt;&lt; endl;
   0X2F
   T.setf(ios::oct, ios::basefield);
   T&lt;&lt; i&lt;&lt; endl;
   057
   T.unsetf(ios::showbase);
   T.setf(ios::dec, ios::basefield);
   T.setf(ios::left, ios::adjustfield);
   T.fill('0');
   T&lt;&lt; "fill char: "&lt;&lt; T.fill()&lt;&lt; endl;
   fill char: 0
   T.width(10);
   +470000000
   T.setf(ios::right, ios::adjustfield);
   T.width(10);
   0000000+47
   T.setf(ios::internal, ios::adjustfield);
   T.width(10);
   +000000047
   T&lt;&lt; i&lt;&lt; endl;
   +47
   T.unsetf(ios::showpos);
   T.setf(ios::showpoint);
   T&lt;&lt; "prec = "&lt;&lt; T.precision()&lt;&lt; endl;
   prec = 6
   T.setf(ios::scientific, ios::floatfield);
   T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;

   2.300114E+06
   T.unsetf(ios::uppercase);
   T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;

   2.300114e+06
   T.setf(ios::fixed, ios::floatfield);
   T&lt;&lt; f&lt;&lt; endl;
   2300114.500000
   T.precision(20);
   T&lt;&lt; "prec = "&lt;&lt; T.precision()&lt;&lt; endl;
   prec = 20
   T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;

   2300114.50000000000000000000
   T.setf(ios::scientific, ios::floatfield);
   T&lt;&lt; endl&lt;&lt; f&lt;&lt; endl;

   2.30011450000000000000e+06
   T.setf(ios::fixed, ios::floatfield);
   T&lt;&lt; f&lt;&lt; endl;
   2300114.50000000000000000000
   T.width(10);
   Is there any more?
   T.width(40);
   0000000000000000000000Is there any more?
   T.setf(ios::left, ios::adjustfield);
   T.width(40);
   Is there any more?0000000000000000000000

   Studying this output should clarify your understanding of the iostream formatting member functions.
   Manipulators
   As you can see from the previous program, calling the member functions for stream formatting operations can get a bit tedious. To make things easier to read and write, a set ofmanipulators is supplied to duplicate the actions provided by the member functions. Manipulators are a convenience because you can insert them for their effect within a containing expression; you don’t have to create a separate function-call statement.
   Manipulators change the state of the stream instead of (or in addition to) processing data. When you insertendl in an output expression, for example, it not only inserts a newline character, but it alsoflushes the stream (that is, puts out all pending characters that have been stored in the internal stream buffer but not yet output). You can also just flush a stream like this:.
   cout&lt;&lt; flush;

   which causes a call to theflush( ) member function, as in
   cout.flush();

   as a side effect (nothing is inserted into the stream). Additional basic manipulators will change the number base tooct (octal),dec (decimal) orhex (hexadecimal):.
    cout&lt;&lt; hex&lt;&lt; "0x"&lt;&lt; i&lt;&lt; endl;

   In this case, numeric output will continue in hexadecimal mode until you change it by inserting eitherdec oroct in the output stream.
   There’s also a manipulator for extraction that "eats" white space:.
   cin&gt;&gt; ws;

   Manipulators with no arguments are provided in&lt;iostream&gt;. These includedec,oct, andhex , which perform the same action as, respectively,setf(ios::dec, ios::basefield),setf(ios::oct, ios::basefield), andsetf(ios::hex, ios::basefield), albeit more succinctly. The&lt;iostream&gt; header also includesws,endl, andflush and the additional set shown here:.ManipulatorEffectshowbase noshowbaseIndicate the numeric base (dec,oct, orhex) when printing an integral value. The format used can be read by the C++ compiler.showpos noshowposShow plus sign (+) for positive values.uppercase nouppercaseDisplay uppercase A-F for hexadecimal values, and display E for scientific values.showpoint noshowpointShow decimal point and trailing zeros for floating-point values.skipws noskipwsSkip white space on input.left right internalLeft-align, pad on right. Right-align, pad on left. Fill between leading sign or base indicator and value.scientific fixedIndicates the display preference for floating-point output (scientific notation vs. fixed-point decimal).
   Manipulators with arguments
   There are six standard manipulators, such assetw( ), that take arguments. These are defined in the header file&lt;iomanip&gt;, and are summarized in the following table.Manipulatoreffectsetiosflags (fmtflags n)Equivalent to a call tosetf(n). The setting remains in effect until the next change, such asios::setf( ).resetiosflags(fmtflags n)Clears only the format flags specified byn. The setting remains in effect until the next change, such asios::unsetf( ).setbase(base n)Changes base ton, wheren is 10, 8, or 16. (Anything else results in 0.) Ifn is zero, output is base 10, but input uses the C conventions: 10 is 10, 010 is 8, and 0xf is 15. You might as well usedec,oct, andhex for output.setfill(char n)Changes the fill character ton, such asios::fill( ).setprecision(int n)Changes the precision ton, such asios::precision( ).setw(int n)Changes the field width ton, such asios::width( ).
   If you’re doing a lot of formatting, you can see how using manipulators instead of calling stream member functions can clean up your code. As an example, here’s the program from the previous section rewritten to use the manipulators. (TheD( ) macro is removed to make it easier to read.).
   //: C04:Manips.cpp
   // Format.cpp using manipulators
   #include&lt;fstream&gt;
   #include&lt;iomanip&gt;
   #include&lt;iostream&gt;
   using namespace std;

   int main() {
     ofstream trc("trace.out");
     int i = 47;
     float f = 2300114.414159;
     char* s = "Is there any more?";

     trc&lt;&lt; setiosflags(ios::unitbuf
              | ios::showbase | ios::uppercase
              | ios::showpos);
     trc&lt;&lt; i&lt;&lt; endl;
     trc&lt;&lt; hex&lt;&lt; i&lt;&lt; endl
        &lt;&lt; oct&lt;&lt; i&lt;&lt; endl;
     trc.setf(ios::left, ios::adjustfield);
     trc&lt;&lt; resetiosflags(ios::showbase)
        &lt;&lt; dec&lt;&lt; setfill('0');
     trc&lt;&lt; "fill char: "&lt;&lt; trc.fill()&lt;&lt; endl;
     trc&lt;&lt; setw(10)&lt;&lt; i&lt;&lt; endl;
     trc.setf(ios::right, ios::adjustfield);
     trc&lt;&lt; setw(10)&lt;&lt; i&lt;&lt; endl;
     trc.setf(ios::internal, ios::adjustfield);
     trc&lt;&lt; setw(10)&lt;&lt; i&lt;&lt; endl;
     trc&lt;&lt; i&lt;&lt; endl; // Without setw(10)

     trc&lt;&lt; resetiosflags(ios::showpos)
        &lt;&lt; setiosflags(ios::showpoint)
        &lt;&lt; "prec = "&lt;&lt; trc.precision()&lt;&lt; endl;
     trc.setf(ios::scientific, ios::floatfield);
     trc&lt;&lt; f&lt;&lt; resetiosflags(ios::uppercase)&lt;&lt; endl;
     trc.setf(ios::fixed, ios::floatfield);
     trc&lt;&lt; f&lt;&lt; endl;
     trc&lt;&lt; f&lt;&lt; endl;
     trc&lt;&lt; setprecision(20);
     trc&lt;&lt; "prec = "&lt;&lt; trc.precision()&lt;&lt; endl;
     trc&lt;&lt; f&lt;&lt; endl;
     trc.setf(ios::scientific, ios::floatfield);
     trc&lt;&lt; f&lt;&lt; endl;
     trc.setf(ios::fixed, ios::floatfield);
     trc&lt;&lt; f&lt;&lt; endl;
     trc&lt;&lt; f&lt;&lt; endl;

     trc&lt;&lt; setw(10)&lt;&lt; s&lt;&lt; endl;
     trc&lt;&lt; setw(40)&lt;&lt; s&lt;&lt; endl;
     trc.setf(ios::left, ios::adjustfield);
     trc&lt;&lt; setw(40)&lt;&lt; s&lt;&lt; endl;
   } ///:~

   You can see that a lot of the multiple statements have been condensed into a single chained insertion. Notice the call tosetiosflags( ) in which the bitwise-OR of the flags is passed. This could also have been done withsetf( ) andunsetf( ) as in the previous example.
   When usingsetw( ) with an output stream, the output expression is formatted into a temporary string that is padded with the current fill character if needed, as determined by comparing the length of the formatted result to the argument ofsetw( ). In other words,setw( ) affects theresult string of a formatted output operation. Likewise, usingsetw( ) with input streams only is meaningful when readingstrings, as the following example makes clear.
   //: C04:InputWidth.cpp
   // Shows limitations of setw with input
   #include&lt;cassert&gt;
   #include&lt;cmath&gt;
   #include&lt;iomanip&gt;
   #include&lt;limits&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     istringstream is("one 2.34 five");
     string temp;
     is&gt;&gt; setw(2)&gt;&gt; temp;
     assert(temp == "on");
     is&gt;&gt; setw(2)&gt;&gt; temp;
     assert(temp == "e");
     double x;
     is&gt;&gt; setw(2)&gt;&gt; x;
     double relerr = fabs(x - 2.34) / x;
     assert(relerr&lt;= numeric_limits&lt;double&gt;::epsilon());
   } ///:~

   If you attempt to read a string,setw( ) will control the number of characters extracted quite nicely… up to a point. The first extraction gets two characters, but the second only gets one, even though we asked for two. That is becauseoperator&gt;&gt;( ) uses white space as a delimiter (unless you turn off theskipws flag). When trying to read a number, however, such asx, you cannot usesetw( )to limit the characters read. With input streams, use onlysetw( ) for extracting strings.
   Creating manipulators
   Sometimes you’d like to create your own manipulators, and it turns out to be remarkably simple. A zero-argument manipulator such asendlis simply a function that takes as its argument anostream reference and returns anostream reference. The declaration forendl is.
   ostream& endl(ostream&);

   Now, when you say:.
   cout&lt;&lt; "howdy"&lt;&lt; endl;

   theendl produces theaddress of that function. So the compiler asks, "Is there a function I can call that takes the address of a function as its argument?" Predefined functions in&lt;iostream&gt;do this; they’re calledapplicators (because theyapply a function to a stream). The applicator calls its function argument, passing it theostream object as its argument. You don’t need to know how applicators work to create your own manipulator; you only need to know that they exist. Nonetheless, they’re simple. Here’s the (simplified) code for anostream applicator:
   ostream& ostream::operator&lt;&lt;(ostream& (*pf)(ostream&)) {
     return pf(*this);
   }

   The actual definition is a little more complicated since it involves templates, but this code illustrates the technique. When a function such as*pf (that takes a stream parameter and returns a stream reference) is inserted into a stream, this applicator function is called, which in turn executes the function to whichpf points. Applicators forios_base,basic_ios,basic_ostream, andbasic_istream are predefined in the standard C++ library.
   To illustrate the process, here’s a trivial example that creates a manipulator callednl that is equivalent to just inserting a newline into a stream (i.e., no flushing of the stream occurs, as withendl):.
   //: C04:nl.cpp
   // Creating a manipulator
   #include&lt;iostream&gt;
   using namespace std;

   ostream& nl(ostream& os) {
     return os&lt;&lt; '\n';
   }

   int main() {
     cout&lt;&lt; "newlines"&lt;&lt; nl&lt;&lt; "between"&lt;&lt; nl
         &lt;&lt; "each"&lt;&lt; nl&lt;&lt; "word"&lt;&lt; nl;
   } ///:~

   When you insertnl into an output stream, such ascout, the following sequence of calls ensues:
   cout.operator&lt;&lt;(nl)? nl(cout)

   The expression
   os&lt;&lt; '\n';

   insidenl( ) callsostream::operator(char), which of course returns the stream, which is what is ultimately returned fromnl( ).[45] 
   Effectors
   As you’ve seen, zero-argument manipulators are easy to create. But what if you want to create a manipulator that takes arguments? If you inspect the&lt;iomanip&gt; header, you’ll see a type calledsmanip, which is what the manipulators with arguments return. You might be tempted to somehow use that type to define your own manipulators, but don’t give in to the temptation. Thesmanip type is implementation-dependent, so using it would not be portable. Fortunately, you can define such manipulators in a straightforward way without any special machinery, based on a technique introduced by Jerry Schwarz, called aneffector.[46] An effector is a simple class whose constructor formats a string representing the desired operation, along with an overloadedoperator&lt;&lt; to insert that string into a stream. Here’s an example with two effectors. The first outputs a truncated character string, and the second prints a number in binary.
   //: C04:Effector.cpp
   // Jerry Schwarz's "effectors"
   #include&lt;cassert&gt;
   #include&lt;limits&gt;  // For max()
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   // Put out a prefix of a string:
   class Fixw {
     string str;
   public:
     Fixw(const string& s, int width)
       : str(s, 0, width) {}
     friend ostream&
     operator&lt;&lt;(ostream& os, const Fixw& fw) {
       return os&lt;&lt; fw.str;
     }
   };

   // Print a number in binary:
   typedef unsigned long ulong;
   class Bin {
     ulong n;
   public:
     Bin(ulong nn) { n = nn; }
     friend ostream& operator&lt;&lt;(ostream& os, const Bin& b) {
       const ulong ULMAX = numeric_limits&lt;ulong&gt;::max();
       ulong bit = ~(ULMAX&gt;&gt; 1); // Top bit set
       while(bit) {
         os&lt;&lt; (b.n& bit ? '1' : '0');
         bit&gt;&gt;= 1;
       }
       return os;
     }
   };

   int main() {
     string words =
       "Things that make us happy, make us wise";
     for(int i = words.size(); --i&gt;= 0;) {
       ostringstream s;
       s&lt;&lt; Fixw(words, i);
       assert(s.str() == words.substr(0, i));
     }
     ostringstream xs, ys;
     xs&lt;&lt; Bin(0xCAFEBABEUL);
     assert(xs.str() ==
       "1100""1010""1111""1110""1011""1010""1011""1110");
     ys&lt;&lt; Bin(0x76543210UL);
     assert(ys.str() ==
       "0111""0110""0101""0100""0011""0010""0001""0000");
   } ///:~

   The constructor forFixw creates a shortened copy of itschar* argument, and the destructor releases the memory created for this copy. The overloadedoperator&lt;&lt; takes the contents of its second argument, theFixw object, inserts it into the first argument, theostream, and then returns theostream so that it can be used in a chained expression. When you useFixw in an expression like this:.
   cout&lt;&lt; Fixw(string, i)&lt;&lt; endl;

   atemporary object is created by the call to theFixw constructor, and that temporary object is passed tooperator&lt;&lt;. The effect is that of a manipulator with arguments. The temporaryFixw object persists until the end of the statement.
   TheBin effector relies on the fact that shifting an unsigned number to the right shifts zeros into the high bits. We usenumeric_limits&lt;unsigned long&gt;::max( ) (the largestunsigned long value, from the standard header&lt;limits&gt; ) to produce a value with the high bit set, and this value is moved across the number in question (by shifting it to the right), masking each bit in turn. We’ve juxtaposed string literals in the code for readability; the separate strings are of course concatenated into one by the compiler.
   Historically, the problem with this technique was that once you created a class calledFixw forchar* orBinforunsigned long, no one else could create a differentFixw orBinclass for their type. However, with namespaces, this problem is eliminated.
   Iostream examples
   In this section you’ll see some examples of what you can do with all the information you’ve learned in this chapter. Although many tools exist to manipulate bytes (stream editors such assed andawk from UNIX are perhaps the most well known, but a text editor also fits this category), they generally have some limitations. Bothsed andawk can be slow and can only handle lines in a forward sequence, and text editors usually require human interaction, or at least learning a proprietary macro language. The programs you write with iostreams have none of these limitations: they’re fast, portable, and flexible.
   Maintaining class library source code
   Generally, when you create a class, you think in library terms: you make a header fileName.hfor the class declaration, and you create a file in which the member functions are implemented, calledName.cpp. These files have certain requirements: a particular coding standard (the program shown here uses the coding format for this book), and in the header file the declarations are generally surrounded by some preprocessor statements to prevent multiple declarations of classes. (Multiple declarations confuse the compiler—it doesn’t know which one you want to use. They could be different, so it throws up its hands and gives an error message.).
   This example allows you to create a new header/implementation pair of files or to modify an existing pair. If the files already exist, it checks and potentially modifies the files, but if they don’t exist, it creates them using the proper format.
   //: C04:Cppcheck.cpp
   // Configures .h& .cpp files to conform to style
   // standard. Tests existing files for conformance.
   #include&lt;fstream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   bool startsWith(const string& base, const string& key) {
     return base.compare(0, key.size(), key) == 0;
   }

   void cppCheck(string fileName) {
     enum bufs { BASE, HEADER, IMPLEMENT,
       HLINE1, GUARD1, GUARD2, GUARD3,
       CPPLINE1, INCLUDE, BUFNUM };
     string part[BUFNUM];
     part[BASE] = fileName;
     // Find any '.' in the string:
     size_t loc = part[BASE].find('.');
     if(loc != string::npos)
       part[BASE].erase(loc); // Strip extension
     // Force to upper case:
     for(size_t i = 0; i&lt; part[BASE].size(); i++)
       part[BASE][i] = toupper(part[BASE][i]);
     // Create file names and internal lines:
     part[HEADER] = part[BASE] + ".h";
     part[IMPLEMENT] = part[BASE] + ".cpp";
     part[HLINE1] = "//" ": " + part[HEADER];
     part[GUARD1] = "#ifndef " + part[BASE] + "_H";
     part[GUARD2] = "#define " + part[BASE] + "_H";
     part[GUARD3] = "#endif // " + part[BASE] +"_H";
     part[CPPLINE1] = string("//") + ": "
       + part[IMPLEMENT];
     part[INCLUDE] = "#include \"" + part[HEADER] + "\"";
     // First, try to open existing files:
     ifstream existh(part[HEADER].c_str()),
              existcpp(part[IMPLEMENT].c_str());
     if(!existh) { // Doesn't exist; create it
       ofstream newheader(part[HEADER].c_str());
       assure(newheader, part[HEADER].c_str());
       newheader&lt;&lt; part[HLINE1]&lt;&lt; endl
        &lt;&lt; part[GUARD1]&lt;&lt; endl
        &lt;&lt; part[GUARD2]&lt;&lt; endl&lt;&lt; endl
        &lt;&lt; part[GUARD3]&lt;&lt; endl;
     } else { // Already exists; verify it
       stringstream hfile; // Write& read
       ostringstream newheader; // Write
       hfile&lt;&lt; existh.rdbuf();
       // Check that first three lines conform:
       bool changed = false;
       string s;
       hfile.seekg(0);
       getline(hfile, s);
       bool lineUsed = false;
       // The call to good() is for Microsoft (later too)
       for (int line = HLINE1; hfile.good()&& line&lt;= GUARD2;
            ++line) {
         if(startsWith(s, part[line])) {
           newheader&lt;&lt; s&lt;&lt; endl;
           lineUsed = true;
           if (getline(hfile, s))
             lineUsed = false;
         } else {
           newheader&lt;&lt; part[line]&lt;&lt; endl;
           changed = true;
           lineUsed = false;
         }
       }
       // Copy rest of file
       if (!lineUsed)
         newheader&lt;&lt; s&lt;&lt; endl;
       newheader&lt;&lt; hfile.rdbuf();
       // Check for GUARD3
       string head = hfile.str();
       if(head.find(part[GUARD3]) == string::npos) {
         newheader&lt;&lt; part[GUARD3]&lt;&lt; endl;
         changed = true;
       }
       // If there were changes, overwrite file:
       if(changed) {
         existh.close();
         ofstream newH(part[HEADER].c_str());
         assure(newH, part[HEADER].c_str());
         newH&lt;&lt; "//@//\n"  // Change marker
          &lt;&lt; newheader.str();
       }
     }
     if(!existcpp) { // Create cpp file
       ofstream newcpp(part[IMPLEMENT].c_str());
       assure(newcpp, part[IMPLEMENT].c_str());
       newcpp&lt;&lt; part[CPPLINE1]&lt;&lt; endl
        &lt;&lt; part[INCLUDE]&lt;&lt; endl;
     } else { // Already exists; verify it
       stringstream cppfile;
       ostringstream newcpp;
       cppfile&lt;&lt; existcpp.rdbuf();
       // Check that first two lines conform:
       bool changed = false;
       string s;
       cppfile.seekg(0);
       getline(cppfile, s);
       bool lineUsed = false;
       for (int line = CPPLINE1;
            cppfile.good()&& line&lt;= INCLUDE;
            ++line) {
         if(startsWith(s, part[line])) {
           newcpp&lt;&lt; s&lt;&lt; endl;
           lineUsed = true;
           if (getline(cppfile, s))
             lineUsed = false;
         } else {
           newcpp&lt;&lt; part[line]&lt;&lt; endl;
           changed = true;
           lineUsed = false;
         }
       }
       // Copy rest of file
       if (!lineUsed)
         newcpp&lt;&lt; s&lt;&lt; endl;
       newcpp&lt;&lt; cppfile.rdbuf();
       // If there were changes, overwrite file:
       if(changed){
         existcpp.close();
         ofstream newCPP(part[IMPLEMENT].c_str());
         assure(newCPP, part[IMPLEMENT].c_str());
         newCPP&lt;&lt; "//@//\n"  // Change marker
          &lt;&lt; newcpp.str();
       }
     }
   }

   int main(int argc, char* argv[]) {
     if(argc&gt; 1)
       cppCheck(argv[1]);
     else
       cppCheck("cppCheckTest.h");
   } ///:~

   First notice the useful functionstartsWith( ), which does just what its name says—it returnstrue if the first string argument starts with the second argument. This is used when looking for the expected comments and include-related statements. Having the array of strings,part, allows for easy looping through the series of expected statements in source code. If the source file doesn’t exist, we merely write the statements to a new file of the given name. If the file does exist, we search a line at a time, verifying that the expected lines occur. If they are not present, they are inserted. Special care has to be taken to make sure we don’t drop existing lines (see where weuse the Boolean variablelineUsed). Notice that we use astringstream for an existing file, so we can first write the contents of the file to it and then read from it and search it.
   The names in the enumeration areBASE, the capitalized base file name without extension;HEADER, the header file name;IMPLEMENT, the implementation file (cpp) name;HLINE1, the skeleton first line of the header file;GUARD1,GUARD2, andGUARD3, the "guard" lines in the header file (to prevent multiple inclusion);CPPLINE1, the skeleton first line of thecpp file; andINCLUDE, the line in thecpp file that includes the header file.
   If you run this program without any arguments, the following two files are created:
   // CPPCHECKTEST.h
   #ifndef CPPCHECKTEST_H
   #define CPPCHECKTEST_H

   #endif // CPPCHECKTEST_H

   // CPPCHECKTEST.cpp
   #include "CPPCHECKTEST.h"

   (We removed the colon after the double-slash in the first comment lines so as not to confuse the book’s code extractor. It will appear in the actual output produced bycppCheck.)
   You can experiment by removing selected lines from these files and re-running the program. Each time you will see that the correct lines are added back in. When a file is modified, the string "//@//" is placed as the first line of the file to bring the change to your attention. You will need to remove this line before you process the file again (otherwisecppcheck will assume the initial comment line is missing).
   Detecting compiler errors
   All the code in this book is designed to compile as shown without errors. Any line of code that should generate a compile-time error is commented out with the special comment sequence "//!". The following program will remove these special comments and append a numbered comment to the line. When you run your compiler, it should generate error messages, and you will see all the numbers appear when you compile all the files. This program also appends the modified line to a special file so that you can easily locate any lines that don’t generate errors.
   //: C04:Showerr.cpp
   // Un-comment error generators
   #include&lt;cstddef&gt;
   #include&lt;cstdlib&gt;
   #include&lt;cstdio&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   const string usage =
     "usage: showerr filename chapnum\n"
     "where filename is a C++ source file\n"
     "and chapnum is the chapter name it's in.\n"
     "Finds lines commented with //! and removes\n"
     "comment, appending //(#) where # is unique\n"
     "across all files, so you can determine\n"
     "if your compiler finds the error.\n"
     "showerr /r\n"
     "resets the unique counter.";

   class Showerr {
     const int CHAP;
     const string MARKER, FNAME;
     // File containing error number counter:
     const string ERRNUM;
     // File containing error lines:
     const string ERRFILE;
     stringstream edited; // Edited file
     int counter;
   public:
     Showerr(const string& f, const string& en,
       const string& ef, int c) : FNAME(f), MARKER("//!"),
       ERRNUM(en), ERRFILE(ef), CHAP(c) { counter = 0; }
     void replaceErrors() {
       ifstream infile(FNAME.c_str());
       assure(infile, FNAME.c_str());
       ifstream count(ERRNUM.c_str());
       if(count) count&gt;&gt; counter;
       int linecount = 1;
       string buf;
       ofstream errlines(ERRFILE.c_str(), ios::app);
       assure(errlines, ERRFILE.c_str());
       while(getline(infile, buf)) {
         // Find marker at start of line:
         size_t pos = buf.find(MARKER);
         if(pos != string::npos) {
           // Erase marker:
           buf.erase(pos, MARKER.size() + 1);
           // Append counter& error info:
           ostringstream out;
           out&lt;&lt; buf&lt;&lt; " // ("&lt;&lt; ++counter&lt;&lt; ") "
              &lt;&lt; "Chapter "&lt;&lt; CHAP
               &lt;&lt; " File: "&lt;&lt; FNAME
              &lt;&lt; " Line "&lt;&lt; linecount&lt;&lt; endl;
           edited&lt;&lt; out.str();
           errlines&lt;&lt; out.str(); // Append error file
         }
         else
           edited&lt;&lt; buf&lt;&lt; "\n"; // Just copy
         linecount++;
       }
     }
     void saveFiles() {
       ofstream outfile(FNAME.c_str()); // Overwrites
       assure(outfile, FNAME.c_str());
       outfile&lt;&lt; edited.rdbuf();
       ofstream count(ERRNUM.c_str()); // Overwrites
       assure(count, ERRNUM.c_str());
       count&lt;&lt; counter; // Save new counter
     }
   };

   int main(int argc, char* argv[]) {
     const string ERRCOUNT("../errnum.txt"),
       ERRFILE("../errlines.txt");
     requireMinArgs(argc, 1, usage.c_str());
     if(argv[1][0] == '/' || argv[1][0] == '-') {
       // Allow for other switches:
       switch(argv[1][1]) {
         case 'r': case 'R':
           cout&lt;&lt; "reset counter"&lt;&lt; endl;
           remove(ERRCOUNT.c_str()); // Delete files
           remove(ERRFILE.c_str());
           return 0;
         default:
           cerr&lt;&lt; usage&lt;&lt; endl;
           return 1;
       }
     }
     if (argc == 3) {
       Showerr s(argv[1], ERRCOUNT, ERRFILE, atoi(argv[2]));
       s.replaceErrors();
       s.saveFiles();
     }
   } ///:~

   You can replace the marker with one of your choice.
   Each file is read a line at a time, and each line is searched for the marker appearing at the head of the line; the line is modified and put into the error line list and into the string stream,edited. When the whole file is processed, it is closed (by reaching the end of a scope), it is reopened as an output file, andedited is poured into the file. Also notice the counter is saved in an external file. The next time this program is invoked, it continues to sequence the counter.
   A simple data logger
   This example shows an approach you might take to log data to disk and later retrieve it for processing. It is meant to produce a temperature-depth profile of the ocean at various points. To hold the data, a class is used:.
   //: C04:DataLogger.h
   // Datalogger record layout
   #ifndef DATALOG_H
   #define DATALOG_H
   #include&lt;ctime&gt;
   #include&lt;iosfwd&gt;
   #include&lt;string&gt;
   using std::ostream;

   struct Coord {
     int deg, min, sec;
     Coord(int d = 0, int m = 0, int s = 0)
       : deg(d), min(m), sec(s) {}
     std::string toString() const;
   };
   ostream& operator&lt;&lt;(ostream&, const Coord&);

   class DataPoint {
     std::time_t timestamp; // Time& day
     Coord latitude, longitude;
     double depth, temperature;
   public:
     DataPoint(std::time_t ts, const Coord& lat,
               const Coord& lon, double dep, double temp)
       : timestamp(ts), latitude(lat), longitude(lon),
         depth(dep), temperature(temp) {}
     DataPoint() : timestamp(0), depth(0), temperature(0) {}
     friend ostream& operator&lt;&lt;(ostream&, const DataPoint&);
   };
   #endif // DATALOG_H ///:~

   ADataPoint consists of a time stamp, which is stored as atime_t value as defined in&lt;ctime&gt;, longitude and latitude coordinates, and values for depth and temperature. We use inserters for easy formatting. Here’s the implementation file:.
   //: C04:DataLogger.cpp {O}
   // Datapoint implementations
   #include "DataLogger.h"
   #include&lt;iomanip&gt;
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   ostream& operator&lt;&lt;(ostream& os, const Coord& c) {
     return os&lt;&lt; c.deg&lt;&lt; '*'&lt;&lt; c.min&lt;&lt; '\''
              &lt;&lt; c.sec&lt;&lt; '"';
   }

   string Coord::toString() const {
     ostringstream os;
     os&lt;&lt; *this;
     return os.str();
   }

   ostream& operator&lt;&lt;(ostream& os, const DataPoint& d) {
     os.setf(ios::fixed, ios::floatfield);
     char fillc = os.fill('0'); // Pad on left with '0'
     tm* tdata = localtime(&d.timestamp);
     os&lt;&lt; setw(2)&lt;&lt; tdata-&gt;tm_mon + 1&lt;&lt; '\\'
       &lt;&lt; setw(2)&lt;&lt; tdata-&gt;tm_mday&lt;&lt; '\\'
       &lt;&lt; setw(2)&lt;&lt; tdata-&gt;tm_year+1900&lt;&lt; ' '
       &lt;&lt; setw(2)&lt;&lt; tdata-&gt;tm_hour&lt;&lt; ':'
       &lt;&lt; setw(2)&lt;&lt; tdata-&gt;tm_min&lt;&lt; ':'
       &lt;&lt; setw(2)&lt;&lt; tdata-&gt;tm_sec;
     os.fill(' '); // Pad on left with ' '
     streamsize prec = os.precision(4);
     os&lt;&lt; " Lat:"&lt;&lt; setw(9)&lt;&lt; d.latitude.toString()
       &lt;&lt; ", Long:"&lt;&lt; setw(9)&lt;&lt; d.longitude.toString()
       &lt;&lt; ", depth:"&lt;&lt; setw(9)&lt;&lt; d.depth
       &lt;&lt; ", temp:"&lt;&lt; setw(9)&lt;&lt; d.temperature;
     os.fill(fillc);
     os.precision(prec);
     return os;
   } ///:~

   TheCoord::toString( )function is necessary because theDataPoint inserter callssetw( ) before it prints the latitude and longitude. If we used the stream inserter forCoord instead, the width would only apply to the first insertion (that is, toCoord::deg), since width changes are always reset immediately. The call tosetf( ) causes the floating-point output to be fixed-precision, andprecision( ) sets the number of decimal places to four. Notice how we restore the fill character and precision to whatever they were before the inserter was called.
   To get the values from the time encoding stored inDataPoint::timestamp, we call the functionstd::localtime( ), which returns a static pointer to atm object. Thetm struct has the following layout:
   struct tm {
     int tm_sec; // 0-59 seconds
     int tm_min; // 0-59 minutes
     int tm_hour; // 0-23 hours
     int tm_mday; // Day of month
     int tm_mon; // 0-11 months
     int tm_year; // Years since 1900
     int tm_wday; // Sunday == 0, etc.
     int tm_yday; // 0-365 day of year
     int tm_isdst; // Daylight savings?
   };

   Generating test data
   Here’s a program that creates a file of test data in binary form (usingwrite( )) and a second file in ASCII form using theDataPoint inserter. You can also print it out to the screen, but it’s easier to inspect in file form.
   //: C04:Datagen.cpp
   // Test data generator
   //{L} DataLogger
   #include&lt;cstdlib&gt;
   #include&lt;cstring&gt;
   #include&lt;fstream&gt;
   #include "../require.h"
   #include "DataLogger.h"
   using namespace std;

   int main() {
     ofstream data("data.txt");
     assure(data, "data.txt");
     ofstream bindata("data.bin", ios::binary);
     assure(bindata, "data.bin");
     time_t timer;
     Coord lat(45,20,31);
     Coord lon(22,34,18);
     // Seed random number generator:
     srand(time(&timer));
     for(int i = 0; i&lt; 100; i++, timer += 55) {
       // Zero to 199 meters:
       double newdepth  = rand() % 200;
       double fraction = rand() % 100 + 1;
       newdepth += 1.0 / fraction;
       double newtemp = 150 + rand()%200; // Kelvin
       fraction = rand() % 100 + 1;
       newtemp += 1.0 / fraction;
       const DataPoint d(timer, Coord(45,20,31),
          Coord(22,34,18), newdepth,
          newtemp);
       data&lt;&lt; d&lt;&lt; endl;
       bindata.write(reinterpret_cast&lt;const char*&gt;(&d),
      sizeof(d));
     }
   } ///:~

   The filedata.txtis created in the ordinary way as an ASCII file, butdata.binhas the flagios::binary to tell the constructor to set it up as a binary file. To illustrate the formatting used for the text file, here is the first line ofdata.txt (the line wraps because it’s longer than this page will allow):.
   07\28\2003 12:54:40 Lat:45*20'31", Long:22*34'18", depth:  16.0164, temp: 242.0122

   The Standard C library functiontime( ) updates thetime_t value its argument points to with an encoding of the current time, which on most platforms is the number of seconds elapsed since 00:00:00 GMT, January 1 1970 (the dawning of the age of Aquarius?). The current time is also a convenient way to seed the random number generator with the Standard C library functionsrand( ), as is done here.
   After this, thetimer is incremented by 55 seconds to give an interesting interval between readings in this simulation.
   The latitude and longitude used are fixed values to indicate a set of readings at a single location. Both the depth and the temperature are generated with the Standard C libraryrand( ) function, which returns a pseudorandom number between zero and a platform-dependent constant,RAND_MAX, defined in&lt;cstdlib&gt; (usually the value of the platform’s largest unsigned integer). To put this in a desired range, use the remainder operator% and the upper end of the range. These numbers are integral; to add a fractional part, a second call torand( ) is made, and the value is inverted after adding one (to prevent divide-by-zero errors).
   In effect, thedata.binfile is being used as a container for the data in the program, even though the container exists on disk and not in RAM. To send the data out to the disk in binary form,write( ) is used. The first argument is the starting address of the source block—notice it must be cast to achar* because that’s whatwrite( ) expects for narrow streams. The second argument is the number of characters to write, which in this case is the size of theDataPoint object (again, because we’re usingnarrow streams). Because no pointers are contained inDataPoint, there is no problem in writing the object to disk. If the object is more sophisticated, you must implement a scheme forserialization, which writes the data referred to by pointers and defines new pointers when read back in later. (We don’t talk about serialization in this volume—most vendor class libraries have some sort of serialization structure built into them.).
   Verifying and viewing the data
   To check the validity of the data stored in binary format, you can read it into memory with theread( ) member function for input streams, and compare it to the text file created earlier byDatagen.cpp. The following example just writes the formatted results tocout, but you can redirect this to a file and then use a file comparison utility to verify that it is identical to the original.
   //: C04:Datascan.cpp
   // Test data generator
   //{L} DataLogger
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include "DataLogger.h"
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream bindata("data.bin", ios::binary);
     assure(bindata, "data.bin");
     DataPoint d;
     while (bindata.read(reinterpret_cast&lt;char*&gt;(&d),
            sizeof d))
       cout&lt;&lt; d&lt;&lt; endl;
   } ///:~

   Internationalization
   The software industry is now a healthy, worldwide economic market, and applications that can run in various languages and cultures are in demand. As early as the late 1980s, the C Standards Committee added support for non-U.S. formatting conventions with theirlocale mechanism. A locale is a set of preferences for displaying certain entities such as dates and monetary quantities. In the 1990s, the C Standards Committee approved an addendum to Standard C that specified functions to handlewide characters (denoted by the typewchar_t), which allow support for character sets other than ASCII and its commonly used Western European extensions. Although the size of a wide character is not specified, some platforms implement them as 32-bit quantities, so they can hold the encodings specified by the Unicode Consortium, as well as mappings to multi-byte characters sets defined by Asian standards bodies. C++ has integrated support for both wide characters and locales into the iostreams library.
   Wide Streams
   Awide stream is a simply a stream class that handles wide characters. All the examples so far (except for the last traits example in Chapter 3) have usednarrow streams, meaning streams that hold instances ofchar. Since stream operations are essentially the same no matter the underlying character type, they are encapsulated generically as templates. As we mentioned earlier, all input streams, for example, are connected somehow to thebasic_istream class template, which is defined as follows:
   template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
   class basic_istream {…};

   In fact, all input stream types are specializations of this template, according to the following type definitions:
   typedef basic_istream&lt;char&gt; istream;
   typedef basic_istream&lt;wchar_t&gt; wistream;
   typedef basic_ifstream&lt;char&gt; ifstream;
   typedef basic_ifstream&lt;wchar_t&gt; wifstream;
   typedef basic_istringstream&lt;char&gt; istringstream;
   typedef basic_istringstream&lt;wchar_t&gt; wistringstream;

   All other stream types are defined in similar fashion.
   In a "perfect" world, this is all you’d have to do to have streams of different character types. In reality, things aren’t that simple. The reason is that the character-processing functions provided forchar andwchar_t don’t have the same names. To compare two narrow strings, for example, you use thestrcmp( ) function. For wide characters, that function is namedwcscmp( ). (Remember these originated in C, which does not have function overloading, hence unique names are a must.) For this reason, a generic stream can’t just callstrcmp( ) in response to a comparison operator. There needs to be a way for the correct low-level functions to be called automatically.
   The principle that guides the solution is well known. You simply "factor out" the differences into a new abstraction. The operations you can perform on characters have been abstracted into thechar_traits template, which has predefined specializations for char andwchar_t, as we discussed at the end of the previous chapter. To compare two strings, then,basic_string just callstraits::compare( ) (remember thattraits is the second template parameter), which in turn calls eitherstrcmp( ) orwcscmp( ), depending on which specialization is being used (transparent tobasic_string, of course).
   You only need to be concerned aboutchar_traits if you access the low-level character processing functions; most of the time you don’t care. Consider, however, making your inserters and extractors more robust by defining them as templates, just in case someone wants to use them on a wide stream.
   To illustrate, recall again theDate class inserter from the beginning of this chapter. We originally declared it as:
   ostream& operator&lt;&lt;(ostream&, const Date&);

   This accommodates only narrow streams. To make it generic, we simply make it a template based onbasic_ostream:
   template&lt;class charT, class traits&gt;
   std::basic_ostream&lt;charT, traits&gt;&
   operator&lt;&lt;(std::basic_ostream&lt;charT, traits&gt;& os,
              const Date& d) {
     charT fillc = os.fill(os.widen('0'));
     charT dash = os.widen('-');
     os&lt;&lt; setw(2)&lt;&lt; d.month&lt;&lt; dash
       &lt;&lt; setw(2)&lt;&lt; d.day&lt;&lt; dash
        &lt;&lt; setw(4)&lt;&lt; d.year;
     os.fill(fillc);
     return os;
   }

   Notice that we also have to replacechar with the template parametercharT in the declaration offillc, since it could be eitherchar orwchar_t, depending on the template instantiation being used.
   Since you don’t know when you’re writing the template which type of stream you have, you need a way to automatically convert character literals to the correct size for the stream. This is the job of thewiden( ) member function. The expressionwiden('-'), for example, converts its argument toL’-’ (the literal syntax equivalent to the conversionwchar_t(‘-’)) if the stream is a wide stream and leaves it alone otherwise. There is also anarrow( ) function that converts to achar if needed.
   We can usewiden( ) to write a generic version of thenl manipulator we presented earlier in the chapter.
   template&lt;class charT, class traits&gt;
   basic_ostream&lt;charT,traits&gt;&
   nl(basic_ostream&lt;charT,traits&gt;& os) {
     return os&lt;&lt; charT(os.widen('\n'));
   }

   Locales
   Perhaps the most notable difference in typical numeric computer output from country to country is the punctuator used to separate the integer and fractional parts of a real number. In the United States, a period denotes a decimal point, but in much of the world, a comma is expected instead. It would be quite inconvenient to do all your own formatting for locale-dependent displays. Once again, creating an abstraction that handles these differences solves the problem.
   That abstraction is thelocale. All streams have an associated locale object that they use for guidance on how to display certain quantities for different cultural environments. A locale manages the categories of culture-dependent display rules, which are defined as follows:CategoryEffectcollateallows comparing strings according to different, supported collating sequencesctypeabstracts the character classification and conversion facilities found in&lt;cctype&gt;monetarysupports different displays of monetary quantitiesnumericsupports different display formats of real numbers, including radix (decimal point) and grouping (thousands) separatorstimesupports various international formats for display of date and timemessagesscaffolding to implement context-dependent message catalogs (such as for error messages in different languages)

   The following program illustrates basic locale behavior:
   //: C04:Locale.cpp
   //{-g++}
   //{-bor}
   //{-edg}
   // Illustrates effects of locales
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   using namespace std;
   int main() {
     locale def;
     cout&lt;&lt; def.name()&lt;&lt; endl;
     locale current = cout.getloc();
     cout&lt;&lt; current.name()&lt;&lt; endl;
     float val = 1234.56;
     cout&lt;&lt; val&lt;&lt; endl;
     // Change to French/France
     cout.imbue(locale("french"));
     current = cout.getloc();
     cout&lt;&lt; current.name()&lt;&lt; endl;
     cout&lt;&lt; val&lt;&lt; endl;

     cout&lt;&lt; "Enter the literal 7890,12: ";
     cin.imbue(cout.getloc());
     cin&gt;&gt; val;
     cout&lt;&lt; val&lt;&lt; endl;
     cout.imbue(def);
     cout&lt;&lt; val&lt;&lt; endl;
   } ///:~

   Here’s the output:
   C
   C
   1234.56
   French_France.1252
   1234,56
   Enter the literal 7890,12:7890,12
   7890,12
   7890.12

   The default locale is the "C" locale, which is what C and C++ programmers have been used to all these years (basically, English language and American culture). All streams are initially "imbued" with the "C" locale. Theimbue( ) member function changes the locale that a stream uses. Notice that the full ISO name for the "French" locale is displayed (that is, French used in France vs. French used in another country). This example shows that this locale uses a comma for a radix point in numeric display. We have to changecin to the same locale if we want to do input according to the rules of this locale.
   Each locale category is divided into number offacets, which are classes encapsulating the functionality that pertains to that category. For example, thetime category has the facetstime_put andtime_get, which contain functions for doing time and dateinput andoutput respectively. Themonetary category has facetsmoney_get,money_put, andmoneypunct. (The latter facet determines the currency symbol.) The following program illustrates themoneypunct facet. (Thetime facet requires a sophisticated use of iterators which is beyond the scope of this chapter.)
   //: C04:Facets.cpp
   //{-bor}
   //{-g++}
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     // Change to French/France
     locale loc("french");
     cout.imbue(loc);

     string currency =
       use_facet&lt;moneypunct&lt;char&gt;&gt;(loc).curr_symbol();
     char point =
       use_facet&lt;moneypunct&lt;char&gt;&gt;(loc).decimal_point();
     cout&lt;&lt; "I made "&lt;&lt; currency&lt;&lt; 12.34&lt;&lt; " today!"
         &lt;&lt; endl;
   } ///:~

   The output shows the French currency symbol and decimal separator:
   I made?12,34 today!

   You can also define your own facets to construct customized locales.[47] Be aware that the overhead for locales is considerable. In fact, some library vendors provide different "flavors" of the standard C++ library to accommodate environments that have limited space.[48]
   Summary
   This chapter has given you a fairly thorough introduction to the iostream class library. In all likelihood, it is all you need to create programs using iostreams. However, be aware that some additional features in iostreams are not used often, but you can discover them by looking at the iostream header files and by reading your compiler’s documentation on iostreams or the references mentioned in this chapter and in the book’s preface.
   Exercises
                1.             Open a file by creating anifstream object. Make anostringstream object and read the entire contents into theostringstream using therdbuf( ) member function. Extract astring copy of the underlying buffer and capitalize every character in the file using the Standard Ctoupper( ) macro defined in&lt;cctype&gt;. Write the result out to a new file.&lt;/#&gt;&lt;#TIC2V2_CHAPTER5_I190&gt;
           24.             Create a program that opens a file (the first argument on the command line) and searches it for any one of a set of words (the remaining arguments on the command line). Read the input a line at a time, and write out the lines (with line numbers) that matchto the new file.&lt;/#&gt;&lt;#TIC2V2_CHAPTER5_I191&gt;
           25.             Write a program that adds a copyright notice to the beginning of all source-code files indicated by the program’s command-line arguments.&lt;/#&gt;&lt;#TIC2V2_CHAPTER5_I192&gt;
           26.             Use your favorite text-searching program (grep, for example) to output the names (only) of all the files that contain a particular pattern. Redirect the output into a file. Write a program that uses the contents of that file to generate a batch file that invokes your editor on each of the files found by the search program.
            27.             We know thatsetw( ) allows for a minimum of characters read in, but what if you wanted to read a maximum? Write an effector that allows the user to specify a maximum number of characters to extract. Have your effector also work for output, in such a way that output fields are truncated, if necessary, to stay within width limits.
           28.             Demonstrate to yourself that if the fail or bad bit is set, and you subsequently turn on stream exceptions, that the stream will immediately throw an exception.
           29.             String streams accommodate easy conversions, but they come with a price. Write a program that racesatoi( ) against thestringstream conversion system to see the effect of the overhead involved withstringstream.
           30.             Make aPerson struct with fields such as name, age, address, etc. Make the string fields fixed-size arrays. The social security number will be the key for each record. Implement the followingDatabase class.

   class DataBase {
   public:
     // Find where a record is on disk
     size_t query(size_t ssn);
     // Return the person at rn (record number)
     Person retrieve(size_t rn);
     // Record a record on disk
     void add(const Person& p);
   };

   Write somePerson records to disk (do not keep them all in memory). When the user requests a record, read it off the disk and return it. The I/O operations in theDataBase class useread( ) andwrite( ) to process allPerson records.
            31.             Write anoperator&lt;&lt; inserter for thePerson struct that can be used to display records in a format easily read. Practice writing it out to file.
           32.             Suppose your database for yourPerson structs was lost but that you have the file you wrote from the previous exercise. Recreate your database using this file. Be sure to use error checking.
           33.             Writesize_t(-1) (the largestunsigned int on your platform) to a text file 1,000,000 times. Repeat, but write to a binary file. Compare the two files for size, and see how much room is saved using the binary format. (You may first want to try to calculate how much will be saved on your platform.)
           34.             Found out the maximum number of digits of precision your implementation of iostreams will print by repeatedly increasing the value of the argument toprecision( ) when printing a transcendental number such assqrt(2.0).
           35.             Write a program that reads real numbers from a file and prints their sum, average, minimum, and maximum.
           36.             Determine the output of the following program before it is executed.
   //: C04:Exercise16.cpp
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include "../require.h"
   using namespace std;
   #define d(a) cout&lt;&lt; #a " ==\t"&lt;&lt; a&lt;&lt; endl;

   void tellPointers(fstream& s) {
     d(s.tellp());
     d(s.tellg());
     cout&lt;&lt; endl;
   }
   void tellPointers(stringstream& s) {
     d(s.tellp());
     d(s.tellg());
     cout&lt;&lt; endl;
   }
   int main() {
     fstream in("Exercise16.cpp");
     assure(in, "Exercise16.cpp");
     in.seekg(10);
     tellPointers(in);
     in.seekp(20);
     tellPointers(in);
     stringstream memStream("Here is a sentence.");
     memStream.seekg(10);
     tellPointers(memStream);
     memStream.seekp(5);
     tellPointers(memStream);
   } ///:~

            37.             Suppose you are given line-oriented data in a file formatted as follows:
   Australia
   5E56,7667230284,Langler,Tyson,31.2147,0.00042117361
   2B97,7586701,Oneill,Zeke,553.429,0.0074673053156065
   4D75,7907252710,Nickerson,Kelly,761.612,0.010276276
   9F2,6882945012,Hartenbach,Neil,47.9637,0.0006471644
   Austria
   480F,7187262472,Oneill,Dee,264.012,0.00356226040013
   1B65,4754732628,Haney,Kim,7.33843,0.000099015948475
   DA1,1954960784,Pascente,Lester,56.5452,0.0007629529
   3F18,1839715659,Elsea,Chelsy,801.901,0.010819887645
   Belgium
   BDF,5993489554,Oneill,Meredith,283.404,0.0038239127
   5AC6,6612945602,Parisienne,Biff,557.74,0.0075254727
   6AD,6477082,Pennington,Lizanne,31.0807,0.0004193544
   4D0E,7861652688,Sisca,Francis,704.751,0.00950906238
   Bahamas
   37D8,6837424208,Parisienne,Samson,396.104,0.0053445
   5E98,6384069,Willis,Pam,90.4257,0.00122009564059246
   1462,1288616408,Stover,Hazal,583.939,0.007878970561
   5FF3,8028775718,Stromstedt,Bunk,39.8712,0.000537974
   1095,3737212,Stover,Denny,3.05387,0.000041205248883
   7428,2019381883,Parisienne,Shane,363.272,0.00490155

   The heading of each section is a region, and every line under that heading is a seller in that region. Each comma-separated field represents the data about each seller. The first field in a line is the SELLER_ID which unfortunately was written out in hexadecimal format. The second is the PHONE_NUMBER (notice that some are missing area codes). LAST_NAME and FIRST_NAME then follow. TOTAL_SALES is the second to the last column. The last column is the decimal amount of the total sales that the seller represents for the company. You are to format the data on the terminal window so that an executive can easily interpret the trends. Sample output is given below.           Australia
                 ---------------------------------

   *Last Name*   *First Name*   *ID*    *Phone*        *Sales*   *Percent*

   Langler       Tyson          24150   766-723-0284     31.24   4.21E-02
   Oneill        Zeke           11159   XXX-758-6701    553.43   7.47E-01
   (etc.)
   5: Templates in depth
   The C++ template facility goes far beyond simple "containers ofT." Although the original motivation was to enable type-safe, generic containers, in modern C++, templates are also used to generate custom code and to optimize program execution through compile-time programming constructs.
   In this chapter we offer a practical look at the power (and pitfalls) of programming with templates in modern C++. For a more complete analysis of template-related language issues and "gotchas," we recommend the superb book by David Vandevoorde and Nico Josuttis.[49] 
   Template parameters
   As we illustrated in Volume 1, templates come in two flavors: function templates and class templates. Both are wholly characterized by their parameters. Each template parameter itself can represent one of the following categories of arguments:
   1.       Types (either built-in or user-defined)
   2.      Compile-time constant values (for example, integers, and pointers and references to static entities; often referred to as non-type parameters)
   3.      Other templates
   The examples in Volume 1 all fall into the first category and are the most common. The canonical example for simple container-like templates nowadays seems to be aStack class. Being a container, aStack object is not concerned with the type of object it stores; the logic of holding objects is independent of the type of objects being held. For this reason you can use a type parameter to represent the contained type:.
   template&lt;class T&gt;
   class Stack {
     T* data;
     size_t count;
   public:
     void push(const T& t);
     // etc.
   };

   You provide the actual type to be used for a particularStack instance by means of an argument for the parameterT:
   Stack&lt;int&gt; myStack;  // A Stack of ints

   The compiler then provides anint-version ofStack by substitutingint forT and generating the corresponding code. The name of the class instance generated from the template in this case isStack&lt;int&gt;.
   Non-type template parameters
   It is also possible to provide a non-type template parameter, as long as it represents an integral value that is known at compile time. You can make a fixed-sizeStack, for instance, by specifying a non-type parameter to be used as the dimension for the underlying array, as follows.
   template&lt;class T, size_t N&gt;
   class Stack {
     T data[N];  // Fixed capacity is N
     size_t count;
   public:
     void push(const T& t);
     // etc.
   };

   You must provide a compile-time constant value for the parameterN when you request an instance of this template, such as
   Stack&lt;int, 100&gt; myFixedStack;

   Because the value ofN is known at compile time, the underlying array (data) can be placed on the runtime stack instead of on the free store, which can improve runtime performance by avoiding the overhead associated with dynamic memory allocation. Following the pattern mentioned earlier, the name of the class above isStack&lt;int, 100&gt;. This means that each distinct value ofN results in a unique class type. For example,Stack&lt;int, 99&gt; is a distinct class fromStack&lt;int, 100&gt;.
   Thebitset class template, discussed in detail in Chapter 7, is the only class in the standard C++ library that uses a non-type template parameter, which happens to specify the number of bits thebitset object can hold. The following random number generator example uses abitset to track numbers so all the numbers in its range are returned in random order without repetition before starting over. This example also overloadsoperator( ) to produce a familiar function-call syntax.
   //: C05:Urand.h
   //{-bor}
   // Unique randomizer
   #ifndef URAND_H
   #define URAND_H
   #include&lt;bitset&gt;
   #include&lt;cstddef&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   using std::size_t;
   using std::bitset;

   template&lt;size_t UpperBound&gt;
   class Urand {
     bitset&lt;UpperBound&gt; used;
   public:
     Urand() {
       srand(time(0));  // randomize
     }
     size_t operator()(); // The "generator" function
   };

   template&lt;size_t UpperBound&gt;
   inline size_t Urand&lt;UpperBound&gt;::operator()() {
     if(used.count() == UpperBound)
       used.reset();  // start over (clear bitset)
     size_t newval;
     while(used[newval = rand() % UpperBound])
       ; // Until unique value is found
     used[newval] = true;
     return newval;
   }
   #endif // URAND_H ///:~

   The uniqueness ofUrand is produced by tracking with abitset all the numbers possible in the random space (the upper bound is set with the template argument) and by recording each number as it’s used by setting the corresponding position bit inused. When the numbers are all used up, thebitset is cleared to start over. Here’s a simple driver that illustrates how to use aUrand object:.
   //: C05:UrandTest.cpp
   //{-bor}
   #include&lt;iostream&gt;
   #include "Urand.h"
   using namespace std;

   int main() {
     Urand&lt;10&gt; u;
     for(int i = 0; i&lt; 20; ++i)
       cout&lt;&lt; u()&lt;&lt; ' ';
   } ///:~

   As we explain later in this chapter, non-type template arguments are also important in the optimization of numeric computations.
   Default template arguments
   You can provide default arguments for template parameters in class templates. (They are not allowed in function templates.) As with default function arguments, they should only be defined once, the first time a template declaration or definition is seen by the compiler; and once you introduce a default argument, all the subsequent template parameters must also have defaults. To make the fixed-sizeStack template shown earlier a little friendlier, for example, you can add a default argument like this:.
   template&lt;class T, size_t N = 100&gt;
   class Stack {
     T data[N];  // Fixed capacity is N
     size_t count;
   public:
     void push(const T& t);
     // etc.
   };

   Now, if you omit the second template argument when declaring aStack object, the value forN will default to 100.
   You can choose to provide defaults for all arguments, but you must use an empty set of brackets when declaring an instance so that the compiler knows that a class template is involved. Here’s how:
   template&lt;class T = int, size_t N = 100&gt;  // Both defaulted
   class Stack {
     T data[N];  // Fixed capacity is N
     size_t count;
   public:
     void push(const T& t);
     // etc.
   };

   Stack&lt;&gt; myStack;  // Same as Stack&lt;int, 100&gt;.

   Default arguments are used heavily in the standard C++ library. Thevector class template, for instance, is declared as follows:
   template&lt;class T, class Allocator = allocator&lt;T&gt;&gt;
   class vector;

   Note the space between the last two right angle bracket characters. This prevents the compiler from interpreting those two characters (&gt;&gt;) as the right-shift operator.
   This declaration reveals thatvector actually takes two arguments: the type of the contained objects it holds, and a type that represents the allocator used by the vector. (We talk more about allocators in Chapter 7.) Whenever you omit the second argument, the standardallocator template is used, parameterized by the first template parameter. This declaration also shows that you can use template parameters in other, subsequent template parameters, asT is used here.
   Although you cannot use default template arguments in function templates, you can use template parameters as default arguments to normal functions. The following function template adds the elements in a sequence.
   //: C05:FuncDef.cpp
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   T sum(T* b, T* e, T init = T()) {
     while(b != e)
       init += *b++;
     return init;
   }

   int main() {
     int a[] = {1,2,3};
     cout&lt;&lt; sum(a, a+sizeof a / sizeof a[0])&lt;&lt; endl; // 6
   } ///:~

   The third argument tosum( ) is the initial value for the accumulation of the elements. Since we omitted it, this argument defaults toT( ), which in the case ofint and other built-in types invokes a pseudo-constructor that performs zero-initialization.
   Template template parameters
   The third type of parameter a template can accept is another class template. This may sound strange, since templates are types, and type parameters are already allowed, but if you are going to use a template type parameter as a template in your code, the compiler needs to know that the parameter is a template in the first place. The following example illustrates a template template parameter.
   //: C05:TempTemp.cpp
   // Illustrates a template template parameter
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   class Array { // A simple, expandable sequence
     enum {INIT = 10};
     T *data;
     size_t capacity;
     size_t count;
   public:
     Array() {
       count = 0;
       data = new T[capacity = INIT];
     }
     void push_back(const T& t) {
       if(count == capacity) {
         // Grow underlying array
         size_t newCap = 2*capacity;
         T* newData = new T[newCap];
         for (size_t i = 0; i&lt; count; ++i)
           newData[i] = data[i];
         delete data;
         data = newData;
         capacity = newCap;
       }
       data[count++] = t;
     }
     void pop_back() {
       if(count&gt; 0)
         --count;
     }
     T* begin() {
       return data;
     }
     T* end() {
       return data + count;
     }
   };

   template&lt;class T, template&lt;class&gt; class Seq&gt;
   class Container {
     Seq&lt;T&gt; seq;
   public:
     void append(const T& t) {
       seq.push_back(t);
     }
     T* begin() {
       return seq.begin();
     }
     T* end() {
       return seq.end();
     }
   };

   int main() {
     Container&lt;int, Array&gt; theData;
     theData.append(1);
     theData.append(2);
     int* p = theData.begin();
     while(p != theData.end())
       cout&lt;&lt; *p++&lt;&lt; endl;
   } ///:~

   TheArray class template is a trivial sequence container. TheContainer template takes two parameters: the type of the objects it is to hold, and a sequence data structure to do the holding. The following line in the implementation of theContainer class requires that we inform the compiler thatSeq is a template:.
     Seq&lt;T&gt; seq;

   If we hadn’t declaredSeq to be a template template parameter, the compiler would complain here thatSeq is not a template, since we’re using it as such. Inmain( ) aContainer is instantiated to use anArray to hold integers, soSeq stands forArray in this example.
   Note that it is not necessary in this case to name the parameter forSeq insideContainer’s declaration. The line in question is:
   template&lt;class T, template&lt;class&gt; class Seq&gt;

   Although we could have written
   template&lt;class T, template&lt;class U&gt; class Seq&gt;

   the parameterU is not needed anywhere. All that matters is thatSeq is a class template that takes a single type parameter. This is analogous to omitting the names of function parameters when they’re not needed, such as when you overload the post-increment operator:.
   T operator++(int);

   Theint here is merely a placeholder and therefore needs no name.
   The following program uses a fixed-size array, which has an extra template parameter representing the array dimension:
   //: C05:TempTemp2.cpp
   // A multi-variate template template parameter
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T, size_t N&gt;
   class Array {
     T data[N];
     size_t count;
   public:
     Array() { count = 0; }
     void push_back(const T& t) {
       if(count&lt; N)
         data[count++] = t;
     }
     void pop_back() {
       if(count&gt; 0)
         --count;
     }
     T* begin() { return data; }
     T* end() { return data + count; }
   };

   template&lt;class T,size_t N,template&lt;class,size_t&gt; class Seq&gt;
   class Container {
     Seq&lt;T,N&gt; seq;
   public:
     void append(const T& t) { seq.push_back(t); }
     T* begin() { return seq.begin(); }
     T* end() { return seq.end(); }
   };

   int main() {
     const size_t N = 10;
     Container&lt;int, N, Array&gt; theData;
     theData.append(1);
     theData.append(2);
     int* p = theData.begin();
     while(p != theData.end())
       cout&lt;&lt; *p++&lt;&lt; endl;
   } ///:~

   Once again, parameter names are not needed in the declaration ofSeq insideContainer’s declaration, but we need two parameters to declare the data memberseq, hence the appearance of the non-type parameterN at the top level.
   Combining default arguments with template template parameters is slightly more problematic. The When the compiler looks at the inner parameters of a template template parameter, default arguments are not considered, so you have to repeat the defaults in order to get an exact match. The following example uses a default argument for the fixed-sizeArray template and shows how to accommodate this quirk in the language.
   //: C05:TempTemp3.cpp
   //{-bor}
   //{-msc}
   // Combining template template parameters and
   // default arguments
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T, size_t N = 10&gt;  // A default argument
   class Array {
     T data[N];
     size_t count;
   public:
     Array() { count = 0; }
     void push_back(const T& t) {
       if(count&lt; N)
         data[count++] = t;
     }
     void pop_back() {
       if(count&gt; 0)
         --count;
     }
     T* begin() { return data; }
     T* end() { return data + count; }
   };

   template&lt;class T, template&lt;class, size_t = 10&gt; class Seq&gt;
   class Container {
     Seq&lt;T&gt; seq;  // Default used
   public:
     void append(const T& t) { seq.push_back(t); }
     T* begin() { return seq.begin(); }
     T* end() { return seq.end(); }
   };

   int main() {
     Container&lt;int, Array&gt; theData;
     theData.append(1);
     theData.append(2);
     int* p = theData.begin();
     while(p != theData.end())
       cout&lt;&lt; *p++&lt;&lt; endl;
   } ///:~

   It is necessary to include the default dimension of 10 in the line:
   template&lt;class T, template&lt;class, size_t = 10&gt; class Seq&gt;

   Both the definition ofseq inContainer andtheData inmain( ) use the default. The only way to use something other than the default value is as the previous program (TempTemp2.cpp) illustrated. This is the only exception to the rule stated earlier that default arguments should appear only once in a compilation unit.
   Since the standard sequence containers (vector,list, anddeque, discussed in depth in Chapter 7) have a default allocator argument, the technique shown above is helpful should you ever want to pass one of these sequences as a template parameter. The following program passes avector and then alist to two instances ofContainer.
   //: C05:TempTemp4.cpp
   //{-bor}
   //{-msc}
   // Passes standard sequences as template arguments
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;memory&gt;  // Declares allocator&lt;T&gt;
   #include&lt;vector&gt;
   using namespace std;

   template&lt;class T, template&lt;class U, class = allocator&lt;U&gt;&gt;
        class Seq&gt;
   class Container {
     Seq&lt;T&gt; seq; // Default of allocator&lt;T&gt; applied implicitly
   public:
     void push_back(const T& t) { seq.push_back(t); }
     typename Seq&lt;T&gt;::iterator begin() { return seq.begin(); }
     typename Seq&lt;T&gt;::iterator end() { return seq.end(); }
   };

   int main() {
     // Use a vector
     Container&lt;int, vector&gt; theData;
     theData.push_back(1);
     theData.push_back(2);
     for(vector&lt;int&gt;::iterator p = theData.begin();
         p != theData.end(); ++p) {
       cout&lt;&lt; *p&lt;&lt; endl;
     }
     // Use a list
     Container&lt;int, list&gt; theOtherData;
     theOtherData.push_back(3);
     theOtherData.push_back(4);
     for(list&lt;int&gt;::iterator p2 = theOtherData.begin();
         p2 != theOtherData.end(); ++p2) {
       cout&lt;&lt; *p2&lt;&lt; endl;
     }
   } ///:~

   In this case we name the first parameter of the inner templateSeq (with the nameU), because the allocators in the standard sequences must themselves be parameterized with the same type as the contained objects in the sequence. Also, since the defaultallocator parameter is known, we can omit it in the subsequent references toSeq&lt;T&gt;, as we did in the previous program. To fully explain this example, however, we have to discuss the semantics of thetypename keyword.
   The typename keyword
   Consider the following:.
   //: C05:TypenamedID.cpp
   //{-bor}
   // Uses 'typename' as a prefix for nested types

   template&lt;class T&gt; class X {
     // Without typename, you should get an error:
     typename T::id i;
   public:
     void f() { i.g(); }
   };

   class Y {
   public:
     class id {
     public:
       void g() {}
     };
   };

   int main() {
     X&lt;Y&gt; xy;
     xy.f();
   } ///:~

   The template definition assumes that the classT that you hand it must have a nested identifier of some kind calledid. Butid could also be a static data member ofT, in which case you can perform operations oniddirectly, but you can’t "create an object" of "the typeid.".
   However, that’s exactly what is happening here: the identifieridis being treated as if it were actually a nested type insideT. In the case of classY,id is in fact a nested type, but (without thetypenamekeyword) the compiler can’t know that when it’s compilingX.
   If the compiler has the option of treating an identifier as a type or as something other than a type when it sees an identifier in a template, it will assume that the identifier refers to something other than a type. That is, it will assume that the identifier refers to an object (including variables of primitive types), an enumeration, or something similar. However, it will not–cannot–just assume that it is a type.
   Because the default behavior of the compiler is to assume that a name that fits the above two points is not a type, you must usetypename for nested names (except in constructor initializer lists, where it is neither needed nor allowed). In the above example, when the compiler seestemplate T::id, it knows (because of thetypename keyword) thatid refers to a nested type and thus it can create an object of that type.
   The short version of the rule is: if a type referred to inside template code is qualified by a template type parameter, it should be preceded by thetypename keyword, unless it appears in a base class specification or initializer list in the same scope (in which case you must not).
   All the above explains the use of thetypename keyword in the programTempTemp4.cpp. Without it, the compiler would assume that the expressionSeq&lt;T&gt;::iterator is not a type, but we were using it to define the return type of thebegin( ) andend( ) member functions.
   The following example, which defines a function template that can print any standard C++ sequence, shows a similar use oftypename.
   //: C05:PrintSeq.cpp
   //{-msc}
   // A print function for standard C++ sequences
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;memory&gt;
   #include&lt;vector&gt;
   using namespace std;

   template&lt;class T, template&lt;class U, class = allocator&lt;U&gt;&gt;
      class Seq&gt;
   void printSeq(Seq&lt;T&gt;& seq) {
     for (typename Seq&lt;T&gt;::iterator b = seq.begin();
          b != seq.end();)
       cout&lt;&lt; *b++&lt;&lt; endl;
   }

   int main() {
     // Process a vector
     vector&lt;int&gt; v;
     v.push_back(1);
     v.push_back(2);
     printSeq(v);
     // Process a list
     list&lt;int&gt; lst;
     lst.push_back(3);
     lst.push_back(4);
     printSeq(lst);
   } ///:~

   Once again, without thetypename keyword the compiler will interpretiterator as a static data member ofSeq&lt;T&gt;, which is a syntax error, since a type is required.
   Typedef-ing a typename
   It’s important not to assume that thetypename keyword creates a new type name. It doesn’t. Its purpose is to inform the compiler that the qualified identifier is to be interpreted as a type. A line that reads:.
   typename Seq&lt;T&gt;::iterator It;

   causes a variable namedIt to be declared of typeSeq&lt;T&gt;::iterator. If you mean to create a new type name, you should usetypedef, as usual, as in:.
   typedef typename Seq&lt;It&gt;::iterator It;

   Using typename instead of class
   Another role of thetypename keyword is to provide you the option of usingtypename instead ofclass in the template argument list of a template definition. To some, this produces clearer code (your mileage may vary):.
   //: C05:UsingTypename.cpp
   // Using 'typename' in the template argument list

   template&lt;typename T&gt; class X { };

   int main() {
     X&lt;int&gt; x;
   } ///:~

   You probably won’t see a great deal of code that usestypename in this fashion, since the keyword was added to the language a relatively long time after templates were introduced.
   Using the template keyword as a hint
   Just as thetypename keyword helps the compiler in situations in which a type identifier is not expected, there is also a potential difficulty with tokens that are not identifiers, such as the&lt; and&gt; characters; sometimes they represent the less-than or greater-than symbols, and sometimes they delimit template parameter lists. As an example, we’ll once more use thebitset class:.
   //: C05:DotTemplate.cpp
   // Illustrate the .template construct
   #include&lt;bitset&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   template&lt;class charT, size_t N&gt;
   basic_string&lt;charT&gt; bitsetToString(const bitset&lt;N&gt;& bs) {
     return bs. template to_string&lt;charT, char_traits&lt;charT&gt;,
                                   allocator&lt;charT&gt;&gt;();
   }

   int main() {
     bitset&lt;10&gt; bs;
     bs.set(1);
     bs.set(5);
     cout&lt;&lt; bs&lt;&lt; endl; // 0000100010
     string s = bitsetToString&lt;char&gt;(bs);
     cout&lt;&lt; s&lt;&lt; endl;  // 0000100010
   } ///:~

   Thebitset class supports conversion to string object via itsto_string member function. To support multiple string classes,to_string is itself a template, following the pattern established by thebasic_string template discussed in Chapter 3. The declaration ofto_string inside ofbitset looks like this:.
   template&lt;class charT, class traits, class Allocator&gt;
   basic_string&lt;charT, traits, Allocator&gt; to_string() const;

   OurbitsetToString( ) function template above allows you to request different types of string representations of abitset. To get a wide string, for instance, you change the call to the following:
     wstring s = bitsetToString&lt;wchar_t&gt;(bs);

   Note thatbasic_string uses default template arguments, so we don’t have to repeat thechar_traits andallocator arguments in the return value. Unfortunately,bitset::to_string does not use default arguments. UsingbitsetToString&lt;char&gt;( bs) is more convenient than typing a fully-qualified call tobs.template to_string&lt;char, char_traits, allocator&lt;char&gt;&gt;( ) every time.
   The return statement inbitsetToString( ) contains thetemplate keyword in an odd place—right after the dot operator applied to thebitset objectbs. This is because when the template is parsed, the&lt; character after theto_string token would be interpreted as a less-than operation instead of the beginning or a template argument list. We explain exactly why this confusion exists in the section "Name lookup issues" later in this chapter. Thetemplate keyword used in this context tells the compiler that what follows is the name of a template, causing the&lt; character to be interpreted correctly. The same reasoning applies to the-&gt; and:: operators when applied to templates. As with thetypename keyword, this template disambiguation technique can only be used within a template.[50] 
   Member Templates
   Thebitset::to_string( ) function template is an example of amember template: a template declared within another class or class template. This allows many combinations of independent template arguments to be combined. A useful example is found in thecomplex class template in the standard C+ library. Thecomplex template has a type parameter meant to represent an underlying floating-point type to hold the real and imaginary parts of a complex number. The following code snippet from the standard library shows a member-template constructor in thecomplex class template:.
   template&lt;typename T&gt;
   class complex {
   public:
     template&lt;class X&gt; complex(const complex&lt;X&gt;&);

   The standardcomplex template comes ready-made with specializations that usefloat,double, andlong double for the parameterT. The member-template constructor above allows you to create a new complex number that uses a different floating-point type as its base type, as seen in the code below:.
     complex&lt;float&gt; z(1,2);
     complex&lt;double&gt; w(z);

   In the declaration ofw, thecomplex template parameterT isdouble andX isfloat. Member templates make this kind of flexible conversion easy.
   Since defining a template within a template is a nesting operation, the prefixes that introduce the templates must reflect that nesting if you define the member template outside the outer class definition. For example, if you were to implement thecomplex class template, and if you were to define the member-template constructor above outside thecomplex template class definition, you would have to do it like this:.
   template&lt;typename T&gt;
   template&lt;typename X&gt;
   complex&lt;T&gt;::complex(const complex&lt;X&gt;& c) {/*body here…*/}

   Another use of member function templates in the standard library is in the initialization of containers, such as avector. Suppose we have avector ofints and we want to initialize a new vector ofdoubles with it, like this:.
     int data[5] = {1,2,3,4,5};
     vector&lt;int&gt; v1(data, data+5);
     vector&lt;double&gt; v2(v1.begin(), v1.end());

   As long as the elements inv1 are assignment-compatible with the elements inv2 (asdouble andint are here), all is well. Thevector class template has the following member template constructor:.
   template&lt;class InputIterator&gt;
   vector(InputIterator first, InputIterator last,
          const Allocator& = Allocator());

   This constructor is actually used twice in the vector declarations above. Whenv1 is initialized from the array ofints, the typeInputIterator isint*. Whenv2 is initialized fromv1, an instance of the member template constructor is used withInputIterator representingvector&lt;int&gt;::iterator.
   Member templates can also be classes. (They don’t have to be functions, although that’s usually what you need.) The following example shows a member class template inside an outer class template.
   //: C05:MemberClass.cpp
   // A member class template
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   template&lt;class T&gt;
   class Outer {
   public:
     template&lt;class R&gt;
     class Inner {
     public:
       void f();
     };
   };

   template&lt;class T&gt; template&lt;class R&gt;
   void Outer&lt;T&gt;::Inner&lt;R&gt;::f() {
     cout&lt;&lt; "Outer == "&lt;&lt; typeid(T).name()&lt;&lt; endl;
     cout&lt;&lt; "Inner == "&lt;&lt; typeid(R).name()&lt;&lt; endl;
     cout&lt;&lt; "Full Inner == "&lt;&lt; typeid(*this).name()&lt;&lt; endl;
   }

   int main() {
     Outer&lt;int&gt;::Inner&lt;bool&gt; inner;
     inner.f();
   } ///:~

   Thetypeid operator, which is covered in Chapter 8, returns an object whosename( ) member function yields a string representation of a type or of the type of a variable. Although the exact representation varies from compiler to compiler, the output of the program above should be something like this:.
   Outer == int
   Inner == bool
   Full Inner == Outer&lt;int&gt;::Inner&lt;bool&gt;

   The declaration of the variableinner in the main program instantiates bothInner&lt;bool&gt; andOuter&lt;int&gt;.
   Member template functions cannot be declaredvirtual. Current compiler technology expects to be able to fix the size of a class’s virtual function table when the class is parsed. Allowing virtual member template functions would require knowing all calls to such member functions everywhere in the program ahead of time, which is not feasible, especially for multi-file projects.
   Function template issues
   Just as a class template describes a family of classes, a function template describes a family of functions. The syntax for creating either type of template is virtually identical, but they differ somewhat in how they are used. You must always use angle brackets when instantiating class templates and you must supply all non-default template arguments. With function templates, on the other hand, you can often omit the template arguments, and default template arguments are not even allowed.[ ]Consider a typical implementation of themin( ) function template declared in the&lt;algorithm&gt; header, which looks something like this:.
   template&lt;typename T&gt;
   const T& min(const T& a, const T& b) {
     return (a&lt; b) ? a : b;
   }

   You could invoke this template by providing the type of the arguments in angle brackets, just like you do with class templates, as in:
   int z = min&lt;int&gt;(i, j);

   This syntax tells the compiler that a specialization of themin template is needed withint used in place of the parameterT, whereupon the compiler generates the corresponding code. Following the pattern of naming the classes generated from class templates, you can think of the name of the instantiated function asmin&lt;int&gt;.
   Type deduction of function template arguments
   You can always use such explicit function template specification as in the example above, but it is often convenient to leave off the template arguments and let the compiler deduce them from the function arguments, like this:.
   int z = min(i, j);

   If bothi andj areints, the compiler knows that you needmin&lt;int&gt;, which it then instantiates automatically. The types must be identical, because the template was originally specified with only one template type argument used for both function parameters. No standard conversions are applied for function arguments whose type is specified by a template parameter. For example, if you wanted to find the minimum of anint and adouble, the following attempt at a call tomin would fail:.
   int z = min(x, j); // x is a double

   Sincex andj are distinct types, no single parameter matches the template parameterT in the definition ofmin; so the call does not match the template declaration. You can work around this difficulty by casting one argument to the other’s type or by reverting to the fully-specified call syntax, as in:.
   int z = min&lt;double&gt;(x, j);

   This tells the compiler to generate thedouble version ofmin, after whichj can be promoted to adouble by normal standard conversion rules (because the functionmin&lt;double&gt;(const double&, const double&) would then exist).
   You might be tempted to require two parameters formin, allowing the types of the arguments to be independent, like this:
   template&lt;typename T, typename U&gt;
   const T& min(const T& a, const U& b) {
     return (a&lt; b) ? a : b;
   }

   This is often a good strategy, but in this case it is problematic becausemin must return a value, and there is no satisfactory way to determine which type it should be (T orU?).
   If the return type of a function template is an independent template parameter, you must always specify its type explicitly when you call it, since there is no argument from which to deduce it. Such is the case with thefromString template below.
   //: C05:StringConv.h
   #ifndef STRINGCONV_H
   #define STRINGCONV_H
   // Function templates to convert to and from strings
   #include&lt;string&gt;
   #include&lt;sstream&gt;

   template&lt;typename T&gt;
   T fromString(const std::string& s) {
     std::istringstream is(s);
     T t;
     is&gt;&gt; t;
     return t;
   }

   template&lt;typename T&gt;
   std::string toString(const T& t) {
     std::ostringstream s;
     s&lt;&lt; t;
     return s.str();
   }
   #endif // STRINGCONV_H ///:~

   These function templates provide conversions to and fromstd:: string for any types that provide a stream inserter or extractor, respectively. Here’s a test program that includes the use of the standard librarycomplex number type:.
   //: C05:StringConvTest.cpp
   #include "StringConv.h"
   #include&lt;iostream&gt;
   #include&lt;complex&gt;
   using namespace std;

   int main() {
     int i = 1234;
     cout&lt;&lt; "i == \""&lt;&lt; toString(i)&lt;&lt; "\"\n";
     float x = 567.89;
     cout&lt;&lt; "x == \""&lt;&lt; toString(x)&lt;&lt; "\"\n";
     complex&lt;float&gt; c(1.0, 2.0);
     cout&lt;&lt; "c == \""&lt;&lt; toString(c)&lt;&lt; "\"\n";
     cout&lt;&lt; endl;

     i = fromString&lt;int&gt;(string("1234"));
     cout&lt;&lt; "i == "&lt;&lt; i&lt;&lt; endl;
     x = fromString&lt;float&gt;(string("567.89"));
     cout&lt;&lt; "x == "&lt;&lt; x&lt;&lt; endl;
     c = fromString&lt; complex&lt;float&gt;&gt;(string("(1.0,2.0)"));
     cout&lt;&lt; "c == "&lt;&lt; c&lt;&lt; endl;
   } ///:~

   The output is what you’d expect:.
   i == "1234"
   x == "567.89"
   c == "(1,2)"

   i == 1234
   x == 567.89
   c == (1,2)

   Notice that in each of the instantiations offromString, the template parameter is specified in the call. If you have a function template with template parameters for the parameter types as well as the return types, it is important to declare the return type parameter first; otherwise you won’t be able to omit the type parameters for the function parameters. As an illustration, consider the following well-known function template:[51] 
   //: C05:ImplicitCast.cpp
   template&lt;typename R, typename P&gt;
   R implicit_cast(const P& p) {
     return p;
   }

   int main() {
     int i = 1;
     float x = implicit_cast&lt;float&gt;(i);
     int j = implicit_cast&lt;int&gt;(x);
     // char* p = implicit_cast&lt;char*&gt;(i);
   } ///:~

   If you interchangeR andP in the template parameter list near the top of the file, it will be impossible to compile this program because the return type will remain unspecified (since the first template parameter would be the function’s parameter type). The last line (which is commented out) is illegal because there is no standard conversion fromint tochar*;implicit_cast is for revealing in your code conversions that are allowed naturally.
   With a little care you can even deduce array dimensions. The following example has an array-initialization function template (init2) that does just that.
   //: C05:ArraySize.cpp
   #include&lt;cstddef&gt;
   using std::size_t;

   template&lt;size_t R, size_t C, typename T&gt;
   void init1(T a[R][C]) {
     for (size_t i = 0; i&lt; R; ++i)
       for (size_t j = 0; j&lt; C; ++j)
         a[i][j] = T();
   }

   template&lt;size_t R, size_t C, class T&gt;
   void init2(T (&a)[R][C]) {  // reference parameter
     for (size_t i = 0; i&lt; R; ++i)
       for (size_t j = 0; j&lt; C; ++j)
         a[i][j] = T();
   }

   int main() {
     int a[10][20];
     init1&lt;10,20&gt;(a);  // must specify
     init2(a);         // sizes deduced
   } ///:~

   Array dimensions are not passed as part of a function parameter’s type unless that parameter is passed by pointer or reference. The function templateinit2 declaresa to be a reference to a two-dimensional array, so its dimensionsR andC are deduced by the template facility, makinginit2 a handy way to initialize a two-dimensional array of any size. The templateinit1 does not pass the array by reference, so the sizes must be explicitly specified, although the type parameter can still deduced.
   Function template overloading
   As with functions, you can overload function templates that have the same name. When the compiler processes a function call in a program, it has to decide which template or ordinary function is the "best" fit for the call. Assuming the existence of themin function template introduced earlier, let’s add some ordinary functions to the mix:.
   //: C05:MinTest.cpp
   #include&lt;cstring&gt;
   #include&lt;iostream&gt;
   using std::strcmp;
   using std::cout;
   using std::endl;

   template&lt;typename T&gt; const T& min(const T& a, const T& b) {
     return (a&lt; b) ? a : b;
   }
   const char* min(const char* a, const char* b) {
     return (strcmp(a, b)&lt; 0) ? a : b;
   }
   double min(double x, double y) {
     return (x&lt; y) ? x : y;
   }

   int main() {
     const char *s2 = "say \"Ni-!\"", *s1 = "knights who";
     cout&lt;&lt; min(1, 2)&lt;&lt; endl;      // 1: 1 (template)
     cout&lt;&lt; min(1.0, 2.0)&lt;&lt; endl;  // 2: 1 (double)
     cout&lt;&lt; min(1, 2.0)&lt;&lt; endl;    // 3: 1 (double)
     cout&lt;&lt; min(s1, s2)&lt;&lt; endl;    // 4: knights who (const
                      //  char*)
     cout&lt;&lt; min&lt;&gt;(s1, s2)&lt;&lt; endl;  // 5: say "Ni-!"
                      //    (template)
   } ///:~

   In addition to the function template, this program defines two non-template functions: a C-style string version ofmin and adouble version. If the template doesn’t exist at all, the call in line 1 above have invokes thedouble version ofmin because of the standard conversion fromint todouble. Since the template can generate anint version, however, that is considered a better match (of course!); so that’s what happens. The call in line 2 is an exact match for thedouble version, of course, and the call in line 3 also invokes the same function, implicitly converting 1 to 1.0. In line 4 theconst char* version ofmin is called directly. In line 5 we force the compiler to use the template facility by appending empty angle brackets to the function name, whereupon it generates aconst char* version from the template and uses it (which is verified by the wrong answer—it’s just comparing addresses![52]). If you’re wondering why we usedusing declarations in lieu of theusing namespace std; directive, some compilers include headers behind the scenes that bring instd::min, which would conflict with our declarations of the namemin.
   As stated above, you can overload templates of the same name, as long as they can be distinguished by the compiler. You could, for example, declare amin function template that processes three arguments:
   template&lt;typename T&gt;
   const T& min(const T& a, const T& b, const T& c);

   Versions of this template will be generated only for calls tomin( ) that have three arguments of the same type.
   Taking the address of a generated function template
   In a number of situations you need to take the address of a function. For example, you may have a function that takes an argument of a pointer to another function. Of course, it’s possible that this other function might be generated from a template function, so you need some way to take that kind of address:[53] 
   //: C05:TemplateFunctionAddress.cpp
   // Taking the address of a function generated
   // from a template.

   template&lt;typename T&gt; void f(T*) {}

   void h(void (*pf)(int*)) {}

   template&lt;typename T&gt;
     void g(void (*pf)(T*)) {}

   int main() {
     // Full type specification:
     h(&f&lt;int&gt;);
     // Type deduction:
     h(&f);
     // Full type specification:
     g&lt;int&gt;(&f&lt;int&gt;);
     // Type deduction:
     g(&f&lt;int&gt;);
     // Partial (but sufficient) specification
     g&lt;int&gt;(&f);
   } ///:~

   This example demonstrates a number of issues. First, even though you’re using templates, the signatures must match. The functionh( ) takes a pointer to a function that takes anint* and returnsvoid, and that’s what the templatef produces. Second, the function that wants the function pointer as an argument can itself be a template, as in the case of the templateg.
   Inmain( ) you can see that type deduction works here too. The first call toh( ) explicitly gives the template argument forf, but sinceh( ) says that it will only take the address of a function that takes anint*, that part can be deduced by the compiler. Withg( ) the situation is even more interesting because two templates are involved. The compiler cannot deduce the type with nothing to go on, but if eitherf org is givenint, the rest can be deduced.
   An obscure issue arises when trying to pass the functionstolower ortoupper, declared in&lt;cctype&gt;, as parameters. It is possible to use these in conjunction with thetransform algorithm (which is covered in detail in the next chapter), for example, to convert a string to lower or upper case. Care must be taken, however, because there are multiple declarations for these functions. A na?ve approach would is something like this:.
   // The variables is a std::string
   transform(s.begin(), s.end(), s.begin(), tolower);

   Thetransform algorithm applies its fourth parameter (tolower in this case) to each character in the strings and places the result ins itself, thus overwriting each character ins with its lower-case equivalent. As it is written, this statement may or may not work! It fails in the following context:.
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string s("LOWER");
     transform(s.begin(),s.end(),s.begin(),tolower);
     cout&lt;&lt; s&lt;&lt; endl;
   }

   Even if your compiler let’s you get away with this, it is illegal. The reason is that the&lt;iostream&gt; header also makes available a two-argument version oftolower andtoupper:
   template&lt;class charT&gt; charT toupper(charT c,
                         const locale& loc);
   template&lt;class charT&gt; charT tolower(charT c,
                         const locale& loc);

   These function templates take a second argument of typelocale. The compiler has no way of knowing whether it should use the one-argument version oftolower defined in&lt;cctype&gt; or the one mentioned above. You can solve this problem (almost!) with a cast in the call totransform, as follows:.
     transform(s.begin(),s.end(),s.begin()
               static_cast&lt;int (*)(int)&gt;(tolower));

   (Recall thattolower andtoupper traffic inint instead ofchar.) The cast above makes clear that the single-argument version oftolower is desired. Once again, this works with some compilers, but it is not required to. The reason, albeit obscure, is that a library implementation is allowed to give "C linkage" (meaning that the function name does not contain all the auxiliary information[54] that normal C++ functions do) to functions inherited from the C language. If this is the case, the cast fails, becausetransform is a C++ function template and expects its fourth argument to have C++ linkage—and a cast is not allowed to change the linkage. What a predicament!.
   The solution is to place calls totolower in an unambiguous context. For example, you could write a function, let’s call itstrTolower( ), and place it in its own file without including&lt;iostream&gt;, like this:.
   //: C05:StrTolower.cpp {O}
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;string&gt;
   using namespace std;

   string strTolower(string s) {
     transform(s.begin(), s.end(), s.begin(), tolower);
     return s;
   } ///:~

   The header&lt;iostream&gt; is not involved here, and the compilers we use do not introduce the two-argument version oftolower in this context,[55] so there’s no problem. You can then use this function normally:.
   //: C05:Tolower.cpp
   //{L} StrTolower
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;
   string strTolower(string);

   int main() {
     string s("LOWER");
     cout&lt;&lt; strTolower(s)&lt;&lt; endl;
   } ///:~

   Another solution is to write a wrapper function template that calls the correct version oftolower explicitly:
   //: C05:ToLower2.cpp
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   template&lt;class charT&gt;
   charT strTolower(charT c) {
     return tolower(c);  // one-arg version called
   }

   int main() {
     string s("LOWER");
     transform(s.begin(),s.end(),s.begin(),&strTolower&lt;char&gt;);
     cout&lt;&lt; s&lt;&lt; endl;
   } ///:~

   This version has the advantage that it can process both wide and narrow strings since the underlying character type is a template parameter. The C++ standards committee is working on modifying the language so that the first example (without the cast) will work, and some day these workarounds can be ignored.[56] 
   Applying a function to an STL sequence
   Suppose you want to take an STL sequence container (which you’ll learn more about in subsequent chapters; for now we can just use the familiarvector) and apply a function to all the objects it contains. Because avector can contain any type of object, you need a function that works with any type ofvector:.
   //: C05:ApplySequence.h
   // Apply a function to an STL sequence container

   // 0 arguments, any type of return value:
   template&lt;class Seq, class T, class R&gt;
   void apply(Seq& sq, R (T::*f)()) {
     typename Seq::iterator it = sq.begin();
     while(it != sq.end()) {
       ((*it)-&gt;*f)();
       it++;
     }
   }

   // 1 argument, any type of return value:
   template&lt;class Seq, class T, class R, class A&gt;
   void apply(Seq& sq, R(T::*f)(A), A a) {
     typename Seq::iterator it = sq.begin();
     while(it != sq.end()) {
       ((*it)-&gt;*f)(a);
       it++;
     }
   }

   // 2 arguments, any type of return value:
   template&lt;class Seq, class T, class R,
            class A1, class A2&gt;
   void apply(Seq& sq, R(T::*f)(A1, A2),
       A1 a1, A2 a2) {
     typename Seq::iterator it = sq.begin();
     while(it != sq.end()) {
       ((*it)-&gt;*f)(a1, a2);
       it++;
     }
   }
   // Etc., to handle maximum likely arguments ///:~

   Theapply( )function template takes a reference to the container class and a pointer-to-member for a member function of the objects contained in the class. It uses an iterator to move through theStack and apply the function to every object.
   Notice that there are no STL header files (or any header files, for that matter) included inapplySequence.h, so it is actually not limited to use with an STL container. However, it does make assumptions (primarily, the name and behavior of theiterator) that apply to STL sequences.
   You can see there is more than one version ofapply( ), further illustrating overloading of function templates. Although these templates allow any type of return value (which is ignored, but the type information is required to match the pointer-to-member), each version takes a different number of arguments, and because it’s a template, those arguments can be of any type. The only limitation here is that there’s no "super template" to create templates for you; you must decide how many arguments will ever be required.
   To test the various overloaded versions ofapply( ), the classGromit[57] is created containing functions with different numbers of arguments:.
   //: C05:Gromit.h
   // The techno-dog. Has member functions
   // with various numbers of arguments.
   #include&lt;iostream&gt;

   class Gromit {
     int arf;
   public:
     Gromit(int arf = 1) : arf(arf + 1) {}
     void speak(int) {
       for(int i = 0; i&lt; arf; i++)
         std::cout&lt;&lt; "arf! ";
       std::cout&lt;&lt; std::endl;
     }
     char eat(float) {
       std::cout&lt;&lt; "chomp!"&lt;&lt; std::endl;
       return 'z';
     }
     int sleep(char, double) {
       std::cout&lt;&lt; "zzz..."&lt;&lt; std::endl;
       return 0;
     }
     void sit() {
       std::cout&lt;&lt; " Sitting...)"&lt;&lt; std::endl;
     }
   }; ///:~

   Now you can use theapply( ) template functions to apply theGromit member functions to avector&lt;Gromit*&gt;, like this:.
   //: C05:ApplyGromit.cpp
   // Test ApplySequence.h
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "ApplySequence.h"
   #include "Gromit.h"
   using namespace std;

   int main() {
     vector&lt;Gromit*&gt; dogs;
     for(size_t i = 0; i&lt; 5; i++)
       dogs.push_back(new Gromit(i));
     apply(dogs,&Gromit::speak, 1);
     apply(dogs,&Gromit::eat, 2.0f);
     apply(dogs,&Gromit::sleep, 'z', 3.0);
     apply(dogs,&Gromit::sit);
     for (size_t i = 0; i&lt; dogs.size(); ++i)
       delete dogs[i];
   } ///:~

   Although the definition ofapply( ) is somewhat complex and not something you’d ever expect a novice to understand, its use is remarkably clean and simple, and a novice could easily use it knowing onlywhat it is intended to accomplish, nothow. This is the type of division you should strive for in all your program components: The tough details are all isolated on the designer’s side of the wall. Users are concerned only with accomplishing their goals and don’t see, know about, or depend on details of the underlying implementation. We’ll explore even more flexible ways to apply functions to sequences in the next chapter.
   Partial ordering of function templates
   We mentioned earlier that an ordinary function overload ofmin( ) is preferable to using the template. If a function already exists to match a function call, why generate another? In the absence of ordinary functions, however, it is possible that overloaded function templates can lead to ambiguities. To minimize the chances of this, an ordering is defined for function templates that chooses themost specialized template, if such exists. A function template is considered more specialized than another if every possible list of arguments that matches it also matches the other, but not the other way around. Consider the following function template declarations, taken from an example in the C++ standard document:.
   template&lt;class T&gt; void f(T);
   template&lt;class T&gt; void f(T*);
   template&lt;class T&gt; void f(const T*);

   The first template can be matched with any type. The second template is more specialized than the first because only pointer types match it. In other words, you can look upon the set of possible calls that match the second template as a subset of the first. A similar relationship exists between the second and third template declarations above: the third can only be called for pointers toconst, but the second accommodates any pointer type. The following program illustrates these rules.
   //: C05:PartialOrder.cpp
   // Reveals Ordering of Function Templates
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   void f(T) {
     cout&lt;&lt; "T\n";
   }

   template&lt;class T&gt;
   void f(T*) {
     cout&lt;&lt; "T*\n";
   }

   template&lt;class T&gt;
   void f(const T*) {
     cout&lt;&lt; "const T*\n";
   }

   int main() {
     f(0);            // T
     int i = 0;
     f(&i);           // T*
     const int j = 0;
     f(&j);           // const T*
   } ///:~

   The callf(&i) certainly matches the first template, but since the second is more specialized, it is called. The third can’t be called in this case since the pointer is not a pointer toconst. The callf(&j) matches all three templates (for example,T would beconst int in the second template), but again, the third template is more specialized, so it is used instead.
   If there is no "most specialized" template among a set of overloaded function templates, an ambiguity remains and the compiler will report an error. That is why this feature is called a "partial ordering"—it may not be able to resolve all possibilities. Similar rules exist for class templates (see the section "Partial specialization" below).
   Template specialization
   The termspecialization has a specific, template-related meaning in C++. A template definition is, by its very nature, ageneralization, because it describes a family of functions or classes in general terms. When template arguments are supplied, the result is a specialization of the template, because it fixes a unique instance out of the many possible instances of the family of functions or classes. Themin function template seen at the beginning of this chapter is a generalization of a minimum-finding function, because the type of its parameters is not specified. When you supply the type for the template parameter, whether explicitly or implicitly via argument deduction, the resultant code generated by the compiler (for example,min&lt;int&gt;) is a specialization of the template. The code generated is also considered aninstantiation of the template, of course, as are all code bodies generated by the template facility.
   Explicit specialization
   You can also provide the code yourself for a given template specialization, should the need arise. Providing your own template specializations is often needed with class templates, but we will begin with themin function template to introduce the syntax.
   Recall that inMinTest.cpp earlier in this chapter we introduced the following ordinary function:
   const char* min(const char* a, const char* b) {
     return (strcmp(a, b)&lt; 0) ? a : b;
   }

   This was so that a call tomin would compare strings and not addresses. Although it would provide no advantage in this case, we could define instead aconst char* specialization formin, as in the following program:.
   //: C05:MinTest2.cpp
   #include&lt;cstring&gt;
   #include&lt;iostream&gt;
   using std::strcmp;
   using std::cout;
   using std::endl;

   template&lt;class T&gt; const T& min(const T& a, const T& b) {
     return (a&lt; b) ? a : b;
   }
   // An explicit specialization of the min template
   template&lt;&gt;
   const char* const& min&lt;const char*&gt;(const char* const& a,
                        const char* const& b) {
     return (strcmp(a, b)&lt; 0) ? a : b;
   }

   int main() {
     const char *s2 = "say \"Ni-!\"", *s1 = "knights who";
     cout&lt;&lt; min(s1, s2)&lt;&lt; endl;
     cout&lt;&lt; min&lt;&gt;(s1, s2)&lt;&lt; endl;
   } ///:~

   The "template&lt;&gt;" prefix tells the compiler that what follows is a specialization of a template. The type for the specialization must appear in angle brackets immediately following the function name, as it normally would in an explicitly-specified call. Note that wecarefully substituteconst char* forT in the explicit specialization. Whenever the original template specifiesconst T, thatconst modifies thewhole typeT. It is the pointer to aconst char* that isconst. Therefore we must writeconst char* const in place ofconst T in the specialization. When the compiler sees a call tomin withconst char* arguments in the program, it will instantiate ourconst char* version ofmin so it can be called. The two calls tomin in this program call the same specialization ofmin.
   Explicit specializations tend to be more useful for class templates than for function templates. When you provide a full specialization for a class template, though, you may need to implement all the member functions. This is because you are providing a separate class, and client code may expect the complete interface to be implemented.
   The standard library has an explicit specialization forvector when it is used to hold objects of typebool. As you saw earlier in this chapter, the declaration for the primaryvector class template is:
   template&lt;class T, class Allocator = allocator&lt;T&gt;&gt;
   class vector {…};

   To specialize for objects of typebool, you could declare an explicit specialization as follows:
   template&lt;&gt;
   class vector&lt; bool, allocator&lt;bool&gt;&gt; {…};

   Again, this is quickly recognized as a full, explicit specialization because of thetemplate&lt;&gt; prefix and because all the primary template’s parameters are satisfied by the argument list appended to the class name. The purpose forvector&lt;bool&gt; is to allow library implementations to save space by packing bits into integers.[58] 
   It turns out thatvector&lt;bool&gt; is a little more flexible than we have described, as seen in the next section.
   Partial Specialization
   Class templates can also be partially specialized, meaning that at least one of the template parameters is left "open" in some way in the specialization. This is actually whatvector&lt;bool&gt; does; it specifies the object type (bool), but leaves the allocator type unspecified. Here is the actual declaration ofvector&lt;bool&gt;:
   template&lt;class Allocator&gt;
   class vector&lt;bool, Allocator&gt;;

   You can recognize a partial specialization because non-empty parameter lists appear in angle brackets both after the template keyword (the unspecified parameters) and after the class (the specified arguments). Because of the wayvector&lt;bool&gt; is defined, a user can provide a custom allocator type, even though the contained type ofbool is fixed. In other words, specialization, and partial specialization in particular, constitute a sort of "overloading" for class templates.
   Partial ordering of class templates
   The rules that determine which template is selected for instantiation are similar to the partial ordering for function templates—the "most specialized" template is selected. An illustration follows. (The string in eachf( ) member function below explains the role of each template definition.).
   //: C05:PartialOrder2.cpp
   // Reveals partial ordering of class templates
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T, class U&gt; class C {
   public:
     void f() {
       cout&lt;&lt; "Primary Template\n";
     }
   };

   template&lt;class U&gt; class C&lt;int, U&gt; {
   public:
     void f() {
       cout&lt;&lt; "T == int\n";
     }
   };

   template&lt;class T&gt; class C&lt;T, double&gt; {
   public:
     void f() {
       cout&lt;&lt; "U == double\n";
     }
   };

   template&lt;class T, class U&gt; class C&lt;T*, U&gt; {
   public:
     void f() {
       cout&lt;&lt; "T* used \n";
     }
   };

   template&lt;class T, class U&gt; class C&lt;T, U*&gt; {
   public:
     void f() {
       cout&lt;&lt; "U* used\n";
     }
   };

   template&lt;class T, class U&gt; class C&lt;T*, U*&gt; {
   public:
     void f() {
       cout&lt;&lt; "T* and U* used\n";
     }
   };

   template&lt;class T&gt; class C&lt;T, T&gt; {
   public:
     void f() {
       cout&lt;&lt; "T == U\n";
     }
   };

   int main() {
     C&lt;float, int&gt;().f();    // 1: Primary template
     C&lt;int, float&gt;().f();    // 2: T == int
     C&lt;float, double&gt;().f(); // 3: U == double
     C&lt;float, float&gt;().f();  // 4: T == U
     C&lt;float*, float&gt;().f(); // 5: T* used [T is float]
     C&lt;float, float*&gt;().f(); // 6: U* used [U is float]
     C&lt;float*, int*&gt;().f();  // 7: T* and U* used [float,int]

     // The following are ambiguous:
   //   8: C&lt;int, int&gt;().f();
   //   9: C&lt;double, double&gt;().f();
   //  10: C&lt;float*, float*&gt;().f();
   //  11: C&lt;int, int*&gt;().f();
   //  12: C&lt;int*, int*&gt;().f();
   } ///:~

   As you can see, you can partially specify template parameters according to whether they are pointer types, or whether they are equal. When theT* specialization is used, such as is the case in line 5,T itself is not the top-level pointer type that was passed—it is the type that the pointer refers to (float, in this case). TheT* specification is a pattern to allow matching against pointer types. If you were to useint** as the first template argument,T would beint*. Line 8 is ambiguous because having the first parameter as anint vs. having the two parameters equal are independent issues—one is not more specialized than the other. Similar logic applies to lines 9 through 12.
   A practical example
   You can easily derive from a class template, and you can create a new template that instantiates and inherits from an existing template. If thevectortemplate does most everything you want, for example, but in a certain application you’d also like a version that can sort itself, you can easily reuse thevector code. The following example derives fromvector&lt;T&gt; and adds sorting.
   //: C05:Sorted.h
   // Template specialization
   #ifndef SORTED_H
   #define SORTED_H
   #include&lt;string&gt;
   #include&lt;vector&gt;

   template&lt;class T&gt;
   class Sorted : public std::vector&lt;T&gt; {
   public:
     void sort();
   };

   template&lt;class T&gt;
   void Sorted&lt;T&gt;::sort() { // A simple sort
     for(int i = size(); i&gt; 0; i--)
       for(int j = 1; j&lt; i; j++)
         if(at(j-1)&gt; at(j)) {
           T t = at(j-1);
           at(j-1) = at(j);
           at(j) = t;
         }
   }

   // Partial specialization for pointers:
   template&lt;class T&gt;
   class Sorted&lt;T*&gt; : public std::vector&lt;T*&gt; {
   public:
     void sort();
   };

   template&lt;class T&gt;
   void Sorted&lt;T*&gt;::sort() {
     for(int i = size(); i&gt; 0; i--)
       for(int j = 1; j&lt; i; j++)
         if(*at(j-1)&gt; *at(j)) {
           T* t = at(j-1);
           at(j-1) = at(j);
           at(j) = t;
         }
   }

   // Full specialization for char*
   // (Made inline here for convenience–
   //  normally would place function body in separate file
   //  and only leave declaration here)
   template&lt;&gt;
   inline void Sorted&lt;char*&gt;::sort() {
     for(int i = size(); i&gt; 0; i--)
       for(int j = 1; j&lt; i; j++)
         if(std::strcmp(at(j-1), at(j))&gt; 0) {
           char* t = at(j-1);
           at(j-1) = at(j);
           at(j) = t;
         }
   }
   #endif // SORTED_H ///:~

   TheSorted template imposes a restriction on all but one of the classes for which it is instantiated: they must contain a&gt; operator. It works correctly only with non-pointer objects (including objects of built-in types). The full specialization compares the elements usingstrcmp( ) to sort vectors ofchar* according to the null-terminated strings to which they refer.
   Here’s a driver forSorted.h that uses the randomizer introduced earlier in the chapter:.
   //: C05:Sorted.cpp
   //{bor} (because of bitset in Urand.h)
   // Testing template specialization
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include "Sorted.h"
   #include "Urand.h"
   using namespace std;

   #define asz(a) (sizeof a / sizeof a[0])

   char* words[] = {
     "is", "running", "big", "dog", "a",
   };
   char* words2[] = {
     "this", "that", "theother",
   };

   int main() {
     Sorted&lt;int&gt; is;
     Urand&lt;47&gt; rand;
     for(size_t i = 0; i&lt; 15; i++)
       is.push_back(rand());
     for(size_t i = 0; i&lt; is.size(); i++)
       cout&lt;&lt; is[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
     is.sort();
     for(size_t i = 0; i&lt; is.size(); i++)
       cout&lt;&lt; is[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;

     // Uses the template partial specialization:
     Sorted&lt;string*&gt; ss;
     for(size_t i = 0; i&lt; asz(words); i++)
       ss.push_back(new string(words[i]));
     for(size_t i = 0; i&lt; ss.size(); i++)
       cout&lt;&lt; *ss[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
     ss.sort();
     for(size_t i = 0; i&lt; ss.size(); i++) {
       cout&lt;&lt; *ss[i]&lt;&lt; ' ';
       delete ss[i];
     }
     cout&lt;&lt; endl;

     // Uses the full char* specialization:
     Sorted&lt;char*&gt; scp;
     for(size_t i = 0; i&lt; asz(words2); i++)
       scp.push_back(words2[i]);
     for(size_t i = 0; i&lt; scp.size(); i++)
       cout&lt;&lt; scp[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
     scp.sort();
     for(size_t i = 0; i&lt; scp.size(); i++)
       cout&lt;&lt; scp[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
   } ///:~

   Each of the template instantiations above uses a different version of the template.Sorted&lt;int&gt; uses the primary template.Sorted&lt;string*&gt; uses the partial specialization for pointers. Last,Sorted&lt;char*&gt; uses the full specialization forchar*. Without this full specialization, you could be fooled into thinking that things were working correctly because thewords array would still sort out to "a big dog is running" since the partial specialization would end up comparing the first character of each array. However,words2 would not sort correctly.
   Preventing template code bloat
   Whenever a class template is instantiated, the code from the class definition for the particular specialization is generated, along with all the member functions that are called in the program. Only the member functions that are actually called are generated. This is a good thing, as the following program makes clear:.
   //: C05:DelayedInstantiation.cpp
   // Member functions of class templates are not
   // instantiated until they're needed.

   class X {
   public:
     void f() {}
   };

   class Y {
   public:
     void g() {}
   };

   template&lt;typename T&gt; class Z {
     T t;
   public:
     void a() { t.f(); }
     void b() { t.g(); }
   };

   int main() {
     Z&lt;X&gt; zx;
     zx.a(); // Doesn't create Z&lt;X&gt;::b()
     Z&lt;Y&gt; zy;
     zy.b(); // Doesn't create Z&lt;Y&gt;::a()
   } ///:~

   Here, even though the templateZ purports to use bothf( ) andg( ) member functions ofT, the fact that the program compiles shows you that it only generatesZ&lt;X&gt;::a( ) when it is explicitly called forzx. (IfZ&lt;X&gt;::b( ) were also generated at the same time, a compile-time error message would be generated, because it would attempt to callX::g( ), which doesn’t exist.) Similarly, the call tozy.b( ) doesn’t generateZ&lt;Y&gt;::a( ). As a result, theZ template can be used withX andY; whereas if all the member functions were generated when the class was first created the use of many templates would significantly limited.
   Suppose you have a container, aStack say, and you use specializations forint,int*, andchar*. Three versions ofStack code will be generated and linked as part of your program. One of the reasons for using a template in the first place is so you don’t have to replicate code by hand; but code still gets replicated—it’s just the compiler that does it instead of you. You can factor the bulk of the implementation for storing pointer types into a single class by using a combination of full and partial specialization. The key is to fully specialize forvoid* and then derive all other pointer types from thevoid* implementation so the common code can be shared. The program below illustrates this technique.
   //: C05:Nobloat.h
   // Shares code for storing pointers in a Stack
   #ifndef NOBLOAT_H
   #define NOBLOAT_H
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;cstring&gt;

   // The primary template
   template&lt;class T&gt;
   class Stack {
     T* data;
     std::size_t count;
     std::size_t capacity;
     enum {INIT = 5};
   public:
     Stack() {
       count = 0;
       capacity = INIT;
       data = new T[INIT];
     }
     void push(const T& t) {
       if (count == capacity) {
         // Grow array store
         std::size_t newCapacity = 2*capacity;
         T* newData = new T[newCapacity];
         for (size_t i = 0; i&lt; count; ++i)
           newData[i] = data[i];
         delete [] data;
         data = newData;
         capacity = newCapacity;
       }
       assert(count&lt; capacity);
       data[count++] = t;
     }
     void pop() {
       assert(count&gt; 0);
       --count;
     }
     T top() const {
       assert(count&gt; 0);
       return data[count-1];
     }
     size_t size() const {return count;}
   };

   // Full specialization for void*
   template&lt;&gt;
   class Stack&lt;void *&gt; {
     void** data;
     std::size_t count;
     std::size_t capacity;
     enum {INIT = 5};
   public:
     Stack() {
       count = 0;
       capacity = INIT;
       data = new void*[INIT];
     }
     void push(void* const& t) {
       if (count == capacity) {
         std::size_t newCapacity = 2*capacity;
         void** newData = new void*[newCapacity];
         std::memcpy(newData, data, count*sizeof(void*));
         delete [] data;
         data = newData;
         capacity = newCapacity;
       }
       assert(count&lt; capacity);
       data[count++] = t;
     }
     void pop() {
       assert(count&gt; 0);
       --count;
     }
     void* top() const {
       assert(count&gt; 0);
       return data[count-1];
     }
     std::size_t size() const {return count;}
   };

   // Partial specialization for other pointer types
   template&lt;class T&gt;
   class Stack&lt;T*&gt; : private Stack&lt;void *&gt; {
     typedef Stack&lt;void *&gt; Base;
   public:
     void push(T* const& t) {Base::push(t);}
     void pop() {Base::pop();}
     T* top() const {return static_cast&lt;T*&gt;(Base::top());}
     std::size_t size() {return Base::size();}
   };
   #endif // NOBLOAT_H ///:~.

   This simple stack expands as it fills its capacity. Thevoid* specialization stands out as a full specialization by virtue of thetemplate&lt;&gt; prefix (that is, the template parameter list is empty). As mentioned earlier, it is necessary to implement all member functions in a class template specialization. The savings occurs with all other pointer types. The partial specialization for other pointer types derives fromStack&lt;void*&gt; privately, since we are merely usingStack&lt;void*&gt; for implementation purposes, and do not wish to expose any of its interface directly to the user. The member functions for each pointer instantiation are small forwarding functions to the corresponding functions inStack&lt;void*&gt;. Hence, whenever a pointer type other thanvoid* is instantiated, it is a fraction of the size it would have been had the primary template alone been used.[59] Here is a driver program:.
   //: C05:NobloatTest.cpp
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include "Nobloat.h"
   using namespace std;

   template&lt;class StackType&gt;
   void emptyTheStack(StackType& stk) {
     while (stk.size()&gt; 0) {
       cout&lt;&lt; stk.top()&lt;&lt; endl;
       stk.pop();
     }
   }
   // An overload for emptyTheStack (not a specialization!)
   template&lt;class T&gt;
   void emptyTheStack(Stack&lt;T*&gt;& stk) {
     while (stk.size()&gt; 0) {
       cout&lt;&lt; *stk.top()&lt;&lt; endl;
       stk.pop();
     }
   }

   int main() {
     Stack&lt;int&gt; s1;
     s1.push(1);
     s1.push(2);
     emptyTheStack(s1);

     Stack&lt;int *&gt; s2;
     int i = 3;
     int j = 4;
     s2.push(&i);
     s2.push(&j);
     emptyTheStack(s2);
   } ///:~

   For convenience we have included twoemptyStack function templates. Since function templates don’t support partial specialization, we provide overloaded templates. The second version ofemptyStack is more specialized than the first, so it is chosen whenever pointer types are used. Three class templates are instantiated in this program:Stack&lt;int&gt;,Stack&lt;void*&gt;, andStack&lt;int*&gt;.Stack&lt;void*&gt; is implicitly instantiated becauseStack&lt;int*&gt; derives from it. If a program uses instantiations for many pointer types, the savings in code size over just using a singleStack template can be substantial.
   Name lookup issues
   When the compiler encounters an identifier it must determine the type and scope (and in the case of variables, the lifetime) of the entity the identifier represents. This is common knowledge among software developers, but the plot thickens when templates are involved. Because not everything is known about a template when its definition is first seen by the compiler, the compiler must hold off until the template is instantiated before it can determine whether it is being used properly. This predicament leads to a two-phase process for template compilation.
   Names in templates
   In the first phase the compiler parses the template definition looking for obvious syntax errors and resolving all the names it can. The names it can resolve during parsing are those that do not depend on template parameters, which the compiler takes care of through normal name lookup means (and also through argument-dependent lookup, discussed below, if necessary). The names it can’t resolve are the so-calleddependent names, which are names that in some way depend on template parameters. These can’t be resolved until the template is instantiated with its actual arguments. Instantiation, therefore, is the second phase of template compilation. During this second phase, the compiler determines whether an explicit specialization of the template in question needs to be used instead of the primary template.
   Before you see an example, two more terms need to be defined. Aqualified name is a name with a class-name prefix, a name with an object name and a dot operator, or a name with a pointer to an object and an arrow operator. Examples of qualified names are found in the following expressions:.
   MyClass::f();
   x.f();
   p-&gt;f();

   We have used qualified names many times in this book, and most recently in connection with thetypename keyword. These are called qualified names because the target names (likef above) are explicitly associated with a class, which tells the compiler where to look for the declarations of those names.
   The other term to discuss isargument-dependent lookup[60] (ADL), which is a technique originally designed to simplify using non-member function calls (including operators) declared in namespaces. Consider the following simple code excerpt:.
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   //…
     std::string s("hello");
     std::cout&lt;&lt; s&lt;&lt; std::endl;

   Note that there is nousing namespace std; directive, which is the typical practice inside header files, for example. Without such a directive, it is necessary to use thestd:: qualifier on the items that are in thestd namespace. We have, however, not qualified everything fromstd that we are using. Can you see what we have left unqualified?.
   We have not specified which operator functions to use. We want the following to happen, but we don’t want to have to type it!
   std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout,s),std::endl);

   To make the original output statement work as desired, ADL specifies that when an unqualified function call appears and its declaration is not in (normal) scope, the namespaces (or class scopes) of each of its arguments are searched for a matching function declaration. In the original statement, the first function call is:.
   operator&lt;&lt;(std::cout, s);

   Since there is no such function in scope in our original excerpt, the compiler notes that this function’s first argument (std::cout) is in the namespacestd; so it adds that namespace to the list of scopes to search for a unique function that best matches the signatureoperator&lt;&lt;(std::ostream&, std::string). It finds this function declared in thestd namespace via the&lt;string&gt; header, so that is the function that is called. Namespaces would be very inconvenient without ADL. (But note that, in general, ADL brings inall declarations of the name in question from all eligible namespaces—if there is no best match, an ambiguity will result.) To turn off ADL, you can enclose the function name in parentheses:.
   (f)(x, y);  // ADL suppressed

   Now consider the following program, from a presentation by Herb Sutter:
   // Lookup.cpp
   // Only works on EDG and Metrowerks (special option)
   #include&lt;iostream&gt;
   using std::cout;

   void f(double) { cout&lt;&lt; "f(double)\n"; }

   template&lt;class T&gt;
   class X {
   public:
     void g() { f(1); }
   };

   void f(int) { cout&lt;&lt; "f(int)\n"; }

   int main() {
     X&lt;int&gt;().g();
   }

   The only compiler we have that gets this correct right out of the box is the Edison Design Group front end. (A number of compilers use this front end, including Comeau C++.) The output should be:.
   f(double)

   becausef is a non-dependent name that can be resolved early by looking in the context where the template is defined, when onlyf(double) is in scope. Unfortunately, there is a lot of code in existence that depends on the non-standard behavior of binding the call tof(1) insideg( ) to the latterf(int), so compiler writers have been reluctant to make the change. (Some compilers, such as the Metrowerks compiler, have an option to enable the correct lookup behavior.).
   Here is a more detailed example, also based on an example from Herb Sutter:
   //: C05:Lookup2.cpp
   //{-bor}
   //{-g++}
   // Microsoft: use option–Za (ANSI mode)
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using std::cout;
   using std::endl;

   void g() { cout&lt;&lt; "global g()\n"; }

   template&lt;class T&gt;
   class Y {
   public:
     void g() { cout&lt;&lt; "Y&lt;"&lt;&lt; typeid(T).name()
      &lt;&lt; "&gt;::g()\n"; }
     void h() { cout&lt;&lt; "Y&lt;"&lt;&lt; typeid(T).name()
      &lt;&lt; "&gt;::h()\n"; }
     typedef int E;
   };

   typedef double E;

   template&lt;class T&gt;
   void swap(T& t1, T& t2) {
     cout&lt;&lt; "global swap\n";
     T temp = t1;
     t1 = t2;
     t2 = temp;
   }

   template&lt;class T&gt;
   class X : public Y&lt;T&gt; {
   public:
     E f() {
       g();
       this-&gt;h();
       T t1 = T(), t2 = T(1);
       cout&lt;&lt; t1&lt;&lt; endl;
       swap(t1, t2);
       std::swap(t1, t2);
       cout&lt;&lt; typeid(E).name()&lt;&lt; endl;
       return E(t2);
     }
   };

   int main() {
     X&lt;int&gt; x;
     cout&lt;&lt; x.f()&lt;&lt; endl;
   } ///:~

   The output from this program should be:
   global g()
   Y&lt;int&gt;::h()
   0
   global swap
   double
   1

   Looking at the declarations inside ofX::f( ), we observe the following:
   ·         The return type ofX::f( ), which isE, is not a dependent name, so it is looked up when the template is parsed, and thetypedef namingE as adouble is found. This may seem strange, since with non-template classes the declaration ofE in the base class would be found first, but those are the rules. (The base class,Y, is adependent base class, so it can’t be searched at template definition time).
   ·         The call tog( ) is also non-dependent, since there is no mention ofT. Ifg had parameters that were of class type of defined in another namespace, ADL would take over, since there is nog with parameters in scope. As it is, this call matches the global declaration ofg( ).
   ·         The callthis-&gt;h( ) is a qualified name, and the object that qualifies it (this) refers to the current object, which is of typeX, which in turn depends on the nameY&lt;T&gt; by inheritance. There is no functionh( ) inside ofX, so lookup will naturally want to search the scope ofX’s base class,Y&lt;T&gt;. Since this is a dependent name, it is looked up at instantiation time, whenY&lt;T&gt; can be reliably known (including any potential specializations that might have been written after the definition ofX); so it callsY&lt;int&gt;::h( ).
   ·         The declarations oft1 andt2 are dependent, of course.
   ·         The call tooperator&lt;&lt;(cout, t1) is dependent, sincet1 is of typeT. This is looked up later whenT isint, and the inserter forint is found instd.
   ·         The unqualified call toswap( ) is dependent because its arguments are of typeT. This ultimately causes a globalswap(int&, int&) to be instantiated, of course.
   ·         The qualified call tostd::swap( ) isnot dependent, becausestd is a fixed namespace; so the compiler knows to look there for the proper declaration. (The qualifier on the left of the "::" must mention a template parameter for a qualified name to be considered dependent.) Thestd::swap( ) function template later generatesstd::swap(int&, int&), at instantiation time. No more dependent names remain inX&lt;T&gt;::f( ).
   To clarify and summarize: name lookup is done at the point of instantiation if the name is dependent, except that for unqualified dependent names the normal name lookup is also attempted early, at the point of definition. All non-dependent names in templates are looked up early, at the time the template definition is parsed. (If necessary, another lookup occurs at instantiation time, when the type of the actual argument is known.).
   (Whew!) If you have studied this example to the point that you understand it, prepare yourself for yet another surprise in the next section whenfriend declarations enter the picture.
   Templates and friends
   A friend function declaration inside a class allows a non-member function to access non-public members of that class. If the friend function name is qualified, it will of course be found in the namespace or class that qualifies it. If it is unqualified, however, the compiler must make an assumption about where the definition of the friend function will be, since all identifiers must have a unique scope. The expectation is that the function will be defined in the nearest enclosing namespace (non-class) scope that contains the class granting friendship. Often this is just the global scope. The following non-template example clarifies this issue.
   //: C05:FriendScope.cpp
   #include&lt;iostream&gt;
   using namespace std;

   class Friendly {
     int i;
   public:
     Friendly(int theInt) { i = theInt; }
     friend void f(const Friendly&); // needs global def.
     void g() { f(*this); }
   };

   void h() {
     f(Friendly(1));  // uses ADL
   }

   void f(const Friendly& fo) {  // definition of friend
     cout&lt;&lt; fo.i&lt;&lt; endl;
   }

   int main() {
     h();// prints 1
     Friendly(2).g();   // prints 2
   } ///:~

   The declaration off( ) inside theFriendly class is unqualified, so the compiler will expect to be able to eventually link that declaration to a definition at file scope (the namespace scope that containsFriendly in this case). That definition appears after the definition of the functionh( ). The linking of the call tof( ) insideh( ) to the same function is a separate matter, however. This is resolved by ADL. Since the argument off( ) insideh( ) is aFriendly object, theFriendly class is searched for a declaration off( ), which succeeds. If the call weref(1) instead (which makes some sense since 1 can be implicitly converted toFriendly(1)), the call should fail, since there is no hint of where the compiler should look for the declaration off( ). The EDG compiler correctly complains thatf is undefined in that case.
   Now suppose thatFriendly andf are both templates, as in the following program.
   //: C05:FriendScope2.cpp
   #include&lt;iostream&gt;
   using namespace std;
   // Necessary forward declarations
   template&lt;class T&gt;
   class Friendly;
   template&lt;class T&gt;
   void f(const Friendly&lt;T&gt;&);

   template&lt;class T&gt;
   class Friendly {
     T t;
   public:
     Friendly(const T& theT) : t(theT) {}
     friend void f&lt;&gt;(const Friendly&lt;T&gt;&);
     void g() { f(*this); }
   };

   void h() {
     f(Friendly&lt;int&gt;(1));
   }

   template&lt;class T&gt;
   void f(const Friendly&lt;T&gt;& fo) {
     cout&lt;&lt; fo.t&lt;&lt; endl;
   }

   int main() {
     h();
     Friendly&lt;int&gt;(2).g();
   } ///:~

   First notice that angle brackets in the declaration off insideFriendly. This is necessary to tell the compiler thatf is a template. Otherwise, the compiler will look for an ordinary function namedf and of course not find it. We could have inserted the template parameter (&lt;T&gt;) in the brackets, but it is easily deduced from the declaration.
   The forward declaration of the function templatef before the class definition is necessary, even though it wasn’t in the previous example whenf was a not a template; the language specifies that friend function templates must be previously declared. Of course, to properly declaref,Friendly must also have been declared, sincef takes aFriendly argument, hence the forward declaration ofFriendly in the beginning. We could have placed the full definition off right after the initial declaration ofFriendly instead of separating its definition and declaration, but we chose instead to leave it in a form that more closely resembles the previous example.
   One last option remains for using friends inside templates: fully define them inside the class itself. Here is how the previous example would appear with that change:
   //: C05:FriendScope3.cpp
   //{-bor}
   // Microsoft: use the -Za (ANSI-compliant) option
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   class Friendly {
     T t;
   public:
     Friendly(const T& theT) : t(theT) {}
     friend void f(const Friendly&lt;T&gt;& fo) {
       cout&lt;&lt; fo.t&lt;&lt; endl;
   }
     void g() { f(*this); }
   };

   void h() {
     f(Friendly&lt;int&gt;(1));
   }

   int main() {
     h();
     Friendly&lt;int&gt;(2).g();
   } ///:~

   There is an important difference between this and the previous example:f is not a template here, but is an ordinary function. (Remember that angle brackets were necessary before to imply thatf was a template.) Every time theFriendly class template is instantiated, a new, ordinary function overload is created that takes an argument of the currentFriendly specialization. This is what Dan Saks has called "making new friends."[61] This is the most convenient way to define friend functions for templates.
   To make this perfectly clear, suppose you have a class template to which you want to add non-member operators as friends. Here is a class template that simply holds a generic value:
   template&lt;class T&gt;
   class Box {
     T t;
   public:
     Box(const T& theT) : t(theT) {}
   };

   Without understanding the likes of the previous examples in this section, novices find themselves frustrated because they can’t get a simple stream output inserter to work. If you don’t define your operators inside the definition ofBox, you must provide the forward declarations we showed earlier:.
   //: C05:Box1.cpp
   // Defines template operators
   #include&lt;iostream&gt;
   using namespace std;
   // Forward declarations
   template&lt;class T&gt;
   class Box;
   template&lt;class T&gt;
   Box&lt;T&gt; operator+(const Box&lt;T&gt;&, const Box&lt;T&gt;&);
   template&lt;class T&gt;
   ostream& operator&lt;&lt;(ostream&, const Box&lt;T&gt;&);

   template&lt;class T&gt;
   class Box {
     T t;
   public:
     Box(const T& theT) : t(theT) {}
     friend Box operator+&lt;&gt;(const Box&lt;T&gt;&, const Box&lt;T&gt;&);
     friend ostream& operator&lt;&lt;&lt;&gt;(ostream&, const Box&lt;T&gt;&);
   };

   template&lt;class T&gt;
   Box&lt;T&gt; operator+(const Box&lt;T&gt;& b1, const Box&lt;T&gt;& b2) {
     return Box&lt;T&gt;(b1.t + b2.t);
   }

   template&lt;class T&gt;
   ostream& operator&lt;&lt;(ostream& os, const Box&lt;T&gt;& b) {
     return os&lt;&lt; '['&lt;&lt; b.t&lt;&lt; ']';
   }

   int main() {
     Box&lt;int&gt; b1(1), b2(2);
     cout&lt;&lt; b1 + b2&lt;&lt; endl;  // [3]
   //  cout&lt;&lt; b1 + 2&lt;&lt; endl; // no implicit conversions!
   } ///:~

   Here we are defining both an addition operator and an output stream operator. The main program reveals a disadvantage of this approach: you can’t depend on implicit conversions (see the expressionb1 + 2) because templates do not provide them. Using the in-class, non-template approach is shorter and more robust:.
   //: C05:Box2.cpp
   // Defines non-template operators
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   class Box {
     T t;
   public:
     Box(const T& theT) : t(theT) {}
     friend Box operator+(const Box&lt;T&gt;& b1,
             const Box&lt;T&gt;& b2) {
       return Box&lt;T&gt;(b1.t + b2.t);
     }
     friend ostream& operator&lt;&lt;(ostream& os,
                   const Box&lt;T&gt;& b) {
       return os&lt;&lt; '['&lt;&lt; b.t&lt;&lt; ']';
     }
   };

   int main() {
     Box&lt;int&gt; b1(1), b2(2);
     cout&lt;&lt; b1 + b2&lt;&lt; endl;  // [3]
     cout&lt;&lt; b1 + 2&lt;&lt; endl;   // [3]
   } ///:~

   Because the operators are normal functions (overloaded for each specialization ofBox—justint in this case, of course), implicit conversions are applied as normal; so the expressionb1 + 2 is valid.
   Friend templates
   You can be precise as to which specializations of a template are friends of a class. In the examples in the previous section, only the specialization of the function templatef with the same type that specializedFriendly was a friend. For example, only the specializationf&lt;int&gt;(const Friendly&lt;int&gt;&) is a friend of the classFriendly&lt;int&gt;. This was accomplished by using the template parameter forFriendly to specializef in its friend declaration. If we had wanted to, we could have made a particular, fixed specialization off a friend to all instances ofFriendly, like this:.
   // Inside Friendly:
     friend void f&lt;&gt;(const Friendly&lt;double&gt;&);

   By usingdouble instead ofT, thedouble specialization off has access to the non-public members of anyFriendly specialization. The specializationf&lt;double&gt;( ) still isn’t instantiated unless it is explicitly called, of course.
   Likewise, if you were to declare a non-template function with no parameters dependent onT, that single function would be a friend to all instances ofFriendly:.
   // Inside of Friendly:
     friend void g(int);  // g(int) befriends all Friendly’s

   As always, sinceg(int) is unqualified, it must be defined at file scope (the namespace scope containingFriendly).
   It is also possible to arrange for all specializations off to be friends for all specializations ofFriendly, with a so-calledfriend template, as follows:
   template&lt;class T&gt;
   class Friendly {
     template&lt;class U&gt; friend void f&lt;&gt;(const Friendly&lt;U&gt;&);

   Since the template argument for the friend declaration is independent ofT, any combination ofT andU is allowed, achieving the friendship objective. Like member templates, friend templates can appear within non-template classes as well.
   Template programming idioms
   Since language is a tool of thought, new language features tend to spawn new programming techniques. In this section we cover some commonly-used template programming idioms that have emerged in the years since templates were added to the C++ language.[62] 
   Traits
   The traits template technique, pioneered by Nathan Myers, is a means of bundling type-dependent declarations together. In essence, using traits allows you to "mix and match" certain types and values with contexts that use them in a flexible manner, while keeping your code readable and maintainable.
   The simplest example of a traits template is thenumeric_limits class template defined in&lt;limits&gt;. The primary template is defined as follows:
   template&lt;class T&gt; class numeric_limits {
   public:
     static const bool is_specialized = false;
     static T min() throw();
     static T max() throw();
     static const int digits = 0;
     static const int digits10 = 0;
     static const bool is_signed = false;
     static const bool is_integer = false;
     static const bool is_exact = false;
     static const int radix = 0;
     static T epsilon() throw();
     static T round_error() throw();
     static const int min_exponent = 0;
     static const int min_exponent10 = 0;
     static const int max_exponent = 0;
     static const int max_exponent10 = 0;
     static const bool has_infinity = false;
     static const bool has_quiet_NaN = false;
     static const bool has_signaling_NaN = false;
     static const float_denorm_style has_denorm =
                      denorm_absent;
     static const bool has_denorm_loss = false;
     static T infinity() throw();
     static T quiet_NaN() throw();
     static T signaling_NaN() throw();
     static T denorm_min() throw();
     static const bool is_iec559 = false;
     static const bool is_bounded = false;
     static const bool is_modulo = false;
     static const bool traps = false;
     static const bool tinyness_before = false;
     static const float_round_style round_style =
                     round_toward_zero;
   };

   The&lt;limits&gt; header defines specializations for all fundamental, numeric types (in which case the memberis_specialized is set totrue). To obtain the base for thedouble version of your floating-point number system, for example, you can use the expressionnumeric_limits&lt;double&gt;::radix. To find the smallest integer value available, you can usenumeric_limits&lt;int&gt;::min( ). Not all members ofnumeric_limits apply to all fundamental types, of course. (For example,epsilon( ) is only for floating-point types.).
   The values that will always be integral are static data members ofnumeric_limits; those that may not be integral, such as the minimum value forfloat, are implemented as static inline member functions. This is because C++ allows onlyintegral static data member constants to be initialized inside a class definition. Other members, such as floating-point values, must be initialized at file scope outside the class definition, which is not appropriate in a header file. Since the needed value in that case will be placed in an implementation (.cpp) file, the value will not be available for compile-time optimization. Inline member functions of a class template, on the other hand, can be included in a header file, and thus facilitate compile-time optimization.
   In Chapter 3 you saw how traits are used to control the character-processing functionality used by the string classes. The classesstd::string andstd::wstring are specializations of thestd::basic_string template, which is defined as follows:
   template&lt;class charT,
     class traits = char_traits&lt;charT&gt;,
     class allocator = allocator&lt;charT&gt;&gt;
     class basic_string;

   The template parametercharT represents the underlying character type, which is usually eitherchar orwchar_t. The primarychar_traits template is typically empty, and specializations forchar andwchar_t are provided by the standard library. Here is the specification of the specializationchar_traits&lt;char&gt; according to the C++ standard:.
   template&lt;&gt;
   struct char_traits&lt;char&gt; {
     typedef char char_type;
     typedef int int_type;
     typedef streamoff off_type;
     typedef streampos pos_type;
     typedef mbstate_t state_type;
     static void assign(char_type& c1, const char_type& c2);
     static bool eq(const char_type& c1, const char_type& c2);
     static bool lt(const char_type& c1, const char_type& c2);
     static int compare(const char_type* s1,
         const char_type* s2, size_t n);
     static size_t length(const char_type* s);
     static const char_type* find(const char_type* s,
                   size_t n,
                   const char_type& a);
     static char_type* move(char_type* s1,
             const char_type* s2, size_t n);
     static char_type* copy(char_type* s1,
             const char_type* s2, size_t n);
     static char_type* assign(char_type* s, size_t n,
               char_type a);
     static int_type not_eof(const int_type& c);
     static char_type to_char_type(const int_type& c);
     static int_type to_int_type(const char_type& c);
     static bool eq_int_type(const int_type& c1,
              const int_type& c2);
     static int_type eof();
   };

   These functions are used by thebasic_string class template for character-based operations common to string processing. When you declare astring variable, such as:.
   std::string s;

   you are actually declarings as follows (because of the default template arguments in the specification ofbasic_string):
   std::basic_string&lt;char, std::char_traits&lt;char&gt;,
      std::allocator&lt;char&gt;&gt; s;

   Because the character traits have been separated from thebasic_string class template, you can supply a custom traits class to replacestd::char_traits. The following example illustrates this flexibility.
   //: C05:PoohCorner.cpp
   // Illustrates traits classes
   #include&lt;iostream&gt;
   using namespace std;

   // Item classes (traits of guests):
   class Water {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Water&) {
       return os&lt;&lt; "Water";
     }
   };
   class Milk {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Milk&) {
       return os&lt;&lt; "Milk";
     }
   };
   class Honey {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Honey&) {
       return os&lt;&lt; "Honey";
     }
   };
   class Cookies {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Cookies&) {
       return os&lt;&lt; "Cookies";
     }
   };

   // Guest classes:
   class Bear {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Bear&) {
       return os&lt;&lt; "Pooh";
     }
   };
   class Boy {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Boy&) {
       return os&lt;&lt; "Christopher Robin";
     }
   };

   // Primary traits template (empty—could hold common types)
   template&lt;class Guest&gt;
   class GuestTraits;

   // Traits specializations for Guest types
   template&lt;&gt;
   class GuestTraits&lt;Bear&gt; {
   public:
     typedef Water beverage_type;
     typedef Honey snack_type;
   };
   template&lt;&gt;
   class GuestTraits&lt;Boy&gt; {
   public:
     typedef Milk beverage_type;
     typedef Cookies snack_type;
   };

   // A custom traits class
   class MixedUpTraits {
   public:
     typedef Milk beverage_type;
     typedef Honey snack_type;
   };

   // The Guest template (uses a traits class)
   template&lt; class Guest, class traits = GuestTraits&lt;Guest&gt;&gt;
   class PoohCorner {
     Guest theGuest;
     typedef typename traits::beverage_type beverage_type;
     typedef typename traits::snack_type snack_type;
     beverage_type bev;
     snack_type snack;
   public:
     PoohCorner(const Guest& g)
       : theGuest(g), bev(beverage_type()),
         snack(snack_type()) {}
     void entertain() {
       cout&lt;&lt; "Entertaining "&lt;&lt; theGuest
           &lt;&lt; " serving "&lt;&lt; bev
           &lt;&lt; " and "&lt;&lt; snack&lt;&lt; endl;
     }
   };

   int main() {
     Boy cr;
     PoohCorner&lt;Boy&gt; pc1(cr);
     pc1.entertain();
     Bear pb;
     PoohCorner&lt;Bear&gt; pc2(pb);
     pc2.entertain();
     PoohCorner&lt;Bear, MixedUpTraits&gt; pc3(pb);
     pc3.entertain();
   } ///:~.

   In this program, instances of the guest classesBoy andBear are served items appropriate to their tastes.Boys like milk and cookies andBears like water and honey. This association of guests to items is done via specializations of a primary (empty) traits class template. The default arguments toPoohCorner ensure that guests get their proper items, but you can override this by simply providing a class that meets the requirements of the traits class, as we do with theMixedUpTraits class above. The output of this program is:.
   Entertaining Christopher Robin serving Milk and Cookies
   Entertaining Pooh serving Water and Honey
   Entertaining Pooh serving Milk and Honey

   Using traits provides two key advantages: (1) it allows flexibility in pairing objects with associated attributes or functionality, and (2) it keeps template parameter lists small and readable. If 30 types were associated with a guest, it would be inconvenient to have to specify all 30 arguments directly in eachPoohCorner declaration. Factoring the types into a separate traits class simplifies things considerably.
   The traits technique is also used in implementing streams and locales, as we showed in Chapter 4.
   Policies
   If you inspect thechar_traits specialization forwchar_t, you’ll see that it is practically identical to itschar counterpart:
   template&lt;&gt;
     struct char_traits&lt;wchar_t&gt; {
     typedef wchar_t char_type;
     typedef wint_t int_type;
     typedef streamoff off_type;
     typedef wstreampos pos_type;
     typedef mbstate_t state_type;
     static void assign(char_type& c1, const char_type& c2);
     static bool eq(const char_type& c1, const char_type& c2);
     static bool lt(const char_type& c1, const char_type& c2);
     static int compare(const char_type* s1,
         const char_type*  s2, size_t n);
     static size_t length(const char_type* s);
     static const char_type* find(const char_type* s,
                   size_t n,
                   const char_type& a);
     static char_type* move(char_type* s1,
             const char_type* s2, size_t n);
     static char_type* copy(char_type* s1,
             const char_type* s2, size_t n);
     static char_type* assign(char_type* s, size_t n,
               char_type a);
     static int_type not_eof(const int_type& c);
     static char_type to_char_type(const int_type& c);
     static int_type to_int_type(const char_type& c);
     static bool eq_int_type(const int_type& c1,
              const int_type& c2);
     static int_type eof();
   };

   The only real difference between the two versions is the set of types involved (char andint vs.wchar_t andwint_t). The functionality provided is the same.[63] This highlights the fact that traits classes are indeed fortraits, and therefore the things that change between related traits classes are usually types and constant values, or fixed algorithms that use type-related template parameters. Traits classes tend to be templates themselves, since the types and constants they contain are seen as characteristics of the primary template parameter(s) (for example,char andwchar_t).
   It is also useful to be able to associatefunctionality with template arguments, so that client programmers can easily customize behavior when they code. The following version of thePoohCorner program, for instance, supports different types of entertainment:.
   //: C05:PoohCorner2.cpp
   // Illustrates policy classes
   #include&lt;iostream&gt;
   using namespace std;

   // Item classes:
   class Water {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Water&) {
       return os&lt;&lt; "Water";
     }
   };
   class Milk {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Milk&) {
       return os&lt;&lt; "Milk";
     }
   };
   class Honey {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Honey&) {
       return os&lt;&lt; "Honey";
     }
   };
   class Cookies {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Cookies&) {
       return os&lt;&lt; "Cookies";
     }
   };

   // Guest classes:
   class Bear {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Bear&) {
       return os&lt;&lt; "Pooh";
     }
   };
   class Boy {
   public:
     friend ostream& operator&lt;&lt;(ostream& os, const Boy&) {
       return os&lt;&lt; "Christopher Robin";
     }
   };

   // Traits template
   template&lt;class Guest&gt;
   class GuestTraits;

   // Traits specializations for Guest types
   template&lt;&gt;
   class GuestTraits&lt;Bear&gt; {
   public:
     typedef Water beverage_type;
     typedef Honey snack_type;
   };
   template&lt;&gt;
   class GuestTraits&lt;Boy&gt; {
   public:
     typedef Milk beverage_type;
     typedef Cookies snack_type;
   };

   // Policy classes (require a static doAction() function)
   class Feed {
   public:
     static const char* doAction() {
       return "Feeding";
     }
   };
   class Stuff {
   public:
     static const char* doAction() {
       return "Stuffing";
     }
   };

   // The Guest template (uses a policy and a traits class)
   template&lt; class Guest, class Action, class traits =
                         GuestTraits&lt;Guest&gt;&gt;
   class PoohCorner {
     Guest theGuest;
     typedef typename traits::beverage_type beverage_type;
     typedef typename traits::snack_type snack_type;
     beverage_type bev;
     snack_type snack;
   public:
     PoohCorner(const Guest& g)
       : theGuest(g), bev(beverage_type()), snack(snack_type()) {}
     void entertain() {
       cout&lt;&lt; Action::doAction()&lt;&lt; " "&lt;&lt; theGuest
           &lt;&lt; " with "&lt;&lt; bev
           &lt;&lt; " and "&lt;&lt; snack&lt;&lt; endl;
     }
   };

   int main() {
     Boy cr;
     PoohCorner&lt;Boy, Feed&gt; pc1(cr);
     pc1.entertain();
     Bear pb;
     PoohCorner&lt;Bear, Stuff&gt; pc2(pb);
     pc2.entertain();
   } ///:~.

   TheAction template parameter in thePoohCorner class expects to have a static member function nameddoAction( ), which is used inPoohCorner&lt;&gt;::entertain( ). Users can chooseFeed orStuff at will, both of which provide the required function. Classes that encapsulate functionality in this way are referred to aspolicy classes. The entertainment "policies" are provided above throughFeed::doAction( ) andStuff::doAction( ). These policy classes happen to be ordinary classes, but they can be templates, and can be combined with inheritance to great advantage. For more in-depth information on policy-based design, see is Andrei Alexandrescu’s book,[64] the definitive source.
   The curiously recurring template pattern
   Any novice C++ programmer can figure out how to modify a class to keep track of the number of objects of that class that currently exist. All you have to do is to add static members, and modify constructor and destructor logic, as follows:.
   //: C05:CountedClass.cpp
   // Object counting via static members
   #include&lt;iostream&gt;
   using namespace std;

   class CountedClass {
     static int count;
   public:
     CountedClass() { ++count; }
     CountedClass(const CountedClass&) { ++count; }
     ~CountedClass() { --count; }
     static int getCount() { return count; }
   };

   int CountedClass::count = 0;

   int main() {
     CountedClass a;
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;   // 1
     CountedClass b;
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;   // 2
     { // an arbitrary scope:
       CountedClass c(b);
       cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl; // 3
       a = c;
       cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl; // 3
     }
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;   // 2
   } ///:~.

   All constructors ofCountedClass increment the static data membercount, and the destructor decrements it. The static member functiongetCount( ) yields the number of current objects whenever it called.
   It would be tremendously tedious to have to manually add these members every time you wanted to add object counting to a class. What is the usual object-oriented device to which one turns to repeat or share code? It’s inheritance, of course, which, unfortunately, is only half a solution in this case. Observe what happens when we collect the counting logic into a base class.
   //: C05:CountedClass2.cpp
   // Erroneous attempt to count objects
   #include&lt;iostream&gt;
   using namespace std;

   class Counted {
     static int count;
   public:
     Counted() { ++count; }
     Counted(const Counted&) { ++count; }
     ~Counted() { --count; }
     static int getCount() { return count; }
   };
   int Counted::count = 0;

   class CountedClass : public Counted {};
   class CountedClass2 : public Counted {};

   int main() {
     CountedClass a;
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;    // 1
     CountedClass b;
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;    // 2
     CountedClass2 c;
     cout&lt;&lt; CountedClass2::getCount()&lt;&lt; endl;   // 3 (Error)
   } ///:~

   All classes that derive fromCounted share the same, single static data member, so the number of objects is tracked collectively across all classes in theCounted hierarchy. What is needed is a way to automatically generate adifferent base class for each derived class. This is accomplished by the curious template construct illustrated below:.
   //: C05:CountedClass3.cpp
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   class Counted {
     static int count;
   public:
     Counted() { ++count; }
     Counted(const Counted&lt;T&gt;&) { ++count; }
     ~Counted() { --count; }
     static int getCount() { return count; }
   };
   template&lt;class T&gt;
   int Counted&lt;T&gt;::count = 0;

   // Curious class definitions
   class CountedClass : public Counted&lt;CountedClass&gt; {};
   class CountedClass2 : public Counted&lt;CountedClass2&gt; {};

   int main() {
     CountedClass a;
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;    // 1
     CountedClass b;
     cout&lt;&lt; CountedClass::getCount()&lt;&lt; endl;    // 2
     CountedClass2 c;
     cout&lt;&lt; CountedClass2::getCount()&lt;&lt; endl;   // 1 (!)
   } ///:~.

   Each derived class derives from a unique base class that is determined by using itself (the derived class) as a template parameter! This may seem like a circular definition, and it would be, had any base class members used the template argument in a computation. Since all data members ofCounted are not dependent onT, its size (which is zero!) is known when the template is parsed. It doesn’t matter, therefore, which argument is used to instantiateCounted; its size is always the same. Therefore, any derivation from an instance ofCounted can be completed when it is parsed, and there is no recursion. Since each base class is unique, it has its own static data, thus constituting a handy technique for adding counting to any class whatsoever. Jim Coplien was the first to mention this interesting derivation idiom in print, which he cited in an article, entitled "Curiously Recurring Template Patterns."[ ][65] 
   Template metaprogramming
   In 1993 compilers were beginning to support simple template constructs so that users could define generic containers and functions. About the same time that the STL was being considered for adoption into standard C++, clever and surprising examples such as the following were passed around among members of the standards committee:.
   //: C05:Factorial.cpp
   // Compile-time computation!
   #include&lt;iostream&gt;
   using namespace std;
   template&lt;int n&gt;
   struct Factorial {
      enum {val = Factorial&lt;n-1&gt;::val * n};
   };
   template&lt;&gt;
   struct Factorial&lt;0&gt; {
      enum {val = 1};
   };
   int main() {
      cout&lt;&lt; Factorial&lt;12&gt;::val&lt;&lt; endl; // 479001600
   } ///:~

   That this program prints the correct value of12! is not alarming. What is alarming is that the computation is complete before the program even runs!.
   When the compiler attempts to instantiateFactorial&lt;12&gt;, it finds it must also instantiateFactorial&lt;11&gt;, which requiresFactorial&lt;10&gt;, and so on. Eventually the recursion ends with the specializationFactorial&lt;1&gt;, and the computation unwinds. Eventually,Factorial&lt;12&gt;::val is replaced by the integral constant 479001600, and compilation ends. Since all the computation is done by the compiler, the values involved must be compile-time constants, hence the use ofenum.[66] When the program runs, the only work left to do is print that constant followed by a newline. To convince yourself that a specialization ofFactorial results in the correct compile-time value, you could use it as an array dimension, such as:.
   double nums[Factorial&lt;5&gt;::val];
   assert(sizeof nums == sizeof(double)*120);

   Compile-time programming
   So what was meant to be a convenient way to perform type parameter substitution turned out to be a mechanism to support compile-time programming. Such a program is called atemplate metaprogram (since you’re in effect "programming a program"), and it turns out that you can do quite a lot with such a beast. In fact, template metaprogramming isTuring complete because it supports selection (if-else) and looping (through recursion); so theoretically you can perform any computation with it.[67] The factorial example above shows how to implement repetition; write a recursive template and provide a stopping criterion via a specialization. The following example shows how to compute Fibonacci numbers at compile time by the same technique.
   //: C05:Fibonacci.cpp
   #include&lt;iostream&gt;
   using namespace std;
   template&lt;int n&gt;
   struct Fib {
      enum {val = Fib&lt;n-1&gt;::val + Fib&lt;n-2&gt;::val};
   };
   template&lt;&gt;
   struct Fib&lt;1&gt; {
      enum {val = 1};
   };
   template&lt;&gt;
   struct Fib&lt;0&gt; {
      enum {val = 0};
   };

   int main() {
      cout&lt;&lt; Fib&lt;5&gt;::val&lt;&lt; endl;   // 6
      cout&lt;&lt; Fib&lt;20&gt;::val&lt;&lt; endl;  // 6765
   } ///:~.

   Fibonacci numbers are defined mathematically as:
    [Êàðòèíêà: img_5.png] 
   The first two cases lead to the template specializations above, and the rule in the third line becomes the primary template.
   Compile-time looping
   To compute any loop in a template metaprogram, it must first be reformulated recursively. For example, to raise the integern to the powerp, instead of using a loop such as in the following lines:.
   int val = 1;
   while (p--)
     val *= n;

   you would have to think of it as a recursive procedure:
   int power(int n, int p) {
     return (p == 0) ? 1 : n*power(n, p - 1);
   }

   This can now be easily rendered as a template metaprogram as follows:
   //: C05:Power.cpp
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;int N, int P&gt;
   struct Power {
     enum {val = N * Power&lt;N, P-1&gt;::val};
   };
   template&lt;int N&gt;
   struct Power&lt;N, 0&gt; {
     enum {val = 1};
   };
   int main() {
     cout&lt;&lt; Power&lt;2, 5&gt;::val&lt;&lt; endl;  // 32
   } ///:~

   Note that we need to use a partial specialization for the stopping condition, since the valueN is still a free template parameter. This program only works for non-negative powers, of course.
   The following metaprogram adapted from Czarnecki and Eisenecker[68] is interesting in that it uses a template template parameter, and simulates passing a function as a parameter to another function, which "loops through" the numbers0..n.
   //: C05:Accumulate.cpp
   // Passes a "function" as a parameter at compile time
   #include&lt;iostream&gt;
   using namespace std;
   // Accumulates the results of F(0)..F(n)
   template&lt;int n, template&lt;int&gt; class F&gt;
   struct Accumulate {
      enum {val = Accumulate&lt;n-1, F&gt;::val + F&lt;n&gt;::val};
   };
   // The stopping criterion (returns the value F(0))
   template&lt;template&lt;int&gt; class F&gt;
   struct Accumulate&lt;0, F&gt; {
      enum {val = F&lt;0&gt;::val};
   };
   // Various "functions":
   template&lt;int n&gt;
   struct Identity {
      enum {val = n};
   };
   template&lt;int n&gt;
   struct Square {
      enum {val = n*n};
   };
   template&lt;int n&gt;
   struct Cube {
      enum {val = n*n*n};
   };
   int main() {
      cout&lt;&lt; Accumulate&lt;4, Identity&gt;::val&lt;&lt; endl; // 10
      cout&lt;&lt; Accumulate&lt;4, Square&gt;::val&lt;&lt; endl;   // 30
      cout&lt;&lt; Accumulate&lt;4, Cube&gt;::val&lt;&lt; endl;     // 100
   } ///:~.

   The primaryAccumulate template attempts to compute the sumF(n)+F(n-1)…F(0). The stopping criterion is obtained by a partial specialization, which "returns"F(0). The parameterF is itself a template, and acts like a function as in the previous examples in this section. The templatesIdentity,Square, andCube compute the corresponding functions of their template parameter that their names suggest. The first instantiation ofAccumulate inmain( ) computes the sum 4+3+2+1+0, because theIdentity function simply "returns" its template parameter. The second line inmain( ) adds the squares of those numbers (16+9+4+1+0), and the last computes the sum of the cubes (64+27+8+1+0).
   Loop unrolling
   Algorithm designers have always endeavored to optimize their programs. One time-honored optimization, especially for numeric programming, is loop unrolling, a technique that minimizes loop overhead. The quintessential loop-unrolling example is matrix multiplication. The following function multiplies a matrix and a vector. (The constantsrows andcols have been previously defined.):.
   void mult(int a[rows][cols], int x[cols], int y[cols]) {
     for (int i = 0; i&lt; rows; ++i) {
         y[i] = 0;
         for (int j = 0; j&lt; cols; ++j)
           y[i] += a[i][j]*x[j];
     }
   }

   Ifcols is an even number, the overhead of incrementing and comparing the loop control variablej can be cut in half by "unrolling" the computation into pairs in the inner loop:.
   void mult(int a[rows][cols], int x[cols], int y[cols]) {
     for (int i = 0; i&lt; rows; ++i) {
         y[i] = 0;
         for (int j = 0; j&lt; cols; j += 2)
           y[i] += a[i][j]*x[j] + a[i][j+1]*x[j+1];
     }
   }

   In general, ifcols is a factor ofk,k operations can be performed each time the inner loop iterates, greatly reducing the overhead. The savings is only noticeable on large arrays, but that is precisely the case with industrial-strength mathematical computations.
   Function inlining also constitutes a form of loop unrolling. Consider the following approach to computing powers of integers.
   //: C05:Unroll.cpp
   // Unrolls an implicit loop via inlining
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;int n&gt;
   inline int power(int m) {
      return power&lt;n-1&gt;(m) * m;
   }
   template&lt;&gt;
   inline int power&lt;1&gt;(int m) {
      return m;
   }
   template&lt;&gt;
   inline int power&lt;0&gt;(int m) {
      return 1;
   }
   int main()
   {
      int m = 4;
      cout&lt;&lt; power&lt;3&gt;(m)&lt;&lt; endl;
   } ///:~.

   Conceptually, the compiler must generate three specializations ofpower&lt;&gt;, one each for the template parameters 3, 2, and 1. Because the code for each of these functions can be inlined, the actual code that is inserted intomain( ) is the single expressionm*m*m. Thus, a simple template specialization coupled with inlining here provides a way to totally avoid loop control overhead.[69] This approach to loop unrolling is limited by your compiler’s inlining depth, of course.
   Compile-time selection
   To simulate conditionals at compile time, you can use the conditional ternary operator in anenum declaration. The following program uses this technique to calculate the maximum of two integers at compile time.
   //: C05:Max.cpp
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;int n1, int n2&gt;
   struct Max {
      enum {val = n1&gt; n2 ? n1 : n2};
   };
   int main() {
      cout&lt;&lt; Max&lt;10, 20&gt;::val&lt;&lt; endl;  // 20
   } ///:~

   If you want to use compile-time conditions to govern custom code generation, you can once again use specializations of the valuestrue andfalse:
   //: C05:Conditionals.cpp
   // Uses compile-time conditions to choose code
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;bool cond&gt;
   struct Select {};

   template&lt;&gt;
   struct Select&lt;true&gt; {
     static inline void f() { statement1(); }
   private:
     static inline void statement1() {
       cout&lt;&lt; "This is";
       cout&lt;&lt; " statement1 executing\n";
     }
   };
   template&lt;&gt;
   struct Select&lt;false&gt; {
     static inline void f() { statement2(); }
   private:
     static inline void statement2() {
       cout&lt;&lt; "This is";
       cout&lt;&lt; " statement2 executing\n";
     }
   };
   template&lt;bool cond&gt;
   void execute() {
     Select&lt;cond&gt;::f();
   }

   int main() {
     execute&lt;sizeof(int) == 4&gt;();
   } ///:~.

   This program is the equivalent of the expression:
   if (cond)
     statement1();
   else
     statement2();

   except that the conditioncond is evaluated at compile time, and the appropriate versions ofexecute&lt;&gt;( ) andSelect&lt;&gt; are instantiated by the compiler. The functionSelect&lt;&gt;::f( ) executes at runtime, of course. Aswitch statement can be emulated in similar fashion, but specializing on each case value instead of the valuestrue andfalse.
   Compile-time assertions
   In Chapter 2 we touted the virtues of using assertions as part of an overall defensive programming strategy. An assertion is basically an evaluation of a Boolean expression followed by a suitable action: do nothing if the condition is true, or halt with a diagnostic message otherwise. The previous section showed how to evaluate compile-time Boolean expressions. The remaining challenge in emulating assertions at compile time is to print a meaningful error message and halt. All that is required to halt the compiler is a compile error; the trick is to insert helpful text in the error message. The following example of Alexandrescu[70] uses template specialization, a local class, and a little macro magic to do the job.
   //: C05:StaticAssert.cpp
   //{-g++}
   #include&lt;iostream&gt;
   using namespace std;

   // A template and a specialization
   template&lt;bool&gt;
   struct StaticCheck {
      StaticCheck(...);
   };
   template&lt;&gt;
   struct StaticCheck&lt;false&gt;{};

   // The macro (generates a local class)
   #define STATIC_CHECK(expr, msg) {              \
      class Error_##msg{};         \
      sizeof((StaticCheck&lt;expr&gt;(Error_##msg()))); \
   }

   // Detects narrowing conversions
   template&lt;class To, class From&gt;
   To safe_cast(From from) {
      STATIC_CHECK(sizeof(From)&lt;= sizeof(To),
    NarrowingConversion);
      return reinterpret_cast&lt;To&gt;(from);
   }

   int main() {
      void* p = 0;
      int i = safe_cast&lt;int&gt;(p);
      cout&lt;&lt; "int cast okay\n";
   //!   char c = safe_cast&lt;char&gt;(p);
   } ///:~.

   This example defines a function template,safe_cast&lt;&gt;( ), that checks to see if the object it is casting from is no larger than the type of object it casts to. If the size of the target object type is smaller, then the user will be notified at compile time that a narrowing conversion was attempted. Notice that theStaticCheck class template has the curious feature thatanything can be converted to an instance ofStaticCheck&lt;true&gt; (because of the ellipsis in its constructor[71]), andnothing can be converted to aStaticCheck&lt;false&gt;, because no conversions are supplied for that specialization. The idea is to attempt to create an instance of a new class and attempt to convert it toStaticCheck&lt;true&gt;at compile time whenever the condition of interest is true, or to aStaticCheck&lt;false&gt; object when the condition being tested is false. Since thesizeof operator does its work at compile time, it is used to attempt the conversion. If the condition is false, the compiler will complain that it doesn’t know how to convert from the new class type toStaticCheck&lt;false&gt;. (The extra parentheses inside thesizeof invocation inSTATIC_CHECK( ) are to prevent the compiler from thinking that we’re trying to invokesizeof on a function, which is illegal.) To get some meaningful information inserted into the error message, the new class name carries key text in its name.
   The best way to understand this technique is to walk through a specific case. Consider the line inmain( ) above which reads:
      int i = safe_cast&lt;int&gt;(p);

   The call tosafe_cast&lt;int&gt;(p) contains the following macro expansion replacing its first line of code:
   {                                    \
      class Error_NarrowingConversion{};               \
      sizeof(StaticCheck&lt;sizeof(void*)&lt;= sizeof(int)&gt; \
              (Error_NarrowingConversion()));          \
   }

   (Recall that the token-pasting preprocessing operator,##, concatenates its operand into a single token, soError_##NarrowingConversion becomes the tokenError_NarrowingConversion after preprocessing). The classError_NarrowingConversion is alocal class (meaning that it is declared inside a non-namespace scope) because it is not needed elsewhere in the program. The application of thesizeof operator here attempts to determine the size of an instance ofStaticCheck&lt;true&gt; (becausesizeof(void*)&lt;= sizeof(int) is true on our platforms), created implicitly from the temporary object returned by the callError_NarrowingConversion( ). The compiler knows the size of the new classError_NarrowingConversion (it’s empty), and so the compile-time use ofsizeof at the outer level inSTATIC_CHECK( ) is valid. Since the conversion from theError_NarrowingConversion temporary toStaticCheck&lt;true&gt; succeeds, so does this outer application ofsizeof, and execution continues.
   Now consider what would happen if the comment were removed from the last line ofmain( ):
      char c = safe_cast&lt;char&gt;(p);

   In this case theSTATIC_CHECK( ) macro insidesafe_cast&lt;char&gt;(p) expands to:
   {                                     \
      class Error_NarrowingConversion{}; \
      sizeof(StaticCheck&lt;sizeof(void*)&lt;= sizeof(char)&gt; \
              (Error_NarrowingConversion()));           \
   }

   Since the expressionsizeof(void*)&lt;= sizeof(char) is false, a conversion from anError_NarrowingConversion temporary toStaticCheck&lt;false&gt; is attempted, as follows:
   sizeof(StaticCheck&lt;false&gt;(Error_NarrowingConversion()));

   which fails, so the compiler halts with a message something like the following:.
   Cannot cast from 'Error_NarrowingConversion' to 'StaticCheck&lt;0&gt;' in function
   char safe_cast&lt;char,void *&gt;(void *)

   The class nameError_NarrowingConversion is the meaningful message judiciously arrange by the coder. In general, to perform a static assertion with this technique, you just invoke theSTATIC_CHECK macro with the compile-time condition to check and with a meaningful name to describe the error.
   Expression templates
   Perhaps the most powerful application of templates is a technique discovered independently in 1994 by Todd Veldhuizen[72] and David Vandevoorde:[73] expression templates. Expression templates enable extensive compile-time optimization of certain computations that results in code that is at least as fast as hand-optimized Fortran, and yet preserves the natural notation of mathematics via operator overloading. Although you wouldn’t be likely to use this technique in everyday programming, it is the basis for a number of sophisticated, high-performance mathematical libraries written in C++.[74] 
   To motivate the need for expression templates, consider typical numerical linear algebra operations, such as adding together two matrices or vectors,[75] such as in the following:
   D = A + B + C;

   In naive implementations, this expression would result in a number of temporaries—one forA+B, and one for (A+B)+C. When these variables represent immense matrices or vectors, the coincident drain on resources is unacceptable. Expression templates allow you to use the same expression without temporaries.
   In the following sample program, we define aMyVector class to simulate mathematical vectors of any size. We use a non-type template argument for the length of the vector. We also define aMyVectorSum class to act as a proxy class for a sum ofMyVector objects. This allows us to use lazy evaluation, so the addition of vector components is performed on demand without the need for temporaries.
   //: C05:MyVector.cpp
   // Optimizes away temporaries via templates
   #include&lt;cstddef&gt;
   #include&lt;cstdlib&gt;
   #include&lt;iostream&gt;
   using namespace std;

   // A proxy class for sums of vectors
   template&lt;class, size_t&gt; class MyVectorSum;

   template&lt;class T, size_t N&gt;
   class MyVector {
     T data[N];
   public:
     MyVector&lt;T,N&gt;& operator=(const MyVector&lt;T,N&gt;& right) {
       for (size_t i = 0; i&lt; N; ++i)
         data[i] = right.data[i];
       return *this;
     }
     MyVector&lt;T,N&gt;& operator=(const MyVectorSum&lt;T,N&gt;& right);
     const T& operator[](size_t i) const {
       return data[i];
     }
     T& operator[](size_t i) {
       return data[i];
     }
   };
   // Proxy class hold references; uses lazy addition
   template&lt;class T, size_t N&gt;
   class MyVectorSum {
     const MyVector&lt;T,N&gt;& left;
     const MyVector&lt;T,N&gt;& right;
   public:
     MyVectorSum(const MyVector&lt;T,N&gt;& lhs,
                 const MyVector&lt;T,N&gt;& rhs)
         : left(lhs), right(rhs) {}
     T operator[](size_t i) const {
       return left[i] + right[i];
     }
   };
   // Operator to support v3 = v1 + v2
   template&lt;class T, size_t N&gt;
   MyVector&lt;T,N&gt;&
   MyVector&lt;T,N&gt;::operator=(const MyVectorSum&lt;T,N&gt;& right) {
     for (size_t i = 0; i&lt; N; ++i)
       data[i] = right[i];
     return *this;
   }
   // operator+ just stores references
   template&lt;class T, size_t N&gt;
   inline MyVectorSum&lt;T,N&gt;
   operator+(const MyVector&lt;T,N&gt;& left,
             const MyVector&lt;T,N&gt;& right) {
     return MyVectorSum&lt;T,N&gt;(left, right);
   }
   // Convenience functions for the test program below
   template&lt;class T, size_t N&gt;
   void init(MyVector&lt;T,N&gt;& v) {
     for (size_t i = 0; i&lt; N; ++i)
       v[i] = rand() % 100;
   }
   template&lt;class T, size_t N&gt;
   void print(MyVector&lt;T,N&gt;& v) {
     for (size_t i = 0; i&lt; N; ++i)
       cout&lt;&lt; v[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
   }
   int main() {
     MyVector&lt;int, 5&gt; v1;
     init(v1);
     print(v1);
     MyVector&lt;int, 5&gt; v2;
     init(v2);
     print(v2);
     MyVector&lt;int, 5&gt; v3;
     v3 = v1 + v2;
     print(v3);
     MyVector&lt;int, 5&gt; v4;
     // Not yet supported:
   //!  v4 = v1 + v2 + v3;
   } ///:~.

   TheMyVectorSum class does no computation when it is created; it merely holds references to the two vectors to be added. It is only when you access a component of a vector sum that it is calculated (see itsoperator[]( )). The overload of the assignment operator forMyVector that takes aMyVectorSum argument is for an expression such as:.
   v1 = v2 + v3;  // add two vectors

   When the expressionv1+v2 is evaluated, aMyVectorSum object is returned (or actually, inserted inline, since thatoperator+( ) is declaredinline). This is a small, fixed-size object (it holds only two references). Then the assignment operator mentioned above is invoked:
   v3.operator=&lt;int,5&gt;(MyVectorSum&lt;int,5&gt;(v2, v3));

   This assigns to each element ofv3 the sum of the corresponding elements ofv1 andv2, computed in real time. No temporaryMyVector objects are created.
   This program does not support an expression that has more than two operands, however, such as
   v4 = v1 + v2 + v3;

   The reason is that after the first addition, a second addition is attempted:
   (v1 + v2)+ v3;

   which would require anoperator+( ) with a first argument ofMyVectorSum and a second argument of typeMyVector. We could attempt to provide a number of overloads to meet all situations, but it is better to let templates do the work, as in the following version of the program.
   //: C05:MyVector2.cpp
   // Handles sums of any length with expression templates
   #include&lt;cstddef&gt;
   #include&lt;cstdlib&gt;
   #include&lt;iostream&gt;
   using namespace std;

   // A proxy class for sums of vectors
   template&lt;class, size_t, class, class&gt; class MyVectorSum;

   template&lt;class T, size_t N&gt;
   class MyVector {
     T data[N];
   public:
     MyVector&lt;T,N&gt;& operator=(const MyVector&lt;T,N&gt;& right) {
       for (size_t i = 0; i&lt; N; ++i)
         data[i] = right.data[i];
       return *this;
     }
     template&lt;class Left, class Right&gt;
     MyVector&lt;T,N&gt;&
       operator=(const MyVectorSum&lt;T,N,Left,Right&gt;& right);
     const T& operator[](size_t i) const {
       return data[i];
     }
     T& operator[](size_t i) {
       return data[i];
     }
   };
   // Allows mixing MyVector and MyVectorSum
   template&lt;class T, size_t N, class Left, class Right&gt;
   class MyVectorSum {
     const Left& left;
     const Right& right;
   public:
     MyVectorSum(const Left& lhs, const Right& rhs)
         : left(lhs), right(rhs) {}
     T operator[](size_t i) const {
       return left[i] + right[i];
     }
   };
   template&lt;class T, size_t N&gt;
   template&lt;class Left, class Right&gt;
   MyVector&lt;T,N&gt;&
   MyVector&lt;T,N&gt;::
   operator=(const MyVectorSum&lt;T,N,Left,Right&gt;& right) {
     for (size_t i = 0; i&lt; N; ++i)
       data[i] = right[i];
     return *this;
   }
   // operator+ just stores references
   template&lt;class T, size_t N&gt;
   inline MyVectorSum&lt;T,N,MyVector&lt;T,N&gt;,MyVector&lt;T,N&gt;&gt;
   operator+(const MyVector&lt;T,N&gt;& left,
             const MyVector&lt;T,N&gt;& right) {
     return
       MyVectorSum&lt;T,N,MyVector&lt;T,N&gt;,MyVector&lt;T,N&gt;&gt;
         (left,right);
   }

   template&lt;class T, size_t N, class Left, class Right&gt;
   inline
   MyVectorSum&lt;T, N, MyVectorSum&lt;T,N,Left,Right&gt;,
               MyVector&lt;T,N&gt;&gt;
   operator+(const MyVectorSum&lt;T,N,Left,Right&gt;& left,
             const MyVector&lt;T,N&gt;& right) {
     return MyVectorSum&lt;T,N,MyVectorSum&lt;T,N,Left,Right&gt;,
             MyVector&lt;T,N&gt;&gt;
       (left, right);
   }
   // Convenience functions for the test program below
   template&lt;class T, size_t N&gt;
   void init(MyVector&lt;T,N&gt;& v) {
     for (size_t i = 0; i&lt; N; ++i)
       v[i] = rand() % 100;
   }
   template&lt;class T, size_t N&gt;
   void print(MyVector&lt;T,N&gt;& v) {
     for (size_t i = 0; i&lt; N; ++i)
       cout&lt;&lt; v[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
   }
   int main() {
     MyVector&lt;int, 5&gt; v1;
     init(v1);
     print(v1);
     MyVector&lt;int, 5&gt; v2;
     init(v2);
     print(v2);
     MyVector&lt;int, 5&gt; v3;
     v3 = v1 + v2;
     print(v3);
     // Now supported:
     MyVector&lt;int, 5&gt; v4;
     v4 = v1 + v2 + v3;
     print(v4);
     MyVector&lt;int, 5&gt; v5;
     v5 = v1 + v2 + v3 + v4;
     print(v5);
   } ///:~.

   Instead of committing ahead of time which types the arguments of a sum will be, we let the template facility deduce them with the template arguments,Left andRight. TheMyVectorSum template takes these extra two parameters so it can represent a sum of any combination of pairs ofMyVector andMyVectorSum. Note also that the assignment operator this time is a member function template. This also allows any&lt;T, N&gt; pair to be coupled with any&lt;Left, Right&gt; pair, so aMyVector object can be assigned from aMyVectorSum holding references to any possible pair of the typesMyVector andMyVectorSum. As we did before, let’s trace through a sample assignment to understand exactly what takes place, beginning with the expression.
   v4 = v1 + v2 + v3;

   Since the resulting expressions become quite unwieldy, in the explanation that follows, we will useMVS as shorthand forMyVectorSum, and will omit the template arguments.
   The first operation isv1+v2, which invokes the inlineoperator+( ), which in turn insertsMVS(v1, v2) into the compilation stream. This is then added tov3, which results in a temporary object according to the expressionMVS(MVS(v1, v2), v3). The final representation of the entire statement is.
   v4.operator+(MVS(MVS(v1, v2), v3));

   This transformation is all arranged by the compiler and explains why this technique carries the moniker "expression templates"; the templateMyVectorSum represents an expression (an addition, in this case), and the nested calls above are reminiscent of the parse tree of the left-associative expressionv1+v2+v3.
   An excellent article by Angelika Langer and Klaus Kreft explains how this technique can be extended to more complex computations.[76] 
   Template compilation models
   You have certainly noticed by now that all our template examples place fully-defined templates within each compilation unit. (For example, we place them completely within single-file programs or in header files for multi-file programs.) This runs counter to the conventional practice of separating ordinary function definitions from their declarations by placing the latter in header files and the function implementations in separate (that is,.cpp) files. Everyone knows the reason for this separation: non-inline function bodies in header files can lead to multiple function definitions, which results in a linker error. A nice side benefit of this approach is that vendors can distribute pre-compiled code along with headers so that users cannot see their function implementations, and compile times are shorter since header files are smaller.
   The inclusion model
   Templates, on the other hand, are not code, per se, but instructions for code generation; only template instantiations are real code. When a compiler has seen a complete template definition during a compilation and then encounters a point of instantiation for that template in the same translation unit, it must deal with the fact that an equivalent point of instantiation may be present in another translation unit. The most common approach consists in generating the code for the instantiation in every translation unit and let the linker weed out duplicates. That particular approach also works well with inline functions that cannot be inlined and with virtual function tables, which is one of the reasons for its popularity. Nonetheless, several compilers prefer instead to rely on more complex schemes to avoid generating a particular instantiation more than once. Either way, it is the responsibility of the C++ translation system to avoid errors due to multiple equivalent points of instantiation.
   A drawback of this approach is obviously that all template source code is visible to the client. If you want to know exactly how your standard library is implemented, all you have to do is inspect the headers in your installation. There is little opportunity for library vendors to hide their implementation strategies. Another noticeable disadvantage of the inclusion model is that header files are much, much larger than they would be if function bodies were compiled separately. This can increase compile times dramatically over traditional compilation models.
   To help reduce the large headers required by the inclusion model, C++ offers two (non-exclusive) alternative code organization mechanisms: you can manually instantiate each specialization usingexplicit instantiation or you can useexported templates, which actually support a large degree of separate compilation.
   Explicit instantiation
   You can manually direct the compiler to instantiate any template specializations of your choice. When you use this technique, there must be one and only one such directive for each such specialization; otherwise you might get multiple definition errors, just as you would with ordinary, non-inline functions with identical signatures. To illustrate, we first (erroneously) separate the declaration of themin template from earlier in this chapter from its definition, following the normal pattern for ordinary, non-inline functions. The following example consists of five files:.
   ·        OurMin.h: contains the declaration of themin function template.
   ·        OurMin.cpp: contains the definition of themin function template.
   ·        UseMin1.cpp: attempts to use anint-instantiation ofmin
   ·        UseMin2.cpp: attempts to use adouble-instantiation ofmin
   ·        MinMain.cpp: callsusemin1( ) andusemin2( )
   Here are the files:
   //: C05:OurMin.h
   #ifndef OURMIN_H
   #define OURMIN_H
   // The declaration of min
   template&lt;typename T&gt; const T& min(const T&, const T&);

   #endif ///:~

   // OurMin.cpp
   #include "OurMin.h"
   // The definition of min
   template&lt;typename T&gt; const T& min(const T& a, const T& b) {
     return (a&lt; b) ? a : b;
   }

   //: C05:UseMin1.cpp {O}
   #include&lt;iostream&gt;
   #include "OurMin.h"
   void usemin1() {
     std::cout&lt;&lt; min(1,2)&lt;&lt; std::endl;
   } ///:~

   //: C05:UseMin2.cpp {O}
   #include&lt;iostream&gt;
   #include "OurMin.h"
   void usemin2() {
     std::cout&lt;&lt; min(3.1,4.2)&lt;&lt; std::endl;
   } ///:~

   //: C05:MinMain.cpp
   //{L} UseMin1 UseMin2 MinInstances
   void usemin1();
   void usemin2();

   int main() {
     usemin1();
     usemin2();
   } ///:~

   When we attempt to build this program, the linker reports unresolved external references formin&lt;int&gt;( ) andmin&lt;double&gt;( ). The reason is that when the compiler encounters the calls to specializations ofmin inUseMin1 andUseMin2, only the declaration ofmin is visible. Since the definition is not available, the compiler assumes it will come from some other translation unit, and the needed specializations are therefore not instantiated at that point, leaving the linker to eventually complain that it cannot find them.
   To solve this problem, we will introduce a new file,MinInstances.cpp, that explicitly instantiates the needed specializations ofmin:
   //: C05:MinInstances.cpp {O}
   #include "OurMin.cpp"
   // Explicit Instantiations for int and double
   template const int& min&lt;int&gt;(const int&, const int&);
   template const double& min&lt;double&gt;(const double&,
                       const double&);
   ///:~

   To manually instantiate a particular template specialization, you precede the specialization’s declaration with thetemplate keyword. That’s it! Note that we must includeOurMin.cpp, notOurMin.h, here, because the compiler needs the template definition to perform the instantiation. This is the only place where we have to do this in this program,[77] however, since it gives us the unique instantiations ofmin that we need; the declarations alone suffice for the other files. Since we are includingOurMin.cpp with the macro preprocessor, we add include guards:.
   //: C05:OurMin.cpp {O}
   #ifndef OURMIN_CPP
   #define OURMIN_CPP
   #include "OurMin.h"

   template&lt;typename T&gt; const T& min(const T& a, const T& b) {
     return (a&lt; b) ? a : b;
   }
   #endif ///:~

   Now when we compile all the files together into a complete program, the unique instances ofmin are found, and the program executes correctly, giving the output:
   1
   3.1

   You can also manually instantiate classes and static data members. When explicitly instantiating a class, all member functions for the requested specialization are instantiated, except any that may have been explicitly instantiated previously. Using only implicit instantiation has the advantage here: only member functions that actually get called are instantiated. Explicit instantiation is intended for large projects in which a hefty chunk of compilation time can be avoided. Whether you use implicit or explicit instantiation is independent of which template compilation you use, of course; you can use manual instantiation with either the inclusion model or the separation model (discussed in the next section).
   The separation model
   The separation model of template compilation allows you to separate function template definitions or static data member definitions from their declarations across translation units, just like you do with ordinary functions and data, byexporting templates. After reading the preceding two sections, this must sound strange indeed. Why bother to have the inclusion model in the first place if you can just adhere to the status quo? The reasons are both historical and technical.
   Historically, the inclusion model was the first to experience widespread commercial use. Part of the reason for that was that the separation model was not well specified until late in the standardization process. It turns out that the inclusion model is the easier of the two to implement. All C++ compilers support the inclusion model. A lot of working code was in existence long before the semantics of the separation model were finalized.
   The technical aspect reflects the fact that the separation model is difficult to implement. In fact, as of summer 2003 only one compiler front end (EDG) supports the separation model, and at the moment it still requires that template source code be available at compile time to perform instantiation on demand. Plans are in place to use some form of intermediate code instead of requiring that the original source be at hand, at which point you will be able to ship "pre-compiled" templates without shipping source code. Because of the lookup complexities explained earlier in this chapter (about dependent names being looked up in the template definition context), a full template definition still has to be available in some form when you compile a program that instantiates it.
   The syntax to separate the source code of a template definition from its declaration is easy enough. You use theexport keyword:
   // C05:OurMin2.h
   // Declares min as an exported template
   //! (Only works with EDG-based compilers)
   #ifndef OURMIN2_H
   #define OURMIN2_H
   export template&lt;typename T&gt; const T& min(const T&,
                             const T&);
   #endif

   Similar toinline orvirtual, theexport keyword need only be mentioned once in a compilation stream, where an exported template is introduced. For this reason, we need not repeat it in the implementation file, but it is considered good practice to do so:.
   // C05:OurMin2.cpp
   // The definition of the exported min template
   //! (Only works with EDG-based compilers)
   #include "OurMin2.h"
   export
   template&lt;typename T&gt; const T& min(const T& a, const T& b) {
     return (a&lt; b) ? a : b;
   } ///:~

   TheUseMin files used previously only need to be updated to include the correct header file (OurMin2.h), and the main program need not change at all. Although this appears to give true separation, the file with the template definition (OurMin2.cpp) must still be shipped to users (because it must be processed for each instantiation ofmin) until such time as some form of intermediate code representation of template definitions is supported. So while the standard does provide for a true separation model, not all of its benefits can be reaped today. Only one family of compilers currently support export (those based on the EDG front end), and these compilers currently do not exploit the potential ability to distribute template definitions in compiled form.
   Summary
   Templates have gone far beyond simple type parameterization! When you combine argument type deduction, custom specialization, and template metaprogramming, C++ templates emerge as a powerful code generation mechanism.
   One of the weaknesses of C++ templates we skipped in this chapter is the difficulty in interpreting compile-time error messages. When you’re not used to it, the quantity of inscrutable text spewed out by the compiler is quite overwhelming. If it’s any consolation, C++ compilers have actually gotten a lot better about this. Leor Zolman has written a nifty toolSTLFilt, that renders these error messages much more readable by extracting the useful information and throwing away the rest.[78] 
   Another important idea to take away from this chapter is thata template implies an interface. That is, even though thetemplate keyword says "I’ll take any type," the code in a template definition actually requires that certain operators and member functions be supported—that’s the interface. So in reality, a template definition is saying, "I’ll take any type that supports this interface." Things would be much nicer if the compiler could simply say, "Hey, this type that you’re trying to instantiate the template with doesn’t support that interface—can’t do it." Using templates, therefore, constitutes a sort of "latent type checking" that is more flexible than the pure object-oriented practice of requiring all types toderive from certain base classes.
   In Chapters 6 and 7 we explore in depth the most famous application of templates, the subset of the standard C++ library commonly known as the Standard Template Library (STL). Chapters 9 and 10 also use template techniques not found in this chapter.
   Exercises
                1.             Write a unary function template that takes a single type template parameter. Create a full specialization for the typeint. Also create a non-template overload for this function that takes a singleint parameter. Have your main program invoke three function variations.
                2.             Write a class template that uses a vector to implement a stack data structure.
           38.             Modify your solution to the previous exercise so that the type of the container used to implement the stack is a template template parameter.
           39.             In the following code, the classNonComparable does not have anoperator=( ). Why would the presence of the classHardLogic cause a compile error, butSoftLogic would not?
   class Noncomparable {};
   struct HardLogic {
     Noncomparable nc1, nc2;
     void compare() {
        return nc1 == nc2; // Compiler error
     }
   };
   template&lt;class T&gt;
   struct SoftLogic {
     Noncomparable nc1, nc2;
     void noOp() {}
     void compare() {
       nc1 == nc2;
     }
   };
   int main() {
     SoftLogic&lt;Noncomparable&gt; l;
     l.noOp(); }

           40.             Write a function template that takes a single type parameter (T) and accepts four function arguments: an array ofT, a start index, a stop index (inclusive), and an optional initial value. The function returns the sum of all the array elements in the specified range. Use the default constructor ofT for the default initial value.
            41.             Repeat the previous exercise but use explicit instantiation to manually create specializations forint anddouble, following the technique explained in this chapter.
           42.             Why does the following code not compile? (Hint: what do class member functions have access to?)

   class Buddy {};
   template&lt;class T&gt;
   class My {
     int i;
   public:
     void play(My&lt;Buddy&gt;& s) {
       s.i = 3;
     }
   };
   int main() {
     My&lt;int&gt; h;
     My&lt;Buddy&gt; me, bud;
     h.play(bud);
     me.play(bud);
   }

           43.             Why does the following code not compile?

   template&lt;class T&gt;
   double pythag(T a, T b, T c) {
     return (-b + sqrt(double(b*b - 4*a*c))) / 2*a;
   }
   int main() {
     pythag(1, 2, 3);
     pythag(1.0, 2.0, 3.0);
     pythag(1, 2.0, 3.0);
     pythag&lt;double&gt;(1, 2.0, 3.0);
   }

           44.             Write templates that take non-type parameters of the following variety: anint, a pointer to anint, a pointer to a static class member of typeint, and a pointer to a static member function.
           45.             Write a class template that takes two type parameters. Define a partial specialization for the first parameter, and another partial specialization that specifies the second parameter. In each specialization, introduce members that are not in the primary template.
           46.             Define a class template namedBob that takes a single type parameter. MakeBob a friend of all instances of a template class namedFriendly, and a friend of a class template namedPicky only when the type parameter ofBob andPicky are identical. GiveBob member functions that demonstrate its friendship.

   6: Generic algorithms
   Algorithms are at the core of computing. To be able to write an algorithm once and for all to work with any type of sequence makes your programs both simpler and safer. The ability to customize algorithms at runtime has revolutionized software development.
   The subset of the standard C++ library known as the Standard Template Library (STL) was originally designed aroundgeneric algorithms—code that processes sequences of any type of values in a type-safe manner. The goal was to use predefined algorithms for almost every task, instead of hand-coding loops every time you need to process a collection of data. This power comes with a bit of a learning curve, however. By the time you get to the end of this chapter, you should be able to decide for yourself whether you find the algorithms addictive or too confusing to remember. If you’re like most people, you’ll resist them at first but then tend to use them more and more.
   A first look
   Among other things, the generic algorithms in the standard library provide avocabulary with which to describe solutions. That is, once you become familiar with the algorithms, you’ll have a new set of words with which to discuss what you’re doing, and these words are at a higher level than what you had before. You don’t have to say, "This loop moves through and assigns from here to there … oh, I see, it’s copying!" Instead, you just saycopy( ). This is the kind of thing we’ve been doing in computer programming from the beginning—creating high-level abstractions to expresswhat you’re doing and spending less time sayinghow you’re doing it. Thehow has been solved once and for all and is hidden in the algorithm’s code, ready to be reused on demand.
   Here’s an example of how to use thecopy algorithm:
   //: C06:CopyInts.cpp
   // Copies ints without an explicit loop
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;  // For size_t
   using namespace std;

   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     int b[SIZE];
     copy(a, a + SIZE, b);
     for (int i = 0; i&lt; SIZE; ++i)
       assert(a[i] == b[i]);
   } ///:~.

   Thecopy algorithm’s first two parameters represent therange of the input sequence—in this case the arraya. Ranges are denoted by a pair of pointers. The first points to the first element of the sequence, and the second points one positionpast the end of the array (right after the last element). This may seem strange at first, but it is an old C idiom that comes in quite handy. For example, the difference of these two pointers yields the number of elements in the sequence. More important, in implementingcopy( ), the second pointer can act as a sentinel to stop the iteration through the sequence. The third argument refers to the beginning of the output sequence, which is the arrayb in this example. It is assumed that the array thatb represents has enough space to receive the copied elements.
   Thecopy( ) algorithm wouldn’t be very exciting if it could only process integers. It can in fact copy any sequence. The following example copiesstring objects.
   //: C06:CopyStrings.cpp
   // Copies strings
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     string a[] = {"read", "my", "lips"};
     const size_t SIZE = sizeof a / sizeof a[0];
     string b[SIZE];
     copy(a, a + SIZE, b);
     assert(equal(a, a + SIZE, b));
   } ///:~.

   This example introduces another algorithm,equal( ), which returnstrue only if each element in the first sequence is equal (using itsoperator==( )) to the corresponding element in the second sequence. This example traverses each sequence twice, once for the copy, and once for the comparison, without a single explicit loop!.
   Generic algorithms achieve this flexibility because they are function templates, of course. If you guessed that the implementation ofcopy( ) looked something like the following, you’d be "almost" right.
   template&lt;typename T&gt;
   void copy(T* begin, T* end, T* dest) {
     while (begin != end)
       *dest++ = *begin++;
   }.

   We say "almost," becausecopy( ) can actually process sequences delimited by anything that acts like a pointer, such as an iterator. In this way,copy( ) can duplicate a vector, as in the following example.
   //: C06:CopyVector.cpp
   // Copies the contents of a vector
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;vector&gt;
   using namespace std;

   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     vector&lt;int&gt; v1(a, a + SIZE);
     vector&lt;int&gt; v2(SIZE);
     copy(v1.begin(), v1.end(), v2.begin());
     assert(equal(v1.begin(), v1.end(), v2.begin()));
   } ///:~.

   The first vector,v1, is initialized from the sequence of integers in the arraya. The definition of the vectorv2 uses a different vector constructor that makes room forSIZE elements, initialized to zero (the default value for integers).
   As with the array example earlier, it’s important thatv2 have enough space to receive a copy of the contents ofv1. For convenience, a special library function,back_inserter( ), returns a special type of iterator thatinserts elements instead ofoverwriting them, so memory is expanded automatically by the container as needed. The following example usesback_inserter( ), so it doesn’t have to expand the size of the output vector,v2, ahead of time.
   //: C06:InsertVector.cpp
   // Appends the contents of a vector to another
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   using namespace std;

   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     vector&lt;int&gt; v1(a, a + SIZE);
     vector&lt;int&gt; v2;  // v2 is empty here
     copy(v1.begin(), v1.end(), back_inserter(v2));
     assert(equal(v1.begin(), v1.end(), v2.begin()));
   } ///:~

   Theback_inserter( ) function is defined in the&lt;iterator&gt; header. We’ll explain how insert iterators work in depth in the next chapter.
   Since iterators are identical to pointers in all essential ways, you can write the algorithms in the standard library in such a way as to allow both pointer and iterator arguments. For this reason, the implementation ofcopy( ) looks more like the following code.
   template&lt;typename Iterator&gt;
   void copy(Iterator begin, Iterator end, Iterator dest) {
     while (begin != end)
       *begin++ = *dest++;
   }

   Whichever argument type you use in the call,copy( ) assumes it properly implements the indirection and increment operators. If it doesn’t, you’ll get a compile-time error.
   Predicates
   At times, you might want to copy only a well-defined subset of one sequence to another, such as only those elements that satisfy a certain condition. To achieve this flexibility, many algorithms have alternate calling sequences that allow you to supply apredicate, which is simply a function that returns a Boolean value based on some criterion. Suppose, for example, that you only want to extract from a sequence of integers those numbers that are less than or equal to 15. A version ofcopy( ) calledremove_copy_if( ) can do the job, like this:.
   //: C06:CopyInts2.cpp
   // Ignores ints that satisfy a predicate
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   using namespace std;
   // You supply this predicate
   bool gt15(int x) {
     return 15&lt; x;
   }
   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     int b[SIZE];
     int* endb = remove_copy_if(a, a+SIZE, b, gt15);
     int* beginb = b;
     while (beginb != endb)
       cout&lt;&lt; *beginb++&lt;&lt; endl; // Prints 10 only
   } ///:~.

   Theremove_copy_if( ) function template takes the usual range-delimiting pointers, followed by a predicate of your choosing. The predicate must be a pointer to function[79] that takes a single argument of the same type as the elements in the sequence, and it must return abool. In this case, the functiongt15 returnstrue if its argument is greater than 15. Theremove_copy_if( ) algorithm appliesgt15( ) to each element in the input sequence and ignores those elements when writing to the output sequence.
   The following program illustrates yet another variation of thecopy algorithm.
   //: C06:CopyStrings2.cpp
   // Replaces strings that satisfy a predicate
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;
   // The predicate
   bool contains_e(const string& s) {
     return s.find('e') != string::npos;
   }
   int main() {
     string a[] = {"read", "my", "lips"};
     const size_t SIZE = sizeof a / sizeof a[0];
     string b[SIZE];
     string* endb =
       replace_copy_if(a, a + SIZE, b, contains_e,
        string("kiss"));
     string* beginb = b;
     while (beginb != endb)
       cout&lt;&lt; *beginb++&lt;&lt; endl;
   } ///:~.

   Instead of just ignoring elements that don’t satisfy the predicate,replace_copy_if( ) substitutes a fixed value for such elements when populating the output sequence. The output in this case is
   kiss
   my
   lips

   because the original occurrence of "read", the only input string containing the lettere, is replaced by the word "kiss", as specified in the last argument in the call toreplace_copy_if( ).
   Thereplace_if( ) algorithm changes the original sequence in place, instead of writing to a separate output sequence, as the following program shows.
   //: C06:ReplaceStrings.cpp
   // Replaces strings in-place
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;
   bool contains_e(const string& s) {
     return s.find('e') != string::npos;
   }
   int main() {
     string a[] = {"read", "my", "lips"};
     const size_t SIZE = sizeof a / sizeof a[0];
     replace_if(a, a + SIZE, contains_e, string("kiss"));
     string* p = a;
     while (p != a + SIZE)
       cout&lt;&lt; *p++&lt;&lt; endl;
   } ///:~

   Stream iterators
   Like any good software library, the Standard C++ Library attempts to provide convenient ways to automate common tasks. We mentioned in the beginning of this chapter that you can use generic algorithms in place of looping constructs. So far, however, our examples have still used an explicit loop to print their output. Since printing output is one of the most common tasks, you would hope for a way to automate that too.
   That’s wherestream iterators come in. A stream iterator allows you to use a stream as either an input or an output sequence. To eliminate the output loop in theCopyInts2.cpp program, for instance, you can do something like the following.
   //: C06:CopyInts3.cpp
   // Uses an output stream iterator
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   using namespace std;
   bool gt15(int x) {
     return 15&lt; x;
   }
   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     remove_copy_if(a, a + SIZE,
     ostream_iterator&lt;int&gt;(cout, "\n"), gt15);
   } ///:~.

   In this example we’ve replaced the output sequenceb in the third argument toremove_copy_if( ) with anoutput stream iterator, which is an instance of theostream_iterator class template declared in the&lt;iterator&gt; header. Output stream iterators overload their copy-assignment operators to write to their stream. This particular instance ofostream_iterator is attached to the output streamcout. Every timeremove_copy_if( ) assigns an integer from the sequencea tocout through this iterator, the iterator writes the integer tocout and also automatically writes an instance of the separator string found in its second argument, which in this case contains just the newline character.
   It is just as easy to write to a file instead of tocout, of course. All you have to do is provide an output file stream instead ofcout:.
   //: C06:CopyIntsToFile.cpp
   // Uses an output file stream iterator
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;fstream&gt;
   #include&lt;iterator&gt;
   using namespace std;
   bool gt15(int x) {
     return 15&lt; x;
   }
   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     ofstream outf("ints.out");
     remove_copy_if(a, a + SIZE,
     ostream_iterator&lt;int&gt;(outf, "\n"), gt15);
   } ///:~.

   Aninput stream iterator allows an algorithm to get its input sequence from an input stream. This is accomplished by having both the constructor andoperator++( ) read the next element from the underlying stream and by overloadingoperator*( ) to yield the value previously read. Since algorithms require two pointers to delimit an input sequence, you can construct anistream_iteratorin two ways, as you can see in the program that follows.
   //: C06:CopyIntsFromFile.cpp
   // Uses an input stream iterator
   #include&lt;algorithm&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include "../require.h"
   using namespace std;
   bool gt15(int x) {
     return 15&lt; x;
   }
   int main() {
     ifstream inf("someInts.dat");
     assure(inf, "someInts.dat");
     remove_copy_if(istream_iterator&lt;int&gt;(inf),
     istream_iterator&lt;int&gt;(),
     ostream_iterator&lt;int&gt;(cout, "\n"), gt15);
   } ///:~.

   The first argument toreplace_copy_if( ) in this program attaches anistream_iterator object to the input file stream containingints. The second argument uses the default constructor of theistream_iterator class. This call constructs a special value ofistream_iterator that indicates end-of-file, so that when the first iterator finally encounters the end of the physical file, it compares equal to the valueistream_iterator&lt;int&gt;( ), allowing the algorithm to terminate correctly. Note that this example avoids using an explicit array altogether.
   Algorithm complexity
   Using a software library is a matter of trust. You trust the implementers to not only provide correct functionality, but you also hope that the functions execute as efficiently as possible. It’s better to write your own loops than to use algorithms that degrade performance.
   To guarantee quality library implementations, the C++ standard not only specifies what an algorithm should do, but how fast it should do it and sometimes how much space it should use. Any algorithm that does not meet the performance requirements does not conform to the standard. The measure of an algorithm’s operational efficiency is called itscomplexity.
   When possible, the standard specifies the exact number of operation counts an algorithm should use. Thecount_if( ) algorithm, for example, returns the number of elements in a sequence satisfying a given predicate. The following call tocount_if( ), if applied to a sequence of integers similar to the examples earlier in this chapter, yields the number of integer elements that are greater than 15:.
   size_t n = count_if(a, a + SIZE, gt15);

   Sincecount_if( ) must look at every element exactly once, it is specified to make a number of comparisons exactly equal to the number of elements in the sequence. Naturally, thecopy( ) algorithm has the same specification.
   Other algorithms can be specified to takeat most a certain number of operations. Thefind( ) algorithm searches through a sequence in order until it encounters an element equal to its third argument:.
   int* p = find(a, a + SIZE, 20);

   It stops as soon as the element is found and returns a pointer to that first occurrence. If it doesn’t find one, it returns a pointer one position past the end of the sequence (a+SIZE in this example). Therefore,find is said to make at most a number of comparisons equal to the number of elements in the sequence.
   Sometimes the number of operations an algorithm takes cannot be measured with such precision. In such cases, the standard specifies the algorithm’sasymptotic complexity, which is a measure of how the algorithm behaves with large sequences compared to well-known formulas. A good example is thesort( ) algorithm, which the standard says takes "approximatelyn log n comparisons on average" (n is the number of elements in the sequence).[80] Such complexity measures give a "feel" for the cost of an algorithm and at least give a meaningful basis for comparing algorithms. As you’ll see in the next chapter, thefind( ) member function for theset container has logarithmic complexity, which means that the cost of searching for an element in aset will, for large sets, be proportional to the logarithm of the number of elements. This is much smaller than the number of elements for largen, so it is always better to search aset by using itsfind( ) member function rather than by using the genericfind( ) algorithm.
   Function objects
   As you study some of the examples earlier in this chapter, you will probably notice the limited utility of the functiongt15( ). What if you want to use a number other than 15 as a comparison threshold? You may need agt20( ) orgt25( ) or others as well. Having to write a separate function for each such comparison has two distasteful difficulties:
   1.       You may have to write a lot of functions!
   2.      You must know all required values when you write your application code.
   The second limitation means that you can’t use runtime values[81] to govern your searches, which is downright unacceptable. Overcoming this difficulty requires a way to pass information to predicates at runtime. For example, you would need a greater-than function that you can initialize with an arbitrary comparison value. Unfortunately, you can’t pass that value as a function parameter, because unary predicates, such as ourgt15( ), are applied to each value in a sequence individually and must therefore take only one parameter.
   The way out of this dilemma is, as always, to create an abstraction. In this case, we need an abstraction that can act like a function as well as store state, without disturbing the number of function parameters it accepts when used. This abstraction is called afunction object.[82]
   A function object is an instance of a class that overloadsoperator( ), the function call operator. This operator allows an object to be used with function call syntax. As with any other object, you can initialize it via its constructors. Here is a function object that can be used in place ofgt15( ):
   //: C06:GreaterThanN.cpp
   #include&lt;iostream&gt;
   using namespace std;
   class gt_n {
     int value;
   public:
     gt_n(int val) : value(val) {}
     bool operator()(int n) {
       return n&gt; value;
     }
   };
   int main() {
     gt_n f(4);
     cout&lt;&lt; f(3)&lt;&lt; endl;  // Prints 0 (for false)
     cout&lt;&lt; f(5)&lt;&lt; endl;  // Prints 1 (for true)
   } ///:~

   The fixed value to compare against (4) is passed when the function objectf is created. The expressionf(3) is then evaluated by the compiler as the following function call:
   f.operator()(3);

   which returns the value of the expression3&gt; value, which is false whenvalue is 4, as it is in this example.
   Since such comparisons apply to types other thanint, it would make sense to definegt_n( ) as a class template. It turns out you don’t have to do it yourself, though—the standard library has already done it for you. The following descriptions of function objects should not only make that topic clear, but also give you a better understanding of how the generic algorithms work.
   Classification of function objects
   The standard C++ library classifies function objects based on the number of arguments that theiroperator( ) takes and the kind of value it returns. This classification is organized according to whether a function object’soperator( ) takes zero, one, or two arguments, as the following definitions illustrate.
   Generator: A type of function object that takesno arguments and returns a value of an arbitrary type. A random number generator is an example of a generator. The standard library provides one generator, the functionrand( ) declared in&lt;cstdlib&gt;, and has some algorithms, such asgenerate_n( ), which apply generators to a sequence.
   Unary Function: A type of function object that takes asingle argument of any type and returns a value that may be of a different type (which may bevoid).
   Binary Function: A type of function object that takestwo arguments of any two (possibly distinct) types and returns a value of any type (includingvoid).
   Unary Predicate: A Unary Function that returns abool.
   Binary Predicate: A Binary Function that returns abool.
   Strict Weak Ordering: A binary predicate that allows for a more general interpretation of "equality." Some of the standard containers consider two elements equivalent if neither is less than the other (usingoperator&lt;( )). This is important when comparing floating-point values, and objects of other types whereoperator==( ) is unreliable or unavailable. This notion also applies if you want to sort a sequence of data records (structs) on a subset of thestruct’s fields, that comparison scheme is considered a strict weak ordering because two records with equal keys are not really "equal" as total objects, but they are equal as far as the comparison you’re using is concerned. The importance of this concept will become clearer in the next chapter.
   In addition, certain algorithms make assumptions about the operations available for the types of objects they process. We will use the following terms to indicate these assumptions:.
   LessThanComparable: A class that has a less-thanoperator&lt;.
   Assignable: A class that has a copy-assignmentoperator= for its own type.
   EqualityComparable: A class that has an equivalenceoperator== for its own type.
   We will use these terms later in this chapter to describe the generic algorithms in the standard library.
   Automatic creation of function objects
   The&lt;functional&gt; header defines a number of useful generic function objects. They are admittedly simple, but you can use them to compose more complicated function objects. Consequently, in many instances, you can construct complicated predicates without writing a single function yourself! You do so by usingfunction object adapters to take the simple function objects and adapt them for use with other function objects in a chain of operations.
   To illustrate, let’s use only standard function objects to accomplish whatgt15( ) did earlier. The standard function object,greater, is abinary function object that returnstrue if its first argument is greater than its second argument. We cannot apply this directly to a sequence of integers through an algorithm such asremove_copy_if( ), becauseremove_copy_if( ) expects aunary predicate. No problem. We can construct a unary predicate on the fly that usesgreater to compare its first argument to afixed value. We fix the value of the second parameter thatgreater will use to be 15 with the function object adapterbind2nd, like this:.
   //: C06:CopyInts4.cpp
   // Uses a standard function object and adapter
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   using namespace std;
   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     remove_copy_if(a, a + SIZE,
     ostream_iterator&lt;int&gt;(cout, "\n"),
     bind2nd(greater&lt;int&gt;(), 15));
   } ///:~.

   This program accomplishes the same thing asCopyInts3.cpp, but without our having to write our own predicate functiongt15( ). The function object adapterbind2nd( ) is a template function that creates a function object of typebinder2nd, which simply stores the two arguments passed tobind2nd( ), the first of which must be a binary function or function object (that is, anything that can be called with two arguments). Theoperator( ) function inbinder2nd, which is itself a unary function, calls the binary function it stored, passing it its incoming parameter and the fixed value it stored.
   To make the explanation concrete for this example, let’s call the instance ofbinder2nd created bybind2nd( ) by the nameb. Whenb is created, it receives two parameters (greater&lt;int&gt;( ) and 15) and stores them. Let’s call the instance ofgreater&lt;int&gt; by the nameg. For convenience, let’s also call the instance of the output stream iterator by the nameo. Then the call toremove_copy_if( ) earlier becomes the following:.
   remove_copy_if(a, a + SIZE, o, b(g, 15).operator());

   Asremove_copy_if( ) iterates through the sequence, it callsb on each element, to determine whether to ignore the element when copying to the destination. If we denote the current element by the namee, that call insideremove_copy_if( ) is equivalent to.
   if (b(e))

   butbinder2nd’s function call operator just turns around and callsg(e,15), so the earlier call is the same as.
   if (greater&lt;int&gt;(e, 15))

   which is the comparison we were seeking. There is also abind1st( ) adapter that creates abinder1st object, which fixes thefirst argument of the associated input binary function.
   As another example, let’s count the number of elements in the sequence not equal to 20. This time we’ll use the algorithmcount_if( ), introduced earlier. There is a standard binary function object,equal_to, and also a function object adapter,not1( ), that take a unary function object as a parameter and invert its truth value. The following program will do the job.
   //: C06:CountNotEqual.cpp
   // Count elements not equal to 20
   #include&lt;algorithm&gt;
   #include&lt;cstddef&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   using namespace std;
   int main() {
     int a[] = {10, 20, 30};
     const size_t SIZE = sizeof a / sizeof a[0];
     cout&lt;&lt; count_if(a, a + SIZE,
       not1(bind1st(equal_to&lt;int&gt;(), 20)));// 2
   } ///:~.

   Asremove_copy_if( ) did in the previous example,count_if( ) calls the predicate in its third argument (let’s call itn) for each element of its sequence and increments its internal counter each timetrue is returned. If, as before, we call the current element of the sequence by the namee, the statement.
   if (n(e))

   in the implementation ofcount_ifis interpreted as
   if (!bind1st(equal_to&lt;int&gt;, 20)(e))

   which of course ends up as
   if (!equal_to&lt;int&gt;(20, e))

   becausenot1( ) returns the logical negation of the result of calling its unary function argument. The first argument toequal_to is 20 in this case because we usedbind1st( ) instead ofbind2nd( ). Since testing for equality is symmetric in its arguments, we could have used eitherbind1st( ) orbind2nd( ) in this example.
   The following table shows the templates that generate the standard function objects, along with the kinds of expressions to which they apply.NameTypeResult producedplusBinaryFunctionarg1 + arg2minusBinaryFunctionarg1 - arg2multipliesBinaryFunctionarg1 * arg2dividesBinaryFunctionarg1 / arg2modulusBinaryFunctionarg1 % arg2negateUnaryFunction- arg1equal_toBinaryPredicatearg1 == arg2not_equal_toBinaryPredicatearg1 != arg2greaterBinaryPredicatearg1&gt; arg2lessBinaryPredicatearg1&lt; arg2greater_equalBinaryPredicatearg1&gt;= arg2less_equalBinaryPredicatearg1&lt;= arg2logical_andBinaryPredicatearg1&& arg2logical_orBinaryPredicatearg1 || arg2logical_notUnaryPredicate!arg1unary_negateUnary Logical!(UnaryPredicate(arg1))binary_negateBinary Logical!(BinaryPredicate(arg1, arg2))
   Adaptable function objects
   Standard function adapters such asbind1st( ) andbind2nd( ) make some assumptions about the function objects they process. To illustrate, consider the following expression from the last line of the earlierCountNotEqual.cpp program:.
   not1(bind1st(equal_to&lt;int&gt;(), 20))

   Thebind1st( ) adapter creates a unary function object of typebinder1st, which simply stores an instance ofequal_to&lt;int&gt; and the value 20. Thebinder1st::operator( ) function needs to know its argument type and its return type; otherwise, it will not have a valid declaration. The convention to solve this problem is to expect all function objects to provide nested type definitions for these types. For unary functions, the type names areargument_type andresult_type; for binary function objects they arefirst_argument_type,second_argument_type, andresult_type. Looking at the implementation ofbind1st( ) andbinder1st in the&lt;functional&gt; header reveals these expectations. First inspectbind1st( ), as it might appear in a typical library implementation:.
   template&lt;class Op, class T&gt;
   binder1st&lt;Op&gt;
   bind1st(const Op& f, const T& val)
   {
     typedef typename Op::first_argument_type Arg1_t;
     return binder1st&lt;Op&gt;(f, Arg1_t(val));
   }

   Note that the template parameter,Op, which represents the type of the binary function being adapted bybind1st( ), must have a nested type namedfirst_argument_type. (Note also the use oftypename to inform the compiler that it is a membertype name, as explained in Chapter 5.) Now notice howbinder1st uses the type names inOp in its declaration of its function call operator:.
   // Inside the implementation for binder1st&lt;Op&gt;…
   typename Op::result_type
   operator()(const typename Op::second_argument_type& x)
     const;

   Function objects whose classes provide these type names are calledadaptable function objects.
   Since these names are expected of all standard function objects as well as of any function objects you create that you want to use with the function object adapters, the&lt;functional&gt; header provides two templates that define these types for you:unary_function andbinary_function. You simply derive from these classes while filling in the argument types as template parameters. Suppose, for example, that we want to make the function objectgt_n, defined earlier in this chapter, adaptable. All we need to do is the following:.
   class gt_n : public unary_function&lt;int, bool&gt; {
     int value;
   public:
     gt_n(int val) : value(val) {}
     bool operator()(int n) {
       return n&gt; value;
     }
   };.

   Allunary_function does is to provide the appropriate type definitions, which it infers from its template parameters as you can see in its definition:.
   template&lt;class Arg, class Result&gt;
   struct unary_function {
     typedef Arg argument_type;
     typedef Result result_type;
   };

   These types become accessible throughgt_n because it derives publicly fromunary_function. Thebinary_function template behaves in a similar manner.
   More function object examples
   The followingFunctionObjects.cpp example provides simple tests for most of the built-in basic function object templates. This way, you can see how to use each template, along with their resulting behavior. This example uses one of the following generators for convenience:.
   //: C06:Generators.h
   // Different ways to fill sequences
   #ifndef GENERATORS_H
   #define GENERATORS_H
   #include&lt;set&gt;
   #include&lt;cstdlib&gt;
   #include&lt;cstring&gt;
   #include&lt;ctime&gt;
   // Microsoft namespace work-around
   #ifndef _MSC_VER
   using std::rand;
   using std::srand;
   using std::time;
   #endif
   // A generator that can skip over numbers:
   class SkipGen {
     int i;
     int skp;
   public:
     SkipGen(int start = 0, int skip = 1)
       : i(start), skp(skip) {}
     int operator()() {
       int r = i;
       i += skp;
       return r;
     }
   };

   // Generate unique random numbers from 0 to mod:
   class URandGen {
     std::set&lt;int&gt; used;
     int limit;
   public:
     URandGen(int lim) : limit(lim) {
       srand(time(0));
     }
     int operator()() {
       while(true) {
         int i = int(rand()) % limit;
         if(used.find(i) == used.end()) {
           used.insert(i);
           return i;
         }
       }
     }
   };

   // Produces random characters:
   class CharGen {
     static const char* source;
     static const int len;
   public:
     CharGen() { srand(time(0)); }
     char operator()() {
       return source[rand() % len];
     }
   };

   // Statics created here for convenience, but
   // will cause problems if multiply included:
   const char* CharGen::source = "ABCDEFGHIJK"
     "LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
   const int CharGen::len = strlen(source);
   #endif // GENERATORS_H ///:~

   We’ll be using these generating functions in various examples throughout this chapter. TheSkipGen function object returns the next number of an arithmetic sequence whose common difference is held in itsskp data member. AURandGen object generates a unique random number in a specified range. (It uses aset container, which we’ll discuss in the next chapter.) ACharGen object returns a random alphabetic character. Here is the sample program we promised, which usesURandGen.
   //: C06:FunctionObjects.cpp
   //{-bor}
   // Illustrates selected predefined function object
   // templates from the standard C++ library
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   #include "Generators.h"
   using namespace std;

   template&lt;class Iter&gt;
   void print(Iter b, Iter e, char* msg = "") {
     if(msg != 0&& *msg != 0)
       cout&lt;&lt; msg&lt;&lt; ":"&lt;&lt; endl;
     typedef typename Iter::value_type T;
     copy(b, e, ostream_iterator&lt;T&gt;(cout, " "));
     cout&lt;&lt; endl;
   }

   template&lt;typename Contain, typename UnaryFunc&gt;
   void testUnary(Contain& source, Contain& dest,
     UnaryFunc f) {
     transform(source.begin(), source.end(),
       dest.begin(), f);
   }

   template&lt;typename Contain1, typename Contain2,
     typename BinaryFunc&gt;
   void testBinary(Contain1& src1, Contain1& src2,
     Contain2& dest, BinaryFunc f) {
     transform(src1.begin(), src1.end(),
       src2.begin(), dest.begin(), f);
   }

   // Executes the expression, then stringizes the
   // expression into the print statement:
   #define T(EXPR) EXPR; print(r.begin(), r.end(), \
     "After " #EXPR);
   // For Boolean tests:
   #define B(EXPR) EXPR; print(br.begin(), br.end(), \
     "After " #EXPR);

   // Boolean random generator:
   struct BRand {
     BRand() { srand(time(0)); }
     bool operator()() {
       return rand()&gt; RAND_MAX / 2;
     }
   };

   int main() {
     const int sz = 10;
     const int max = 50;
     vector&lt;int&gt; x(sz), y(sz), r(sz);
     // An integer random number generator:
     URandGen urg(max);
     generate_n(x.begin(), sz, urg);
     generate_n(y.begin(), sz, urg);
     // Add one to each to guarantee nonzero divide:
     transform(y.begin(), y.end(), y.begin(),
       bind2nd(plus&lt;int&gt;(), 1));
     // Guarantee one pair of elements is ==:
     x[0] = y[0];
     print(x.begin(), x.end(), "x");
     print(y.begin(), y.end(), "y");
     // Operate on each element pair of x& y,
     // putting the result into r:
     T(testBinary(x, y, r, plus&lt;int&gt;()));
     T(testBinary(x, y, r, minus&lt;int&gt;()));
     T(testBinary(x, y, r, multiplies&lt;int&gt;()));
     T(testBinary(x, y, r, divides&lt;int&gt;()));
     T(testBinary(x, y, r, modulus&lt;int&gt;()));
     T(testUnary(x, r, negate&lt;int&gt;()));
     vector&lt;bool&gt; br(sz); // For Boolean results
     B(testBinary(x, y, br, equal_to&lt;int&gt;()));
     B(testBinary(x, y, br, not_equal_to&lt;int&gt;()));
     B(testBinary(x, y, br, greater&lt;int&gt;()));
     B(testBinary(x, y, br, less&lt;int&gt;()));
     B(testBinary(x, y, br, greater_equal&lt;int&gt;()));
     B(testBinary(x, y, br, less_equal&lt;int&gt;()));
     B(testBinary(x, y, br,
       not2(greater_equal&lt;int&gt;())));
     B(testBinary(x,y,br,not2(less_equal&lt;int&gt;())));
     vector&lt;bool&gt; b1(sz), b2(sz);
     generate_n(b1.begin(), sz, BRand());
     generate_n(b2.begin(), sz, BRand());
     print(b1.begin(), b1.end(), "b1");
     print(b2.begin(), b2.end(), "b2");
     B(testBinary(b1, b2, br, logical_and&lt;int&gt;()));
     B(testBinary(b1, b2, br, logical_or&lt;int&gt;()));
     B(testUnary(b1, br, logical_not&lt;int&gt;()));
     B(testUnary(b1, br, not1(logical_not&lt;int&gt;())));
   } ///:~

   To keep this example short, we used a few handy tricks. Theprint( ) template is designed to print any sequence, along with an optional message. Sinceprint( ) uses thecopy( ) algorithm to send objects tocout via anostream_iterator, theostream_iterator must know the type of object it is printing, which we infer from thevalue_type member of the iterator passed.[83] As you can see inmain( ), however, the compiler can deduce the type ofT when you hand it avector&lt;T&gt;, so you don’t have to specify that template argument explicitly; you just sayprint(x) to print thevector&lt;T&gt; x.
   The next two template functions automate the process of testing the various function object templates. There are two since the function objects are either unary or binary. ThetestUnary( ) function takes a source vector, a destination vector, and a unary function object to apply to the source vector to produce the destination vector. IntestBinary( ), two source vectors are fed to a binary function to produce the destination vector. In both cases, the template functions simply turn around and call thetransform( ) algorithm, which applies the unary function/function object found in its fourth parameter to each sequence element, writing the result to the sequence indicated by its third parameter, which in this case is the same as the input sequence.
   For each test, you want to see a string describing the test, followed by the results of the test. To automate this, the preprocessor comes in handy; theT( ) andB( ) macros each take the expression you want to execute. After evaluating the expression, they pass the appropriate range toprint( ). To produce the message the expression is "string-ized" using the preprocessor. That way you see the code of the expression that is executed followed by the result vector.
   The last little tool,BRand, is a generator object that creates randombool values. To do this, it gets a random number fromrand( ) and tests to see if it’s greater than(RAND_MAX+1)/2. If the random numbers are evenly distributed, this should happen half the time.
   Inmain( ), three vectors ofint are created:x andy for source values, andr for results. To initializex andy with random values no greater than 50, a generator of typeURandGen fromGenerators.h is used. The standardgenerate_n( ) algorithm populates the sequence specified in its first argument by invoking its third argument (which must be a generator) a given number of times (specified in its second argument). Since there is one operation in which elements ofx are divided by elements ofy, we must ensure that there are no zero values ofy. This is accomplished by once again using thetransform( ) algorithm, taking the source values fromy and putting the results back intoy. The function object for this is created with the expression:.
   bind2nd(plus&lt;int&gt;(), 1)

   This expression uses theplus function object to add 1 to its first argument. As we did earlier in this chapter, we use a binder adapter to make this a unary function so it can applied to the sequence by a single call totransform( ).
   Another test in the program compares the elements in the two vectors for equality, so it is interesting to guarantee that at least one pair of elements is equivalent; in this case element zero is chosen.
   Once the two vectors is printed,T( ) tests each of the function objects that produces a numeric value, and thenB( ) tests each function object that produces a Boolean result. The result is placed into avector&lt;bool&gt;, and when this vector is printed, it produces a‘1’ for a true value and a ‘0’ for a false value. Here is the output from an execution ofFunctionObjects.cpp:.
   x:
   4 8 18 36 22 6 29 19 25 47
   y:
   4 14 23 9 11 32 13 15 44 30
   After testBinary(x, y, r, plus&lt;int&gt;()):
   8 22 41 45 33 38 42 34 69 77
   After testBinary(x, y, r, minus&lt;int&gt;()):
   0 -6 -5 27 11 -26 16 4 -19 17
   After testBinary(x, y, r, multiplies&lt;int&gt;()):
   16 112 414 324 242 192 377 285 1100 1410
   After testBinary(x, y, r, divides&lt;int&gt;()):
   1 0 0 4 2 0 2 1 0 1
   After testBinary(x, y, r, limit&lt;int&gt;()):
   0 8 18 0 0 6 3 4 25 17
   After testUnary(x, r, negate&lt;int&gt;()):
   -4 -8 -18 -36 -22 -6 -29 -19 -25 -47
   After testBinary(x, y, br, equal_to&lt;int&gt;()):
   1 0 0 0 0 0 0 0 0 0
   After testBinary(x, y, br, not_equal_to&lt;int&gt;()):
   0 1 1 1 1 1 1 1 1 1
   After testBinary(x, y, br, greater&lt;int&gt;()):
   0 0 0 1 1 0 1 1 0 1
   After testBinary(x, y, br, less&lt;int&gt;()):
   0 1 1 0 0 1 0 0 1 0
   After testBinary(x, y, br, greater_equal&lt;int&gt;()):
   1 0 0 1 1 0 1 1 0 1
   After testBinary(x, y, br, less_equal&lt;int&gt;()):
   1 1 1 0 0 1 0 0 1 0
   After testBinary(x, y, br, not2(greater_equal&lt;int&gt;())):
   0 1 1 0 0 1 0 0 1 0
   After testBinary(x,y,br,not2(less_equal&lt;int&gt;())):
   0 0 0 1 1 0 1 1 0 1
   b1:
   0 1 1 0 0 0 1 0 1 1
   b2:
   0 1 1 0 0 0 1 0 1 1
   After testBinary(b1, b2, br, logical_and&lt;int&gt;()):
   0 1 1 0 0 0 1 0 1 1
   After testBinary(b1, b2, br, logical_or&lt;int&gt;()):
   0 1 1 0 0 0 1 0 1 1
   After testUnary(b1, br, logical_not&lt;int&gt;()):
   1 0 0 1 1 1 0 1 0 0
   After testUnary(b1, br, not1(logical_not&lt;int&gt;())):
   0 1 1 0 0 0 1 0 1 1

   A binder doesn’t have to produce a unarypredicate; it can also create any unaryfunction (that is, a function that returns something other thanbool). For example, suppose you’d like to multiply every element in avector by 10. Using a binder with thetransform( ) algorithm does the trick:.
   //: C06:FBinder.cpp
   // Binders aren't limited to producing predicates
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   #include "Generators.h"
   using namespace std;

   int main() {
     ostream_iterator&lt;int&gt; out(cout," ");
     vector&lt;int&gt; v(15);
     generate(v.begin(), v.end(), URandGen(20));
     copy(v.begin(), v.end(), out);
     transform(v.begin(), v.end(), v.begin(),
               bind2nd(multiplies&lt;int&gt;(), 10));
     copy(v.begin(), v.end(), out);
   } ///:~

   Since the third argument totransform( )is the same as the first, the resulting elements are copied back into the source vector. The function object created bybind2nd( ) in this case produces anint result.
   The "bound" argument to a binder cannot be a function object, but it does not have to be a compile-time constant. For example:.
   //: C06:BinderValue.cpp
   // The bound argument can vary
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   using namespace std;

   int boundedRand() { return rand() % 100; }

   int main() {
     const int sz = 20;
     int a[sz], b[sz] = {0};
     generate(a, a + sz, boundedRand);
     int val = boundedRand();
     int* end = remove_copy_if(a, a + sz, b,
                bind2nd(greater&lt;int&gt;(), val));
     // Sort for easier viewing:
     sort(a, a + sz);
     sort(b, end);
     ostream_iterator&lt;int&gt; out(cout, " ");
     cout&lt;&lt; "Original Sequence:\n";
     copy(a, a + sz, out); cout&lt;&lt; endl;
     cout&lt;&lt; "Values less&lt;= "&lt;&lt; val&lt;&lt; endl;
     copy(b, end, out); cout&lt;&lt; endl;
   } ///:~


   Here, an array is filled with 20 random numbers between 0 and 100, and the user provides a value on the command line. In theremove_copy_if( ) call, you can see that the bound argument tobind2nd( ) is random number in the same range as the sequence. The output of a sample execution follows.
   Original Sequence:
   4 12 15 17 19 21 26 30 47 48 56 58 60 63 71 79 82 90 92 95
   Values less&lt;= 41
   4 12 15 17 19 21 26 30

   Function pointer adapters
   Wherever a function-like entity is expected by an algorithm, you can supply either a pointer to an ordinary function or a function object. When the algorithm issues a call, if it is through a function pointer, than the native function-call mechanism is used. If it through a function object, then that objectsoperator( ) member executes. You saw earlier, for example, that we passed a raw function,gt15( ), as a predicate toremove_copy_if( ) in the programCopyInts2.cpp. We also passed pointers to functions returning random numbers togenerate( ) andgenerate_n( ).
   You cannot, however, use raw functions with function object adapters, such asbind2nd( ), because they assume the existence of type definitions for the argument and result types. Instead of manually converting your native functions into function objects yourself, the standard library provides a family of adapters to do the work for you. Theptr_fun( )adapters take a pointer to a function and turn it into a function object. They are not designed for a function that takes no arguments—they must only be used with unary functions or binary functions.
   The following program usesptr_fun( ) to wrap a unary function.
   //: C06:PtrFun1.cpp
   // Using ptr_fun() with a unary function
   #include&lt;algorithm&gt;
   #include&lt;cmath&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   using namespace std;

   int d[] = {123, 94, 10, 314, 315};
   const int dsz = sizeof d / sizeof *d;
   bool isEven(int x) {
     return x % 2 == 0;
   }
   int main() {
     vector&lt;bool&gt; vb;
     transform(d, d + dsz, back_inserter(vb),
       not1(ptr_fun(isEven)));
     copy(vb.begin(), vb.end(),
       ostream_iterator&lt;bool&gt;(cout, " "));
     cout&lt;&lt; endl;
     // Output: 1 0 0 0 1
   } ///:~

   We can’t simply passisEven tonot1, becausenot1 needs to know the actual argument type and return type its argument uses. Theptr_fun( ) adapter deduces those types through template argument deduction. The definition of the unary version ofptr_fun( ) looks something like this:.
   template&lt;class Arg, class Result&gt;
   pointer_to_unary_function&lt;Arg, Result&gt;
   ptr_fun(Result (*fptr)(Arg))
   {
     return pointer_to_unary_function&lt;Arg, Result&gt;(fptr);
   }

   As you can see, this version ofptr_fun( ) deduces the argument and result types fromfptr and uses them to initialize apointer_to_unary_function object that storesfptr. The function call operator forpointer_to_unary_function just callsfptr, as you can see by the last line of its code:.
   template&lt;class Arg, class Result&gt;
   class pointer_to_unary_function
   : public unary_function&lt;Arg, Result&gt; {
     Result (*fptr)(Arg); // stores the f-ptr
   public:
     pointer_to_unary_function(Result (*x)(Arg))
       : fptr(x) {}
     Result operator()(Arg x) const {return fptr(x);}
   };

   Sincepointer_to_unary_function derives fromunary_function, the appropriate type definitions come along for the ride and are available tonot1.
   There is also a binary version ofptr_fun( ), which returns apointer_to_binary_function object (which derives frombinary_function, of course) that behaves analogously to the unary case. The following program uses the binary version ofptr_fun( ) to raise numbers in a sequence to a power. It also reveals a "gotcha" when passing overloaded functions toptr_fun( ).
   //: C06:PtrFun2.cpp
   // Using ptr_fun() for a binary function
   #include&lt;algorithm&gt;
   #include&lt;cmath&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   using namespace std;

   double d[] = { 01.23, 91.370, 56.661,
     023.230, 19.959, 1.0, 3.14159 };
   const int dsz = sizeof d / sizeof *d;

   int main() {
     vector&lt;double&gt; vd;
     transform(d, d + dsz, back_inserter(vd),
       bind2nd(ptr_fun&lt;double, double, double&gt;(pow), 2.0));
     copy(vd.begin(), vd.end(),
       ostream_iterator&lt;double&gt;(cout, " "));
     cout&lt;&lt; endl;
   } ///:~

   Thepow( ) function is overloaded in the standard C++ header&lt;cmath&gt; for each of the floating-point data types, as follows:
   float pow(float, int);  // efficient int power versions…
   double pow(double, int);
   long double pow(long double, int);
   float pow(float, float);
   double pow(double, double);
   long double pow(long double, long double);

   Since there are multiple versions ofpow( ), the compiler has no way of knowing which to choose. In this case, we have to help the compiler by using explicit function template specialization, as explained in the previous chapter.
   An even trickier problem is that of converting a member function into a function object suitable for using with the generic algorithms. As a simple example, suppose we have the classical "shape" problem and want to apply thedraw( ) member function to each pointer in a container ofShape:.
   //: C06:MemFun1.cpp
   // Applying pointers to member functions
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Shape {
   public:
     virtual void draw() = 0;
     virtual ~Shape() {}
   };

   class Circle : public Shape {
   public:
     virtual void draw() {
       cout&lt;&lt; "Circle::Draw()"&lt;&lt; endl;
     }
     ~Circle() {
       cout&lt;&lt; "Circle::~Circle()"&lt;&lt; endl;
     }
   };

   class Square : public Shape {
   public:
     virtual void draw() {
       cout&lt;&lt; "Square::Draw()"&lt;&lt; endl;
     }
     ~Square() {
       cout&lt;&lt; "Square::~Square()"&lt;&lt; endl;
     }
   };

   int main() {
     vector&lt;Shape*&gt; vs;
     vs.push_back(new Circle);
     vs.push_back(new Square);
     for_each(vs.begin(), vs.end(),
       mem_fun(&Shape::draw));
     purge(vs);
   } ///:~

   Thefor_each( ) algorithm does just what it sounds like it: it passes each element in a sequence to the function object denoted by its third argument. In this case, we want the function object to wrap one of the member functions of the class itself, and so the function object’s "argument" becomes the pointer to the object that the member function is called for. To produce such a function object, themem_fun( ) template takes a pointer to a member as its argument. Thepurge( ) function is just a little something we wrote that calls delete on every element of sequence.
   Themem_fun( ) functions are for producing function objects that are called using a pointer to the object that the member function is called for, whilemem_fun_ref( ) is used for calling the member function directly for an object. One set of overloads of bothmem_fun( ) andmem_fun_ref( ) is for member functions that take zero arguments and one argument, and this is multiplied by two to handleconst vs. non-const member functions. However, templates and overloading takes care of sorting all that out; all you need to remember is when to usemem_fun( ) vs.mem_fun_ref( ).
   Suppose you have a container of objects (not pointers), and you want to call a member function that takes an argument. The argument you pass should come from a second container of objects. To accomplish this, use the second overloaded form of thetransform( ) algorithm:.
   //: C06:MemFun2.cpp
   // Calling member functions through an object reference
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   using namespace std;

   class Angle {
     int degrees;
   public:
     Angle(int deg) : degrees(deg) {}
     int mul(int times) {
       return degrees *= times;
     }
   };

   int main() {
     vector&lt;Angle&gt; va;
     for(int i = 0; i&lt; 50; i += 10)
       va.push_back(Angle(i));
     int x[] = { 1, 2, 3, 4, 5 };
     transform(va.begin(), va.end(), x,
       ostream_iterator&lt;int&gt;(cout, " "),
       mem_fun_ref(&Angle::mul));
     cout&lt;&lt; endl;
     // Output: 0 20 60 120 200
   } ///:~

   Because the container is holding objects,mem_fun_ref( ) must be used with the pointer-to-member function. This version oftransform( ) takes the start and end point of the first range (where the objects live); the starting point of the second range, which holds the arguments to the member function; the destination iterator, which in this case is standard output; and the function object to call for each object. This function object is created withmem_fun_ref( ) and the desired pointer to member. Notice that thetransform( ) andfor_each( ) template functions are incomplete;transform( ) requires that the function it calls return a value, and there is nofor_each( ) that passes two arguments to the function it calls. Thus, you cannot call a member function that returnsvoid and takes an argument usingtransform( ) orfor_each( ).
   Most any member function works withmem_fun_ref( ). You can also use standard library member functions, if your compiler doesn’t add any default arguments beyond the normal arguments specified in the standard.[84] For example, suppose you’d like to read a file and search for blank lines; your compiler may allow you to use thestring::empty( ) member function like this:.
   //: C06:FindBlanks.cpp
   // Demonstrates mem_fun_ref() with string::empty()
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;fstream&gt;
   #include&lt;functional&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../require.h"
   using namespace std;

   typedef vector&lt;string&gt;::iterator LSI;

   int main(int argc, char* argv[]) {
     char* fname = "FindBlanks.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     vector&lt;string&gt; vs;
     string s;
     while(getline(in, s))
       vs.push_back(s);
     vector&lt;string&gt; cpy = vs; // For testing
     LSI lsi = find_if(vs.begin(), vs.end(),
        mem_fun_ref(&string::empty));
     while(lsi != vs.end()) {
       *lsi = "A BLANK LINE";
       lsi = find_if(vs.begin(), vs.end(),
         mem_fun_ref(&string::empty));
     }
     for(size_t i = 0; i&lt; cpy.size(); i++)
       if(cpy[i].size() == 0)
         assert(vs[i] == "A BLANK LINE");
       else
         assert(vs[i] != "A BLANK LINE");
   } ///:~

   This example usesfind_if( ) to locate the first blank line in the given range usingmem_fun_ref( ) withstring::empty( ). After the file is opened and read into the vector, the process is repeated to find every blank line in the file. Each time a blank line is found, it is replaced with the characters "A BLANK LINE." All you have to do to accomplish this is dereference the iterator to select the current string.
   Writing your own function object adapters
   Consider how to write a program that converts strings representing floating-point numbers to their actual numeric values. To get things started, here’s a generator that creates the strings:.
   //: C06:NumStringGen.h
   // A random number generator that produces
   // strings representing floating-point numbers
   #ifndef NUMSTRINGGEN_H
   #define NUMSTRINGGEN_H
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;

   class NumStringGen {
     const int sz; // Number of digits to make
   public:
     NumStringGen(int ssz = 5) : sz(ssz) {
       std::srand(std::time(0));
     }
     std::string operator()() {
       static char n[] = "0123456789";
       const int nsz = sizeof n / sizeof *n;
       std::string r(sz, ' ');
       for(int i = 0; i&lt; sz; i++)
         if(i == sz/2)
           r[i] = '.'; // Insert a decimal point
         else
           r[i] = n[std::rand() % nsz];
       return r;
     }
   };
   #endif // NUMSTRINGGEN_H ///:~

   You tell it how big the strings should be when you create theNumStringGen object. The random number generator selects digits, and a decimal point is placed in the middle.
   The following program usesNumStringGen to fill avector&lt;string&gt;. However, to use the standard C library functionatof( ) to convert the strings to floating-point numbers, thestring objects must first be turned intochar pointers, since there is no automatic type conversion fromstring tochar*. Thetransform( ) algorithm can be used withmem_fun_ref( ) andstring::c_str( ) to convert all thestrings tochar*, and then these can be transformed usingatof.
   //: C06:MemFun3.cpp
   // Using mem_fun()
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "NumStringGen.h"
   using namespace std;

   int main() {
     const int sz = 9;
     vector&lt;string&gt; vs(sz);
     // Fill it with random number strings:
     generate(vs.begin(), vs.end(), NumStringGen());
     copy(vs.begin(), vs.end(),
       ostream_iterator&lt;string&gt;(cout, "\t"));
     cout&lt;&lt; endl;
     const char* vcp[sz];
     transform(vs.begin(), vs.end(), vcp,
       mem_fun_ref(&string::c_str));
     vector&lt;double&gt; vd;
     transform(vcp, vcp + sz, back_inserter(vd),
       std::atof);
     copy(vd.begin(), vd.end(),
       ostream_iterator&lt;double&gt;(cout, "\t"));
     cout&lt;&lt; endl;
   } ///:~

   This program does two transformations: one to convert strings to C-style strings (arrays of characters), and one to convert the C-style strings to numbers viaatof( ). It would be nice to combine these two operations into one. After all, we can compose functions in mathematics, so why not C++?.
   The obvious approach takes the two functions as arguments and applies them in the proper order:
   //: C06:ComposeTry.cpp
   // A first attempt at implementing function composition
   #include&lt;cassert&gt;
   #include&lt;cstdlib&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   template&lt;typename R, typename E, typename F1, typename F2&gt;
   class unary_composer {
      F1 f1;
      F2 f2;
   public:
      unary_composer(F1 fone, F2 ftwo) : f1(fone), f2(ftwo) {}
      R operator()(E x) {
         return f1(f2(x));
      }
   };
   template&lt;typename R, typename E, typename F1, typename F2&gt;
   unary_composer&lt;R, E, F1, F2&gt; compose(F1 f1, F2 f2) {
      return unary_composer&lt;R, E, F1, F2&gt;(f1, f2);
   }
   int main()
   {
     double x =
       compose&lt;double, const string&&gt;(atof,
         mem_fun_ref(&string::c_str))("12.34");
     assert(x == 12.34);
   } ///:~

   Theunary_composer object in this example stores the function pointersatof andstring::c_str such that the latter function is applied first when itsoperator( ) is called. Thecompose( ) function adapter is a convenience, so we don’t have to supply all four template arguments explicitly—F1 andF2 are deduced from the call.
   It would be much better, of course, if we didn’t have to supply any template arguments at all. This is achieved by adhering to the convention for type definitions for adaptable function objects; in other words, we will assume that the functions to be composed are adaptable. This requires that we useptr_fun( ) foratof( ). For maximum flexibility, we also makeunary_composer adaptable in case it gets passed to a function adapter. The following program does so and easily solves the original problem.
   //: C06:ComposeFinal.cpp
   // An adaptable composer
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;cstdlib&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "NumStringGen.h"
   using namespace std;

   template&lt;typename F1, typename F2&gt;
   class unary_composer
     : public unary_function&lt;typename F2::argument_type,
              typename F1::result_type&gt; {
   public:
      unary_composer(F1 f1, F2 f2) : f1(f1), f2(f2) {}
      typename F1::result_type
        operator()(typename F2::argument_type x) {
         return f1(f2(x));
      }
   private:
      F1 f1;
      F2 f2;
   };
   template&lt;typename F1, typename F2&gt;
   unary_composer&lt;F1, F2&gt; compose(F1 f1, F2 f2) {
      return unary_composer&lt;F1, F2&gt;(f1, f2);
   }
   int main() {
     const int sz = 9;
     vector&lt;string&gt; vs(sz);
     // Fill it with random number strings:
     generate(vs.begin(), vs.end(), NumStringGen());
     copy(vs.begin(), vs.end(),
       ostream_iterator&lt;string&gt;(cout, "\t"));
     cout&lt;&lt; endl;
     vector&lt;double&gt; vd;
     transform(vs.begin(), vs.end(), back_inserter(vd),
       compose(ptr_fun(atof), mem_fun_ref(&string::c_str)));
     copy(vd.begin(), vd.end(),
       ostream_iterator&lt;double&gt;(cout, "\t"));
     cout&lt;&lt; endl;
   } ///:~

   Once again we must usetypename to let the compiler know that the member we are referring to is a nested type.
   Some implementations[85] support composition of function objects as an extension, and the C++ standards committee is likely to add these capabilities to the next version of standard C++.
   A catalog of STL algorithms
   This section provides a quick reference for when you’re searching for the appropriate algorithm. We leave the full exploration of all the STL algorithms to other references (see the end of this chapter, and Appendix A), along with the more intimate details of performance, and so on. Our goal here is for you to become rapidly comfortable and facilewith the algorithms, and we’ll assume you will look into the more specialized references if you need more depth of detail.
   Although you will often see the algorithms described using their full template declaration syntax, we’re not doing that here because you already know they are templates, and it’s quite easy to see what the template arguments are from the function declarations. The type names for the arguments provide descriptions for the types of iterators required. We think you’ll find this form is easier to read, and you can quickly find the full declaration in the template header file if for some reason you feel the need.
   The reason for all the fuss about iterators is to accommodate any type of container that meets the requirements in the standard library. So far we have illustrated the generic algorithms with only arrays and vectors as sequences, but in the next chapter you’ll see a broad range of data structures that support less robust iteration. For this reason, the algorithms are categorized in part by the types of iteration facilities they require.
   The names of the iterator classes describe the iterator type to which they must conform. There are no interface base classes to enforce these iteration operations—they are just expected to be there. If they are not, your compiler will complain. The various flavors of iterators are described briefly as follows.
   InputIterator. An input iterator only allowsreading elements of its sequence in a single, forward pass usingoperator++ andoperator*. Input iterators can also be tested withoperator== andoperator!=. That’s all.
   OutputIterator. An output iterator only allowswriting elements to a sequence in a single, forward pass usingoperator++ andoperator*. OutputIterators cannot be tested withoperator== andoperator!=, however, because you assume that you can just keep sending elements to the destination and that you don’t have to see if the destination’s end marker was reached. That is, the container that anOutputIterator references can take an infinite number of objects, so no end-checking is necessary. This requirement is important so that anOutputIterator can be used withostreams (viaostream_iterator), but you’ll also commonly use the "insert" iterators such as are the type of iterator returned byback_inserter( )).
   There is no way to determine whether multipleInputIterators orOutputIterators point within the same range, so there is no way to us multiple such iterators in concert. Just think in terms of iterators to supportistreams andostreams, andInputIterator andOutputIterator will make perfect sense. Also note that algorithms that useInputIterators orOutputIterators put the weakest restrictions on the types of iterators they will accept, which means that you can use any "more sophisticated" type of iterator when you seeInputIterator orOutputIterator used as STL algorithm template arguments.
   ForwardIterator. Because you can only read from anInputIterator and write to anOutputIterator, you can’t use either of them to simultaneously read and modify a range, and you can’t dereference such an iterator more than once. With aForwardIterator these restrictions are relaxed; you can still only move forward usingoperator++, but you can both write and read, and you can compare such iterators in the same range for equality. Since forward iterators can both read and write, they can of course be used wherever an input or output iterator is called for.
   BidirectionalIterator. Effectively, this is aForwardIterator that can also go backward. That is, aBidirectionalIterator supports all the operations that aForwardIterator does, but in addition it has anoperator--.
   RandomAccessIterator. This type of iterator supports all the operations that a regular pointer does: you can add and subtract integral values to move it forward and backward by jumps (rather than just one element at a time), you can subscript it withoperator[ ], you can subtract one iterator from another, and you can compare iterators to see which is greater usingoperator&lt;,operator&gt;, and so on. If you’re implementing a sorting routine or something similar, random access iterators are necessary to be able to create an efficient algorithm.
   The names used for the template parameter types in the algorithm descriptions later in this chapter consist of the listed iterator types (sometimes with a‘1’ or ‘2’ appended to distinguish different template arguments) and can also include other arguments, often function objects.
   When describing the group of elements that an operation is performed on, mathematical "range" notation is often used. In this, the square bracket means "includes the end point," and the parenthesis means "does not include the end point." When using iterators, a range is determined by the iterator pointing to the initial element and by the "past-the-end" iterator, pointing past the last element. Since the past-the-end element is never used, the range determined by a pair of iterators can thus be expressed as[first, last), in whichfirst is the iterator pointing to the initial element, andlast is the past-the-end iterator.
   Most books and discussions of the STL algorithms arrange them according to side-effects:non-mutating algorithms don’t change the elements in the range,mutating algorithms do change the elements, and so on. These descriptions are based primarily on the underlying behavior or implementation of the algorithm—that is, on the designer’s perspective. In practice, we don’t find this a useful categorization, so instead we’ll organize them according to the problem you want to solve: are you searching for an element or set of elements, performing an operation on each element, counting elements, replacing elements, and so on. This should help you find the algorithm you want more easily.
   Note that all the algorithms are in the namespacestd. If you do not see a different header such as&lt;utility&gt; or&lt;numeric&gt; above the function declarations, it appears in&lt;algorithm&gt;.
   Support tools for example creation
   It’s useful to create some basic tools with which to test the algorithms. In the examples that follow we’ll use the generators mentioned earlier inGenerators.h, as well as what appears below.
   Displaying a range is something that will be done constantly, so here is a templatized function that let you print any sequence, regardless of the type in that sequence:.
   //: C06:PrintSequence.h
   // Prints the contents of any sequence
   #ifndef PRINTSEQUENCE_H
   #define PRINTSEQUENCE_H
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;

   template&lt;typename InputIter&gt;
   void print(InputIter first, InputIter last,
     char* nm = "", char* sep = "\n",
     std::ostream& os = std::cout) {
     if(nm != 0&& *nm != '\0')
       os&lt;&lt; nm&lt;&lt; ": "&lt;&lt; sep;
     while(first != last)
       os&lt;&lt; *first++&lt;&lt; sep;
     os&lt;&lt; std::endl;
   }
   #endif // PRINTSEQUENCE_H ///:~

   The default prints tocout with newlines as separators, but you can change that. You can also provide a message to print at the head of the output.
   Finally, a number of the STL algorithms that move elements of a sequence around distinguish between "stable" and "unstable" reordering of a sequence. This refers to preserving the original relative order of those elements that are equivalent as far as the comparison function is concerned. For example, consider a sequence{ c(1), b(1), c(2), a(1), b(2), a(2) }. These elements are tested for equivalence based on their letters, but their numbers indicate how they first appeared in the sequence. If you sort (for example) this sequence using an unstable sort, there’s no guarantee of any particular order among equivalent letters, so you could end up with{ a(2), a(1), b(1), b(2), c(2), c(1) }. However, if you use a stable sort, you will get{ a(1), a(2), b(1), b(2), c(1), c(2) }. The STLsort( ) algorithm uses a variation ofquicksort and is therefore unstable, but astable_sort( ) is also provided.[86] 
   To demonstrate the stability versus instability of algorithms that reorder a sequence, we need some way to keep track of how the elements originally appeared. The following is a kind ofstring object that keeps track of the order in which that particular object originally appeared, using astatic map that mapsNStrings toCounters. EachNString then contains anoccurrence field that indicates the order in which thisNString was discovered.
   //: C06:NString.h
   // A "numbered string" that indicates which
   // occurrence this is of a particular word
   #ifndef NSTRING_H
   #define NSTRING_H
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;utility&gt;
   #include&lt;vector&gt;
   typedef std::pair&lt;std::string, int&gt; psi;

   // Only compare on the first element
   bool operator==(const psi& l, const psi& r) {
     return l.first == r.first;
   }

   class NString {
     std::string s;
     int thisOccurrence;
     // Keep track of the number of occurrences:
     typedef std::vector&lt;psi&gt; vp;
     typedef vp::iterator vpit;
     static vp words;
     void addString(const std::string& x) {
       psi p(x, 0);
       vpit it = std::find(words.begin(), words.end(), p);
       if(it != words.end())
         thisOccurrence = ++it-&gt;second;
       else {
         thisOccurrence = 0;
         words.push_back(p);
       }
     }
   public:
     NString() : thisOccurrence(0) {}
     NString(const std::string& x) : s(x) {
       addString(x);
     }
     NString(const char* x) : s(x) {
       addString(x);
     }
     // The implicit operator= and
     // copy-constructor are OK here
     friend std::ostream& operator&lt;&lt;(
       std::ostream& os, const NString& ns) {
       return os&lt;&lt; ns.s&lt;&lt; " ["
        &lt;&lt; ns.thisOccurrence&lt;&lt; "]";
     }
     // Need this for sorting. Notice it only
     // compares strings, not occurrences:
     friend bool
     operator&lt;(const NString& l, const NString& r) {
       return l.s&lt; r.s;
     }
     friend
     bool operator==(const NString& l, const NString& r) {
       return l.s == r.s;
     }
     // For sorting with greater&lt;NString&gt;:
     friend bool
     operator&gt;(const NString& l, const NString& r) {
       return l.s&gt; r.s;
     }
     // To get at the string directly:
     operator const std::string&() const {return s;}
   };

   // Allocate static member object. Done here for
   // brevity, but should normally be done in a
   // separate cpp file:
   NString::vp NString::words;
   #endif // NSTRING_H ///:~

   We would normally use amap container to associate a string with its number of occurrences, but maps don’t appear until the next chapter, so we use avector of pairs instead. You’ll see plenty of similar examples there.
   To do an ordinary ascending sort, the only operator that’s necessary isNString::operator&lt;( ); however, to sort in reverse order, theoperator&gt;( ) is also provided so that thegreater template can call it.
   As this is just a demonstration class, we are taking the liberty of placing the definition of the static memberswords andoccurrences in this header file, but this will break down if the header file is included in more than one place, so you should normally place allstatic definitions incpp files.
   Filling and generating
   These algorithms let you automatically fill a range with a particular value or generate a set of values for a particular range. The "fill" functions insert a single value multiple times into the container, and the "generate" functions use an object called agenerator (described earlier) to create the values to insert into the container.
   voidfill(ForwardIterator first, ForwardIterator last, const T& value); voidfill_n(OutputIterator first, Size n, const T& value);
   fill( ) assignsvalue to every element in the range[first, last).fill_n( ) assignsvalue ton elements starting atfirst.
   voidgenerate(ForwardIterator first, ForwardIterator last, Generator gen); voidgenerate_n(OutputIterator first, Size n, Generator gen);
   generate( ) makes a call togen( ) for each element in the range[first, last), presumably to produce a different value for each element.generate_n( ) callsgen( ) n times and assigns each result ton elements starting atfirst.
   Example
   The following example fills and generates intovectors. It also shows the use ofprint( ):
   //: C06:FillGenerateTest.cpp
   // Demonstrates "fill" and "generate"
   #include "Generators.h"
   #include "PrintSequence.h"
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   #include&lt;string&gt;
   using namespace std;

   int main() {
     vector&lt;string&gt; v1(5);
     fill(v1.begin(), v1.end(), "howdy");
     print(v1.begin(), v1.end(), "v1", " ");
     vector&lt;string&gt; v2;
     fill_n(back_inserter(v2), 7, "bye");
     print(v2.begin(), v2.end(), "v2");
     vector&lt;int&gt; v3(10);
     generate(v3.begin(), v3.end(), SkipGen(4,5));
     print(v3.begin(), v3.end(), "v3", " ");
     vector&lt;int&gt; v4;
     generate_n(back_inserter(v4),15, URandGen(30));
     print(v4.begin(), v4.end(), "v4", " ");
   } ///:~

   Avector&lt;string&gt; is created with a predefined size. Since storage has already been created for all thestring objects in thevector,fill( ) can use its assignment operator to assign a copy of "howdy" to each space in thevector. Also, the default newline separator is replaced with a space.
   The secondvector&lt;string&gt; v2 is not given an initial size, soback_inserter must be used to force new elements in instead of trying to assign to existing locations. Just as an example, the otherprint( ) is used, which requires a range.
   Thegenerate( ) andgenerate_n( ) functions have the same form as the "fill" functions except that they use a generator instead of a constant value; here, both generators are demonstrated.
   Counting
   All containers have a member functionsize( ) that will tells you how many elements they hold. The return type ofsize( ) is the iterator’sdifference_type[87] (usuallyptrdiff_t), which we denote byIntegralValue in the following. The following two algorithms count objects that satisfy certain criteria.
   IntegralValuecount(InputIterator first, InputIterator last, const EqualityComparable& value);
   Produces the number of elements in[first, last) that are equivalent tovalue (when tested usingoperator==).
   IntegralValuecount_if(InputIterator first, InputIterator last, Predicate pred);
   Produces the number of elements in[first, last) that each causepred to returntrue.
   Example
   Here, avector&lt;char&gt; v is filled with random characters (including some duplicates). Aset&lt;char&gt; is initialized fromv, so it holds only one of each letter represented inv. Thisset counts all the instances of all the characters, which are then displayed:.
   //: C06:Counting.cpp
   // The counting algorithms
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iterator&gt;
   #include&lt;set&gt;
   #include&lt;vector&gt;
   #include "Generators.h"
   #include "PrintSequence.h"
   using namespace std;

   int main() {
     vector&lt;char&gt; v;
     generate_n(back_inserter(v), 50, CharGen());
     print(v.begin(), v.end(), "v", "");
     // Create a set of the characters in v:
     set&lt;char&gt; cs(v.begin(), v.end());
     typedef set&lt;char&gt;::iterator sci;
     for(sci it = cs.begin(); it != cs.end(); it++) {
       int n = count(v.begin(), v.end(), *it);
       cout&lt;&lt; *it&lt;&lt; ": "&lt;&lt; n&lt;&lt; ", ";
     }
     int lc = count_if(v.begin(), v.end(),
       bind2nd(greater&lt;char&gt;(), 'a'));
     cout&lt;&lt; "\nLowercase letters: "&lt;&lt; lc&lt;&lt; endl;
     sort(v.begin(), v.end());
     print(v.begin(), v.end(), "sorted", "");
   } ///:~

   Thecount_if( ) algorithm is demonstrated by counting all the lowercase letters; the predicate is created using thebind2nd( ) andgreater function object templates.
   Manipulating sequences
   These algorithms let you move sequences around.
   OutputIteratorcopy(InputIterator first, InputIterator last, OutputIterator destination);
   Using assignment, copies from[first, last) todestination, incrementingdestination after each assignment. This is essentially a "shuffle-left" operation, and so the source sequence must not contain the destination. Because assignment is used, you cannot directly insert elements into an empty container or at the end of a container, but instead you must wrap thedestination iterator in aninsert_iterator (typically by usingback_inserter( ) or by usinginserter( ) in the case of an associative container).
   BidirectionalIterator2copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 destinationEnd);
   Likecopy( ), but actually copies the elements in reverse order. This is essentially a "shuffle-right" operation, and, likecopy( ), the source sequence must not contain the destination. The source range[first, last) is copied to the destination, but the first destination element isdestinationEnd - 1. This iterator is then decremented after each assignment. The space in the destination range must already exist (to allow assignment), and the destination range cannot be within the source range.
   voidreverse(BidirectionalIterator first, BidirectionalIterator last); OutputIteratorreverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator destination);
   Both forms of this function reverse the range[first, last).reverse( ) reverses the range in place, andreverse_copy( ) leaves the original range alone and copies the reversed elements intodestination, returning the past-the-end iterator of the resulting range.
   ForwardIterator2swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);
   Exchanges the contents of two ranges of equal size by swapping corresponding elements.
   voidrotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last); OutputIteratorrotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator destination);
   Moves the contents of[first, middle) to the end of the sequence, and the contents of[middle, last) to the beginning. Withrotate( ), the swap is performed in place; and withrotate_copy( ) the original range is untouched, and the rotated version is copied intodestination, returning the past-the-end iterator of the resulting range. Note that whileswap_ranges( ) requires that the two ranges be exactly the same size, the "rotate" functions do not.
   boolnext_permutation(BidirectionalIterator first, BidirectionalIterator last); boolnext_permutation(BidirectionalIterator first, BidirectionalIterator last, StrictWeakOrdering binary_pred); boolprev_permutation(BidirectionalIterator first, BidirectionalIterator last); boolprev_permutation(BidirectionalIterator first, BidirectionalIterator last, StrictWeakOrdering binary_pred);
   Apermutation is one unique ordering of a set of elements. If you haven unique elements, there aren! (n factorial) distinct possible combinations of those elements. All these combinations can be conceptually sorted into a sequence using a lexicographical (dictionary-like) ordering and thus produce a concept of a "next" and "previous" permutation. Therefore, whatever the current ordering of elements in the range, there is a distinct "next" and "previous" permutation in the sequence of permutations.
   Thenext_permutation( ) andprev_permutation( ) functions rearrange the elements into their next or previous permutation and if successful returntrue. If there are no more "next" permutations, the elements are in sorted order; sonext_permutation( ) returnsfalse. If there are no more "previous" permutations, the elements are in descending sorted order; soprevious_permutation( ) returnsfalse.
   The versions of the functions that have aStrictWeakOrdering argument perform the comparisons usingbinary_pred instead ofoperator&lt;.
   voidrandom_shuffle(RandomAccessIterator first, RandomAccessIterator last); voidrandom_shuffle(RandomAccessIterator first, RandomAccessIterator last RandomNumberGenerator& rand);
   This function randomly rearranges the elements in the range. It yields uniformly distributed results if the random-number generator does. The first form uses an internal random number generator, and the second uses a user-supplied random-number generator. The generator must return a value in the range [0, n) for some positive n.
   BidirectionalIteratorpartition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred); BidirectionalIteratorstable_partition(BidirectionalIterator first,   BidirectionalIterator last, Predicate pred);
   The "partition" functions move elements that satisfypred to the beginning of the sequence. An iterator pointing one past the last of those elements is returned (which is, in effect, and "end" iterator" for the initial subsequence of elements that satisfypred). This location is often called the "partition point".
   Withpartition( ), the order of the elements in each resulting subsequence after the function call is not specified, but withstable_parition( ), the relative order of the elements before and after the partition point will be the same as before the partitioning process.
   Example
   This gives a basic demonstration of sequence manipulation:.
   //: C06:Manipulations.cpp
   // Shows basic manipulations
   #include "PrintSequence.h"
   #include "NString.h"
   #include "Generators.h"
   #include&lt;vector&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt;
   using namespace std;

   int main() {
     vector&lt;int&gt; v1(10);
     // Simple counting:
     generate(v1.begin(), v1.end(), SkipGen());
     print(v1.begin(), v1.end(), "v1", " ");
     vector&lt;int&gt; v2(v1.size());
     copy_backward(v1.begin(), v1.end(), v2.end());
     print(v2.begin(), v2.end(), "copy_backward", " ");
     reverse_copy(v1.begin(), v1.end(), v2.begin());
     print(v2.begin(), v2.end(), "reverse_copy", " ");
     reverse(v1.begin(), v1.end());
     print(v1.begin(), v1.end(), "reverse", " ");
     int half = v1.size() / 2;
     // Ranges must be exactly the same size:
     swap_ranges(v1.begin(), v1.begin() + half,
       v1.begin() + half);
     print(v1.begin(), v1.end(), "swap_ranges", " ");
     // Start with fresh sequence:
     generate(v1.begin(), v1.end(), SkipGen());
     print(v1.begin(), v1.end(), "v1", " ");
     int third = v1.size() / 3;
     for(int i = 0; i&lt; 10; i++) {
       rotate(v1.begin(), v1.begin() + third,
         v1.end());
       print(v1.begin(), v1.end(), "rotate", " ");
     }
     cout&lt;&lt; "Second rotate example:"&lt;&lt; endl;
     char c[] = "aabbccddeeffgghhiijj";
     const char csz = strlen(c);
     for(int i = 0; i&lt; 10; i++) {
       rotate(c, c + 2, c + csz);
       print(c, c + csz, "", "");
     }
     cout&lt;&lt; "All n! permutations of abcd:"&lt;&lt; endl;
     int nf = 4 * 3 * 2 * 1;
     char p[] = "abcd";
     for(int i = 0; i&lt; nf; i++) {
       next_permutation(p, p + 4);
       print(p, p + 4, "", "");
     }
     cout&lt;&lt; "Using prev_permutation:"&lt;&lt; endl;
     for(int i = 0; i&lt; nf; i++) {
       prev_permutation(p, p + 4);
       print(p, p + 4, "", "");
     }
     cout&lt;&lt; "random_shuffling a word:"&lt;&lt; endl;
     string s("hello");
     cout&lt;&lt; s&lt;&lt; endl;
     for(int i = 0; i&lt; 5; i++) {
       random_shuffle(s.begin(), s.end());
       cout&lt;&lt; s&lt;&lt; endl;
     }
     NString sa[] = { "a", "b", "c", "d", "a", "b",
       "c", "d", "a", "b", "c", "d", "a", "b", "c"};
     const int sasz = sizeof sa / sizeof *sa;
     vector&lt;NString&gt; ns(sa, sa + sasz);
     print(ns.begin(), ns.end(), "ns", " ");
     vector&lt;NString&gt;::iterator it =
       partition(ns.begin(), ns.end(),
         bind2nd(greater&lt;NString&gt;(), "b"));
     cout&lt;&lt; "Partition point: "&lt;&lt; *it&lt;&lt; endl;
     print(ns.begin(), ns.end(), "", " ");
     // Reload vector:
     copy (sa, sa + sasz, ns.begin());
     it = stable_partition(ns.begin(), ns.end(),
       bind2nd(greater&lt;NString&gt;(), "b"));
     cout&lt;&lt; "Stable partition"&lt;&lt; endl;
     cout&lt;&lt; "Partition point: "&lt;&lt; *it&lt;&lt; endl;
     print(ns.begin(), ns.end(), "", " ");
   } ///:~

   The best way to see the results of this program is to run it. (You’ll probably want to redirect the output to a file.)
   Thevector&lt;int&gt; v1 is initially loaded with a simple ascending sequence and printed. You’ll see that the effect ofcopy_backward( ) (which copies intov2, which is the same size asv1) is the same as an ordinary copy. Again,copy_backward( ) does the same thing ascopy( ); it just performs the operations in reverse order.
   reverse_copy( ), however, actually does create a reversed copy, andreverse( ) performs the reversal in place. Next,swap_ranges( ) swaps the upper half of the reversed sequence with the lower half. Of course, the ranges could be smaller subsets of the entire vector, as long as they are of equivalent size.
   After re-creating the ascending sequence,rotate( ) is demonstrated by rotating one third ofv1 multiple times. A secondrotate( ) example uses characters and just rotates two characters at a time. This also demonstrates the flexibility of both the STL algorithms and theprint( ) template, since they can both be used with arrays ofchar as easily as with anything else.
   To demonstratenext_permutation( ) andprev_permutation( ), a set of four characters "abcd" is permuted through alln! (n factorial) possible combinations. You’ll see from the output that the permutations move through a strictly defined order (that is, permuting is a deterministic process).
   A quick-and-dirty demonstration ofrandom_shuffle( ) is to apply it to astring and see what words result. Because astring object hasbegin( ) andend( ) member functions that return the appropriate iterators, it too can be easily used with many of the STL algorithms. Of course, an array ofchar could also have been used.
   Finally, thepartition( ) andstable_partition( ) are demonstrated, using an array ofNString. You’ll note that the aggregate initialization expression useschar arrays, butNString has achar* constructor that is automatically used.
   You’ll see from the output that with the unstable partition, the objects are correctly above and below the partition point, but in no particular order; whereas with the stable partition, their original order is maintained.
   Searching and replacing
   All these algorithms are used for searching for one or more objects within a range defined by the first two iterator arguments.
   InputIteratorfind(InputIterator first, InputIterator last,  const EqualityComparable& value);
   Searches forvaluewithin a range of elements. Returns an iterator in the range[first, last) that points to the first occurrence ofvalue. Ifvalue isn’t in the range,find( ) returnslast. This is alinear search; that is, it starts at the beginning and looks at each sequential element without making any assumptions about the way the elements are ordered. In contrast, abinary_search( ) (defined later) works on a sorted sequence and can thus be much faster.
   InputIteratorfind_if(InputIterator first, InputIterator  last, Predicate pred);
   Just likefind( ),find_if( ) performs a linear search through the range. However, instead of searching forvalue,find_if( ) looks for an element such that thePredicate pred returnstrue when applied to that element. Returnslast if no such element can be found.
   ForwardIteratoradjacent_find(ForwardIterator first,  ForwardIterator last); ForwardIteratoradjacent_find(ForwardIterator first,  ForwardIterator last, BinaryPredicate binary_pred);
   Likefind( ), performs a linear search through the range, but instead of looking for only one element, it searches for two adjacent elements that are equivalent. The first form of the function looks for two elements that are equivalent (viaoperator==). The second form looks for two adjacent elements that, when passed together tobinary_pred, produce atrue result. An iterator to the first of the two elements is returned if a pair is found; otherwise,last is returned.
   ForwardIterator1find_first_of(ForwardIterator1 first1,  ForwardIterator1 last1, ForwardIterator2 first2,   ForwardIterator2 last2); ForwardIterator1find_first_of(ForwardIterator1 first1,  ForwardIterator1 last1, ForwardIterator2 first2,   ForwardIterator2 last2, BinaryPredicate binary_pred);.
   Likefind( ), performs a linear search through the range. Both forms search for an element in the second range that’s equivalent to one in the first, the first form usingoperator==, and the second using the supplied predicate. In the second form, the current element from the first range becomes the first argument tobinary_pred, and the element from the second range becomes the second argument.
   ForwardIterator1search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2); ForwardIterator1search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2 BinaryPredicate binary_pred);
   Checks to see if the second range occurs (in the exact order of the second range) within the first range, and if so returns an iterator pointing to the place in the first range where the second range begins. Returnslast1 if no subset can be found. The first form performs its test usingoperator==, and the second checks to see if each pair of objects being compared causesbinary_pred to returntrue.
   ForwardIterator1find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2); ForwardIterator1find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate binary_pred);
   The forms and arguments are just likesearch( ) in that they look for the second range appearing as a subset of the first range, but whilesearch( ) looks for the first occurrence of the subset,find_end( ) looks for thelast occurrence and returns an iterator to its first element.
   ForwardIteratorsearch_n(ForwardIterator first, ForwardIterator last, Size count, const T& value); ForwardIteratorsearch_n(ForwardIterator first, ForwardIterator last, Size count, const T& value, BinaryPredicate binary_pred);
   Looks for a group ofcount consecutive values in[first, last) that are all equal tovalue (in the first form) or that all cause a return value oftrue when passed intobinary_pred along withvalue (in the second form). Returnslast if such a group cannot be found.
   ForwardIteratormin_element(ForwardIterator first, ForwardIterator last); ForwardIteratormin_element(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);
   Returns an iterator pointing to the first occurrence of the "smallest" value in the range (as explained below—there may be multiple occurrences of this value.) Returnslast if the range is empty. The first version performs comparisons withoperator&lt;, and the valuerreturned is such that *e&lt; *r is false for every elemente in the range[first, r). The second version compares usingbinary_pred, and the valuer returned is such thatbinary_pred (*e, *r) is false for every elemente in the range[first, r).
   ForwardIteratormax_element(ForwardIterator first, ForwardIterator last); ForwardIteratormax_element(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);
   Returns an iterator pointing to the first occurrence of the largest value in the range. (There may be multiple occurrences of the largest value.) Returnslast if the range is empty. The first version performs comparisons withoperator&lt;, and the valuerreturned is such that *r&lt; *e is false for every elemente in the range[first, r). The second version compares usingbinary_pred, and the valuer returned is such thatbinary_pred (*r, *e) is false for every elemente in the range[first, r).
   voidreplace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value); voidreplace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value); OutputIteratorreplace_copy(InputIterator first, InputIterator last, OutputIterator result, const T& old_value, const T& new_value); OutputIteratorreplace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);
   Each of the "replace" forms moves through the range[first, last), finding values that match a criterion and replacing them withnew_value. Bothreplace( ) andreplace_copy( ) simply look forold_value to replace;replace_if( ) andreplace_copy_if( ) look for values that satisfy the predicatepred. The "copy" versions of the functions do not modify the original range but instead make a copy with the replacements intoresult (incrementingresult after each assignment).
   Example
   To provide easy viewing of the results, this example manipulatesvectors ofint. Again, not every possible version of each algorithm is shown. (Some that should be obvious have been omitted.)
   //: C06:SearchReplace.cpp
   // The STL search and replace algorithms
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;vector&gt;
   #include "PrintSequence.h"
   using namespace std;

   struct PlusOne {
     bool operator()(int i, int j) {
       return j == i + 1;
     }
   };

   class MulMoreThan {
     int value;
   public:
     MulMoreThan(int val) : value(val) {}
     bool operator()(int v, int m) {
       return v * m&gt; value;
     }
   };

   int main() {
     int a[] = { 1, 2, 3, 4, 5, 6, 6, 7, 7, 7,
       8, 8, 8, 8, 11, 11, 11, 11, 11 };
     const int asz = sizeof a / sizeof *a;
     vector&lt;int&gt; v(a, a + asz);
     print(v.begin(), v.end(), "v", " ");
     vector&lt;int&gt;::iterator it =
       find(v.begin(), v.end(), 4);
     cout&lt;&lt; "find: "&lt;&lt; *it&lt;&lt; endl;
     it = find_if(v.begin(), v.end(),
       bind2nd(greater&lt;int&gt;(), 8));
     cout&lt;&lt; "find_if: "&lt;&lt; *it&lt;&lt; endl;
     it = adjacent_find(v.begin(), v.end());
     while(it != v.end()) {
       cout&lt;&lt; "adjacent_find: "&lt;&lt; *it
        &lt;&lt; ", "&lt;&lt; *(it + 1)&lt;&lt; endl;
       it = adjacent_find(it + 1, v.end());
     }
     it = adjacent_find(v.begin(), v.end(),
       PlusOne());
     while(it != v.end()) {
       cout&lt;&lt; "adjacent_find PlusOne: "&lt;&lt; *it
        &lt;&lt; ", "&lt;&lt; *(it + 1)&lt;&lt; endl;
       it = adjacent_find(it + 1, v.end(),
         PlusOne());
     }
     int b[] = { 8, 11 };
     const int bsz = sizeof b / sizeof *b;
     print(b, b + bsz, "b", " ");
     it = find_first_of(v.begin(), v.end(),
       b, b + bsz);
     print(it, it + bsz, "find_first_of", " ");
     it = find_first_of(v.begin(), v.end(),
       b, b + bsz, PlusOne());
     print(it,it + bsz,"find_first_of PlusOne"," ");
     it = search(v.begin(), v.end(), b, b + bsz);
     print(it, it + bsz, "search", " ");
     int c[] = { 5, 6, 7 };
     const int csz = sizeof c / sizeof *c;
     print(c, c + csz, "c", " ");
     it = search(v.begin(), v.end(),
       c, c + csz, PlusOne());
     print(it, it + csz,"search PlusOne", " ");
     int d[] = { 11, 11, 11 };
     const int dsz = sizeof d / sizeof *d;
     print(d, d + dsz, "d", " ");
     it = find_end(v.begin(), v.end(), d, d + dsz);
     print(it, v.end(),"find_end", " ");
     int e[] = { 9, 9 };
     print(e, e + 2, "e", " ");
     it = find_end(v.begin(), v.end(),
       e, e + 2, PlusOne());
     print(it, v.end(),"find_end PlusOne"," ");
     it = search_n(v.begin(), v.end(), 3, 7);
     print(it, it + 3, "search_n 3, 7", " ");
     it = search_n(v.begin(), v.end(),
       6, 15, MulMoreThan(100));
     print(it, it + 6,
       "search_n 6, 15, MulMoreThan(100)", " ");
     cout&lt;&lt; "min_element: "&lt;&lt;
       *min_element(v.begin(), v.end())&lt;&lt; endl;
     cout&lt;&lt; "max_element: "&lt;&lt;
       *max_element(v.begin(), v.end())&lt;&lt; endl;
     vector&lt;int&gt; v2;
     replace_copy(v.begin(), v.end(),
       back_inserter(v2), 8, 47);
     print(v2.begin(), v2.end(), "replace_copy 8 -&gt; 47", " ");
     replace_if(v.begin(), v.end(),
       bind2nd(greater_equal&lt;int&gt;(), 7), -1);
     print(v.begin(), v.end(), "replace_if&gt;= 7 -&gt; -1", " ");
   } ///:~

   The example begins with two predicates:PlusOne, which is a binary predicate that returnstrue if the second argument is equivalent to one plus the first argument; andMulMoreThan, which returnstrue if the first argument times the second argument is greater than a value stored in the object. These binary predicates are used as tests in the example.
   Inmain( ), an arraya is created and fed to the constructor forvector&lt;int&gt; v. This vector is used as the target for the search and replace activities, and you’ll note that there are duplicate elements—these are discovered by some of the search/replace routines.
   The first test demonstratesfind( ), discovering the value 4 inv. The return value is the iterator pointing to the first instance of 4, or the end of the input range (v.end( )) if the search value is not found.
   Thefind_if( ) algorithm uses a predicate to determine if it has discovered the correct element. In this example, this predicate is created on the fly usinggreater&lt;int&gt; (that is, "see if the firstintargument is greater than the second") andbind2nd( ) to fix the second argument to 8. Thus, it returns true if the value inv is greater than 8.
   Since two identical objects appear next to each other in a number of cases inv, the test ofadjacent_find( ) is designed to find them all. It starts looking from the beginning and then drops into awhile loop, making sure that the iteratorit has not reached the end of the input sequence (which would mean that no more matches can be found). For each match it finds, the loop prints the matches and then performs the nextadjacent_find( ), this time usingit + 1 as the first argument (this way, it will still find two pairs in a triple).
   You might look at thewhile loop and think that you can do it a bit more cleverly, to wit:.
     while(it != v.end()) {
       cout&lt;&lt; "adjacent_find: "&lt;&lt; *it++
        &lt;&lt; ", "&lt;&lt; *it++&lt;&lt; endl;
       it = adjacent_find(it, v.end());
     }

   Of course, this is exactly what we tried first. However, we did not get the output we expected, on any compiler. This is because there is no guarantee about when the increments occur in this expression.
   The next test usesadjacent_find( ) with thePlusOne predicate, which discovers all the places where the next number in the sequencev changes from the previous by one. The samewhile approach finds all the cases.
   Thefind_first_of( ) algorithm requires a second range of objects for which to hunt; this is provided in the arrayb. Notice that, because the first range and the second range infind_first_of( ) are controlled by separate template arguments, those ranges can refer to two different types of containers, as seen here. The second form offind_first_of( ) is also tested, usingPlusOne.
   Thesearch( ) algorithm finds exactly the second range inside the first one, with the elements in the same order. The second form ofsearch( ) uses a predicate, which is typically just something that defines equivalence, but it also presents some interesting possibilities—here, thePlusOne predicate causes the range{ 4, 5, 6 } to be found.
   Thefind_end( ) test discovers thelast occurrence of the entire sequence{ 11, 11, 11 }. To show that it has in fact found the last occurrence, the rest ofv starting fromit is printed.
   The firstsearch_n( ) test looks for 3 copies of the value 7, which it finds and prints. When using the second version ofsearch_n( ), the predicate is ordinarily meant to be used to determine equivalence between two elements, but we’ve taken some liberties and used a function object that multiplies the value in the sequence by (in this case) 15 and checks to see if it’s greater than 100. That is, thesearch_n( ) test says "find me 6 consecutive values that, when multiplied by 15, each produce a number greater than 100." Not exactly what you normally expect to do, but it might give you some ideas the next time you have an odd searching problem.
   Themin_element( ) andmax_element( ) algorithms are straightforward; the only thing that’s a bit odd is that it looks like the function is being dereferenced with a ‘*’. Actually, the returned iterator is being dereferenced to produce the value for printing.
   To test replacements,replace_copy( ) is used first (so it doesn’t modify the original vector) to replace all values of 8 with the value 47. Notice the use ofback_inserter( ) with the empty vectorv2. To demonstratereplace_if( ), a function object is created using the standard templategreater_equal along withbind2nd to replace all the values that are greater than or equal to 7 with the value -1.
   Comparing ranges
   These algorithms provide ways to compare two ranges. At first glance, the operations they perform seem close to thesearch( ) function. However,search( ) tells you where the second sequence appears within the first, andequal( ) andlexicographical_compare( )simply tell you how two sequences compare. On the other hand,mismatch( ) does tell you where the two sequences go out of sync, but those sequences must be exactly the same length.
   boolequal(InputIterator first1, InputIterator last1, InputIterator first2); boolequal(InputIterator first1, InputIterator last1, InputIterator first2 BinaryPredicate binary_pred);
   In both these functions, the first range is the typical one,[first1, last1). The second range starts atfirst2, but there is no "last2" because its length is determined by the length of the first range. Theequal( ) function returns true if both ranges are exactly the same (the same elements in the same order); in the first case, theoperator== performs the comparison, and in the second casebinary_pred decides if two elements are the same.
   boollexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2); boollexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate binary_pred);
   These two functions determine if the first range is "lexicographically less" than the second. (They returntrue if range 1 is less than range 2, and false otherwise.) Lexicographical comparison, or "dictionary" comparison, means that the comparison is done the same way we establish the order of strings in a dictionary, one element at a time. The first elements determine the result if these elements are different, but if they’re equal, the algorithm moves on to the next elements and looks at those, and so on until it finds a mismatch. At that point, it looks at the elements, and if the element from range 1 is less than the element from range two,lexicographical_compare( ) returnstrue; otherwise, it returnsfalse. If it gets all the way through one range or the other (the ranges may be different lengths for this algorithm) without finding an inequality, range 1 isnotless than range 2, so the function returnsfalse.
   If the two ranges are different lengths, a missing element in one range acts as one that "precedes" an element that exists in the other range, so "abc" precedes "abcd". If the algorithm reaches the end of one of the ranges without a mismatch, then the shorter range comes first. In that case, if the shorter range is the first range, the result istrue, otherwise it isfalse.
   In the first version of the function,operator&lt; performs the comparisons, and in the second version,binary_pred is used.
   pair&lt;InputIterator1, InputIterator2&gt;mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); pair&lt;InputIterator1, InputIterator2&gt;mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);
   As inequal( ), the length of both ranges is exactly the same, so only the first iterator in the second range is necessary, and the length of the first range is used as the length of the second range. Whereasequal( ) just tells you whether the two ranges are the same,mismatch( ) tells you where they begin to differ. To accomplish this, you must be told (1) the element in the first range where the mismatch occurred and (2) the element in the second range where the mismatch occurred. These two iterators are packaged together into apair object and returned. If no mismatch occurs, the return value islast1 combined with the past-the-end iterator of the second range. Thepair template class is astruct with two elements denoted by the member namesfirst andsecond and is defined in the&lt;utility&gt; header.
   As inequal( ), the first function tests for equality usingoperator== while the second one usesbinary_pred.
   Example
   Because the standard C++string class is built like a container (it hasbegin( ) andend( ) member functions that produce objects of typestring::iterator), it can be used to conveniently create ranges of characters to test with the STL comparison algorithms. However, note thatstringhas a fairly complete set of native operations, so look at thestring class before using the STL algorithms to perform operations.
   //: C06:Comparison.cpp
   // The STL range comparison algorithms
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "PrintSequence.h"
   using namespace std;

   int main() {
     // strings provide a convenient way to create
     // ranges of characters, but you should
     // normally look for native string operations:
     string s1("This is a test");
     string s2("This is a Test");
     cout&lt;&lt; "s1: "&lt;&lt; s1&lt;&lt; endl
      &lt;&lt; "s2: "&lt;&lt; s2&lt;&lt; endl;
     cout&lt;&lt; "compare s1& s1: "
      &lt;&lt; equal(s1.begin(), s1.end(), s1.begin())
      &lt;&lt; endl;
     cout&lt;&lt; "compare s1& s2: "
      &lt;&lt; equal(s1.begin(), s1.end(), s2.begin())
      &lt;&lt; endl;
     cout&lt;&lt; "lexicographical_compare s1& s1: "&lt;&lt;
       lexicographical_compare(s1.begin(), s1.end(),
         s1.begin(), s1.end())&lt;&lt;  endl;
     cout&lt;&lt; "lexicographical_compare s1& s2: "&lt;&lt;
       lexicographical_compare(s1.begin(), s1.end(),
         s2.begin(), s2.end())&lt;&lt; endl;
     cout&lt;&lt; "lexicographical_compare s2& s1: "&lt;&lt;
       lexicographical_compare(s2.begin(), s2.end(),
         s1.begin(), s1.end())&lt;&lt; endl;
     cout&lt;&lt; "lexicographical_compare shortened "
       "s1& full-length s2: "&lt;&lt; endl;
     string s3(s1);
     while(s3.length() != 0) {
       bool result = lexicographical_compare(
         s3.begin(), s3.end(), s2.begin(),s2.end());
       cout&lt;&lt; s3&lt;&lt; endl&lt;&lt; s2&lt;&lt; ", result = "
        &lt;&lt; result&lt;&lt; endl;
       if(result == true) break;
       s3 = s3.substr(0, s3.length() - 1);
     }
     pair&lt;string::iterator, string::iterator&gt; p =
       mismatch(s1.begin(), s1.end(), s2.begin());
     print(p.first, s1.end(), "p.first", "");
     print(p.second, s2.end(), "p.second","");
   } ///:~

   Note that the only difference betweens1 ands2 is the capital‘T’ ins2’s "Test." Comparings1 ands1 for equality yieldstrue, as expected, whiles1 ands2 are not equal because of the capital‘T’.
   To understand the output of thelexicographical_compare( ) tests, remember two things: first, the comparison is performed character-by-character, and, second, on our platform, capital letters "precede" lowercase letters. In the first test,s1 is compared tos1. These are exactly equivalent. One isnot lexicographically less than the other (which is what the comparison is looking for), and thus the result isfalse. The second test is asking "doess1 precedes2?" When the comparison gets to the‘t’ in "test", it discovers that the lowercase ‘t’ ins1 is "greater" than the uppercase‘T’ ins2, so the answer is againfalse. However, if we test to see whethers2 precedess1, the answer istrue.
   To further examine lexicographical comparison, the next test in this example comparess1 withs2 again (which returnedfalse before). But this time it repeats the comparison, trimming one character off the end ofs1 (which is first copied intos3) each time through the loop until the test evaluates totrue. What you’ll see is that, as soon as the uppercase ‘T’ is trimmed offs3 (the copy ofs1), the characters, which are exactly equal up to that point, no longer count. Becauses3 is shorter thans2, it lexicographically precedess2.
   The final test usesmismatch( ). To capture the return value, create the appropriatepair p, constructing the template using the iterator type from the first range and the iterator type from the second range (in this case, bothstring::iterators). To print the results, the iterator for the mismatch in the first range isp.first, and for the second range isp.second. In both cases, the range is printed from the mismatch iterator to the end of the range so you can see exactly where the iterator points.
   Removing elements
   Because of the genericity of the STL, the concept of removal is a bit constrained. Since elements can only be "removed" via iterators, and iterators can point to arrays, vectors, lists, and so on, it is not safe or reasonable to actually try to destroy the elements that are being removed and to change the size of the input range[first, last). (An array, for example, cannot have its size changed.) So instead, what the STL "remove" functions do is rearrange the sequence so that the "removed" elements are at the end of the sequence, and the "un-removed" elements are at the beginning of the sequence (in the same order that they were before, minus the removed elements—that is, this is astable operation). Then the function will return an iterator to the "new last" element of the sequence, which is the end of the sequence without the removed elements and the beginning of the sequence of the removed elements. In other words, ifnew_last is the iterator that is returned from the "remove" function,[first, new_last) is the sequence without any of the removed elements, and[new_last, last) is the sequence of removed elements.
   If you are simply using your sequence, including the removed elements, with more STL algorithms, you can just usenew_last as the new past-the-end iterator. However, if you’re using a resizable containerc(not an array) and you actually want to eliminate the removed elements from the container, you can useerase( ) to do so, for example:.
   c.erase(remove(c.begin(), c.end(), value), c.end());

   You can also use theresize( ) member function that belongs to all standard sequences (more on this in the next chapter).
   The return value ofremove( ) is thenew_last iterator, soerase( ) deletes all the removed elements fromc.
   The iterators in[new_last, last) are dereferenceable, but the element values are unspecified and should not be used.
   ForwardIteratorremove(ForwardIterator first, ForwardIterator last, const T& value); ForwardIteratorremove_if(ForwardIterator first, ForwardIterator last, Predicate pred); OutputIteratorremove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value); OutputIteratorremove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);
   Each of the "remove" forms moves through the range[first, last), finding values that match a removal criterion and copying the unremoved elements over the removed elements (thus effectively removing them). The original order of the unremoved elements is maintained. The return value is an iterator pointing past the end of the range that contains none of the removed elements. The values that this iterator points to are unspecified.
   The "if" versions pass each element topred( ) to determine whether it should be removed. (Ifpred( ) returnstrue, the element is removed.) The "copy" versions do not modify the original sequence, but instead copy the unremoved values into a range beginning atresult and return an iterator indicating the past-the-end value of this new range.
   ForwardIteratorunique(ForwardIterator first, ForwardIterator last); ForwardIteratorunique(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred); OutputIteratorunique_copy(InputIterator first, InputIterator last, OutputIterator result); OutputIteratorunique_copy(InputIterator first, InputIterator last, OutputIterator result,  BinaryPredicate binary_pred);
   Each of the "unique" functions moves through the range[first, last), finding adjacent values that are equivalent (that is, duplicates) and "removing" the duplicate elements by copying over them. The original order of the unremoved elements is maintained. The return value is an iterator pointing past the end of the range that has the adjacent duplicates removed.
   Because only duplicates that are adjacent are removed, it’s likely that you’ll want to callsort( ) before calling a "unique" algorithm, since that will guarantee thatall the duplicates are removed.
   For each iterator valuei in the input range, the versions containingbinary_pred call:.
   binary_pred(*i, *(i-1));

   and if the result istrue,*i is considered a duplicate.
   The "copy" versions do not modify the original sequence, but instead copy the unremoved values into a range beginning atresult and return an iterator indicating the past-the-end value of this new range.
   Example
   This example gives a visual demonstration of the way the "remove" and "unique" functions work.
   //: C06:Removing.cpp
   // The removing algorithms
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;string&gt;
   #include "Generators.h"
   #include "PrintSequence.h"
   using namespace std;

   struct IsUpper {
     bool operator()(char c) {
       return isupper(c);
     }
   };

   int main() {
     string v;
     v.resize(25);
     generate(v.begin(), v.end(), CharGen());
     print(v.begin(), v.end(), "v original", "");
     // Create a set of the characters in v:
     string us(v.begin(), v.end());
     sort(us.begin(), us.end());
     string::iterator it = us.begin(), cit = v.end(),
       uend = unique(us.begin(), us.end());
     // Step through and remove everything:
     while(it != uend) {
       cit = remove(v.begin(), cit, *it);
       print(v.begin(), v.end(), "Complete v", "");
       print(v.begin(), cit, "Pseudo v ", " ");
       cout&lt;&lt; "Removed element:\t"&lt;&lt; *it
           &lt;&lt; "\nPsuedo Last Element:\t"
           &lt;&lt; *cit&lt;&lt; endl&lt;&lt; endl;
       it++;
     }
     generate(v.begin(), v.end(), CharGen());
     print(v.begin(), v.end(), "v", "");
     cit = remove_if(v.begin(), v.end(), IsUpper());
     print(v.begin(), cit, "v after remove_if IsUpper", " ");
     // Copying versions are not shown for remove
     // and remove_if.
     sort(v.begin(), cit);
     print(v.begin(), cit, "sorted", " ");
     string v2;
     v2.resize(cit - v.begin());
     unique_copy(v.begin(), cit, v2.begin());
     print(v2.begin(), v2.end(), "unique_copy", " ");
     // Same behavior:
     cit = unique(v.begin(), cit, equal_to&lt;char&gt;());
     print(v.begin(), cit, "unique equal_to&lt;char&gt;", " ");
   } ///:~

   The stringv, which is a container of characters, as you know, is filled with randomly generated characters. Each character is used in aremove statement, but the entire stringv is printed out each time so you can see what happens to the rest of the range, after the resulting endpoint (which is stored incit).
   To demonstrateremove_if( ), the address of the standard C library functionisupper( )(in&lt;cctype&gt;is called inside the function object classIsUpper, an object of which is passed as the predicate forremove_if( ). This returnstrue only if a character is uppercase, so only lowercase characters will remain. Here, the end of the range is used in the call toprint( ) so only the remaining elements will appear. The copying versions ofremove( ) andremove_if( ) are not shown because they are a simple variation on the noncopying versions, which you should be able to use without an example.
   The range of lowercase letters is sorted in preparation for testing the "unique" functions. (The "unique" functions are not undefined if the range isn’t sorted, but it’s probably not what you want.).. First,unique_copy( ) puts the unique elements into a newvector using the default element comparison, and then the form ofunique( ) that takes a predicate is used; the predicate used is the built-in function objectequal_to( ), which produces the same results as the default element comparison.
   Sorting and operations on sorted ranges
   A significant category of STL algorithms requires that the range they operate on be in sorted order.
   STL provides a number of separate sorting algorithms, depending on whether the sort should be stable, partial, or just regular (non-stable). Oddly enough, only the partial sort has a copying version; otherwise you’ll need to make your own copy before sorting if that’s what you want.
   Once your sequence is sorted, you can perform many operations on that sequence, from simply locating an element or group of elements to merging with another sorted sequence or manipulating sequences as mathematical sets.
   Each algorithm involved with sorting or operations on sorted sequences has two versions. The first uses the object’s ownoperator&lt; to perform the comparison, and the second usesoperator( )(a, b) to determine the relative order ofa andb. Other than this, there are no differences, so this distinction will not be pointed out in the description of each algorithm.
   Sorting
   The sort algorithms require ranges delimited by random-access iterators, such as avector ordeque. Thelist container has its own built-insort( ) function, since it only supports bi-directional iteration.
   voidsort(RandomAccessIterator first, RandomAccessIterator last); voidsort(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Sorts[first, last) into ascending order. The first form usesoperator&lt; and the second form uses the supplied comparator object to determine the order.
   voidstable_sort(RandomAccessIterator first, RandomAccessIterator last); voidstable_sort(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Sorts[first, last) into ascending order, preserving the original ordering of equivalent elements. (This is important if elements can be equivalent but not identical.).
   voidpartial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last); voidpartial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Sorts the number of elements from[first, last) that can be placed in the range[first, middle). The rest of the elements end up in[middle, last) and have no guaranteed order.
   RandomAccessIteratorpartial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last); RandomAccessIteratorpartial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, StrictWeakOrdering binary_pred);
   Sorts the number of elements from[first, last) that can be placed in the range[result_first, result_last) and copies those elements into[result_first, result_last). If the range[first, last) is smaller than[result_first, result_last), the smaller number of elements is used.
   voidnth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last); voidnth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Just likepartial_sort( ),nth_element( ) partially orders a range of elements. However, it’s much "less ordered" thanpartial_sort( ). The only thing thatnth_element( ) guarantees is that whateverlocationyou choose will become a dividing point. All the elements in the range[first, nth)will pair-wise satisfy the binary predicate (operator&lt; by default, as usual), and all the elements in the range(nth, last] will not. However, neither subrange is in any particular order, unlikepartial_sort( ) which has the first range in sorted order.
   If all you need is this very weak ordering (if, for example, you’re determining medians, percentiles, and that sort of thing), this algorithm is faster thanpartial_sort( ).
   Locating elements in sorted ranges
   Once a range is sorted, you can use a group of operations to find elements within those ranges. In the following functions, there are always two forms. One assumes the intrinsicoperator&lt; performs the sort, and the second operator must be used if some other comparison function object performs the sort. You must use the same comparison for locating elements as you do to perform the sort; otherwise, the results are undefined. In addition, if you try to use these functions on unsorted ranges, the results will be undefined.
   boolbinary_search(ForwardIterator first, ForwardIterator last, const T& value); boolbinary_search(ForwardIterator first, ForwardIterator last, const T& value, StrictWeakOrdering binary_pred);
   Tells you whethervalue appears in the sorted range[first, last).
   ForwardIteratorlower_bound(ForwardIterator first, ForwardIterator last, const T& value); ForwardIteratorlower_bound(ForwardIterator first, ForwardIterator last, const T& value, StrictWeakOrdering binary_pred);
   Returns an iterator indicating the first occurrence ofvalue in the sorted range[first, last). Ifvalue is not present, an iterator to where it would fit in the sequence is returned.
   ForwardIteratorupper_bound(ForwardIterator first, ForwardIterator last, const T& value); ForwardIteratorupper_bound(ForwardIterator first, ForwardIterator last, const T& value, StrictWeakOrdering binary_pred);
   Returns an iterator indicating one past the last occurrence ofvalue in the sorted range[first, last). Ifvalue is not present, an iterator to where it would fit in the sequence is returned.
   pair&lt;ForwardIterator, ForwardIterator&gt;equal_range(ForwardIterator first, ForwardIterator last, const T& value); pair&lt;ForwardIterator, ForwardIterator&gt;equal_range(ForwardIterator first, ForwardIterator last, const T& value, StrictWeakOrdering binary_pred);
   Essentially combineslower_bound( ) andupper_bound( ) to return apair indicating the first and one-past-the-last occurrences ofvalue in the sorted range[first, last). Both iterators indicate the location wherevalue would fit if it is not found.
   You may find it surprising that the binary search algorithms take a forward iterator instead of a random access iterator. (Most explanations of binary search use indexing.) Remember that a random access iterator "is-a" forward iterator, and can be used wherever the latter is specified. If the iterator passed to one of these algorithms in fact supports random access, then the efficient logarithmic-time procedure is used, otherwise a linear search is performed.[88]
   Example
   The following example turns each input word into anNString and added to avector&lt;NString&gt;. Thevector is then used to demonstrate the various sorting and searching algorithms.
   //: C06:SortedSearchTest.cpp
   // Test searching in sorted ranges
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;
   #include&lt;ctime&gt;
   #include&lt;cstdlib&gt;
   #include&lt;cstddef&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   #include "NString.h"
   #include "PrintSequence.h"
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     typedef vector&lt;NString&gt;::iterator sit;
     char* fname = "test.txt";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     srand(time(0));
     cout.setf(ios::boolalpha);
     vector&lt;NString&gt; original;
     copy(istream_iterator&lt;string&gt;(in),
       istream_iterator&lt;string&gt;(), back_inserter(original));
     require(original.size()&gt;= 4, "Must have four elements");
     vector&lt;NString&gt; v(original.begin(), original.end()),
       w(original.size() / 2);
     sort(v.begin(), v.end());
     print(v.begin(), v.end(), "sort");
     v = original;
     stable_sort(v.begin(), v.end());
     print(v.begin(), v.end(), "stable_sort");
     v = original;
     sit it = v.begin(), it2;
     // Move iterator to middle
     for(size_t i = 0; i&lt; v.size() / 2; i++)
       it++;
     partial_sort(v.begin(), it, v.end());
     cout&lt;&lt; "middle = "&lt;&lt; *it&lt;&lt; endl;
     print(v.begin(), v.end(), "partial_sort");
     v = original;
     // Move iterator to a quarter position
     it = v.begin();
     for(size_t i = 0; i&lt; v.size() / 4; i++)
       it++;
     // Less elements to copy from than to the destination
     partial_sort_copy(v.begin(), it, w.begin(), w.end());
     print(w.begin(), w.end(), "partial_sort_copy");
     // Not enough room in destination
     partial_sort_copy(v.begin(), v.end(), w.begin(),
       w.end());
     print(w.begin(), w.end(), "w partial_sort_copy");
     // v remains the same through all this process
     assert(v == original);
     nth_element(v.begin(), it, v.end());
     cout&lt;&lt; "The nth_element = "&lt;&lt; *it&lt;&lt; endl;
     print(v.begin(), v.end(), "nth_element");
     string f = original[rand() % original.size()];
     cout&lt;&lt; "binary search: "
      &lt;&lt; binary_search(v.begin(), v.end(), f)
      &lt;&lt; endl;
     sort(v.begin(), v.end());
     it = lower_bound(v.begin(), v.end(), f);
     it2 = upper_bound(v.begin(), v.end(), f);
     print(it, it2, "found range");
     pair&lt;sit, sit&gt; ip =
       equal_range(v.begin(), v.end(), f);
     print(ip.first, ip.second,
       "equal_range");
   } ///:~

   This example uses theNString class seen earlier, which stores an occurrence number with copies of a string. The call to stable_sort( ) shows how the original order for objects with equal strings is preserved. You can also see what happens during a partial sort (the remaining unsorted elements are in no particular order). There is no "partial stable sort.".
   Notice in the call tonth_element( ) that, whatever the nth element turns out to be (which will vary from one run to another because ofURandGen), the elements before that are less, and after that are greater, but the elements have no particular order other than that. Because ofURandGen, there are no duplicates, but if you use a generator that allows duplicates, you’ll see that the elements before the nth element will be less than or equal to the nth element.
   This example also illustrates all three binary search algorithms. As advertised,lower_bound( ) refers to the first element in the sequence equal to a given key,upper_bound( ) points one past the last, andequal_range( ) returns both results as a pair.
   Merging sorted ranges
   As before, the first form of each function assumes the intrinsicoperator&lt; performs the sort. The second form must be used if some other comparison function object performs the sort. You must use the same comparison for locating elements as you do to perform the sort; otherwise, the results are undefined. In addition, if you try to use these functions on unsorted ranges, the results will be undefined.
   OutputIteratormerge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); OutputIteratormerge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering binary_pred);
   Copies elements from[first1, last1) and[first2, last2) intoresult, such that the resulting range is sorted in ascending order. This is a stable operation.
   voidinplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last); voidinplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, StrictWeakOrdering binary_pred);
   This assumes that[first, middle) and[middle, last) are each sorted ranges in the same sequence. The two ranges are merged so that the resulting range[first, last) contains the combined ranges in sorted order.
   Example
   It’s easier to see what goes on with merging ifints are used; the following example also emphasizes how the algorithms (and our ownprint template) work with arrays as well as containers.
   //: C06:MergeTest.cpp
   // Test merging in sorted ranges
   #include&lt;algorithm&gt;
   #include "PrintSequence.h"
   #include "Generators.h"
   using namespace std;

   int main() {
     const int sz = 15;
     int a[sz*2] = {0};
     // Both ranges go in the same array:
     generate(a, a + sz, SkipGen(0, 2));
     a[3] = 4;
     a[4] = 4;
     generate(a + sz, a + sz*2, SkipGen(1, 3));
     print(a, a + sz, "range1", " ");
     print(a + sz, a + sz*2, "range2", " ");
     int b[sz*2] = {0}; // Initialize all to zero
     merge(a, a + sz, a + sz, a + sz*2, b);
     print(b, b + sz*2, "merge", " ");
     // Reset b
     for(int i = 0; i&lt; sz*2; i++)
       b[i] = 0;
     inplace_merge(a, a + sz, a + sz*2);
     print(a, a + sz*2, "inplace_merge", " ");
     int* end = set_union(a, a + sz, a + sz, a + sz*2, b);
     print(b, end, "set_union", " ");
   } ///:~

   Inmain( ), instead of creating two separate arrays, both ranges are created end to end in the same arraya. (This will come in handy for theinplace_merge.) The first call tomerge( ) places the result in a different array,b. For comparison,set_union( ) is also called, which has the same signature and similar behavior, except that it removes duplicates from the second set. Finally,inplace_merge( ) combines both parts ofa.
   Set operations on sorted ranges
   Once ranges have been sorted, you can perform mathematical set operations on them.
   boolincludes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2); boolincludes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, StrictWeakOrdering binary_pred);
   Returnstrue if[first2, last2) is a subset of[first1, last1). Neither range is required to hold only unique elements, but if[first2, last2) holdsn elements of a particular value,[first1, last1) must also hold at leastn elements if the result is to betrue.
   OutputIteratorset_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); OutputIteratorset_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering binary_pred);
   Creates the mathematical union of two sorted ranges in theresult range, returning the end of the output range. Neither input range is required to hold only unique elements, but if a particular value appears multiple times in both input sets, the resulting set will contain the larger number of identical values.
   OutputIteratorset_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); OutputIteratorset_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering binary_pred);
   Produces, inresult, the intersection of the two input sets, returning the end of the output range—that is, the set of values that appear in both input sets. Neither input range is required to hold only unique elements, but if a particular value appears multiple times in both input sets, the resulting set will contain the smaller number of identical values.
   OutputIteratorset_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); OutputIteratorset_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering binary_pred);
   Produces, inresult, the mathematical set difference, returning the end of the output range. All the elements that are in[first1, last1) but not in[first2, last2) are placed in the result set. Neither input range is required to hold only unique elements, but if a particular value appears multiple times in both input sets (n times in set 1 andm times in set 2), the resulting set will containmax(n-m, 0) copies of that value.
   OutputIteratorset_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); OutputIteratorset_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakOrdering binary_pred);
   Constructs, inresult, the set containing:.
   1.All the elements in set 1 that are not in set 2
   2.All the elements in set 2 that are not in set 1.
   Neither input range is required to hold only unique elements, but if a particular value appears multiple times in both input sets (n times in set 1 andm times in set 2), the resulting set will containabs(n-m) copies of that value, in whichabs( ) is the absolute value. The return value is the end of the output range.
   Example
   It’s easiest to see the set operations demonstrated using simple vectors of characters, so you view the sets more easily. These characters are randomly generated and then sorted, but the duplicates are not removed so you can see what the set operations do when duplicates are involved.
   //: C06:SetOperations.cpp
   // Set operations on sorted ranges
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   #include "PrintSequence.h"
   #include "Generators.h"
   using namespace std;

   int main() {
     const int sz = 30;
     char v[sz + 1], v2[sz + 1];
     CharGen g;
     generate(v, v + sz, g);
     generate(v2, v2 + sz, g);
     sort(v, v + sz);
     sort(v2, v2 + sz);
     print(v, v + sz, "v", "");
     print(v2, v2 + sz, "v2", "");
     bool b = includes(v, v + sz, v + sz/2, v + sz);
     cout.setf(ios::boolalpha);
     cout&lt;&lt; "includes: "&lt;&lt; b&lt;&lt; endl;
     char v3[sz*2 + 1], *end;
     end = set_union(v, v + sz, v2, v2 + sz, v3);
     print(v3, end, "set_union", "");
     end = set_intersection(v, v + sz,
       v2, v2 + sz, v3);
     print(v3, end, "set_intersection", "");
     end = set_difference(v, v + sz, v2, v2 + sz, v3);
     print(v3, end, "set_difference", "");
     end = set_symmetric_difference(v, v + sz,
       v2, v2 + sz, v3);
     print(v3, end, "set_symmetric_difference","");
   } ///:~

   Afterv andv2 are generated, sorted, and printed, theincludes( ) algorithm is tested by seeing if the entire range ofv contains the last half ofv, which of course it does; so the result should always be true. The arrayv3 holds the output ofset_union( ),set_intersection( ),set_difference( ), andset_symmetric_difference( ), and the results of each are displayed so you can ponder them and convince yourself that the algorithms do indeed work as promised.
   Heap operations
   A heap is an array-like data structure used to implement a "priority queue", which is just a range that is organized in a way that accommodates retrieving elements by priority according to some comparison function. The heap operations in the standard library allow a sequence to be treated as a "heap" data structure, which always efficiently returns the element of highest priority, without fully ordering the entire sequence.
   As with the "sort" operations, there are two versions of each function. The first uses the object’s ownoperator&lt; to perform the comparison; the second uses an additionalStrictWeakOrdering object’soperator( )(a, b) to compare two objects fora&lt; b.
   voidmake_heap(RandomAccessIterator first, RandomAccessIterator last); voidmake_heap(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Turns an arbitrary range into a heap.
   voidpush_heap(RandomAccessIterator first, RandomAccessIterator last); voidpush_heap(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Adds the element *(last-1) to the heap determined by the range[first, last-1). In other words, it places the last element in its proper location in the heap.
   voidpop_heap(RandomAccessIterator first, RandomAccessIterator last); voidpop_heap(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   Places the largest element (which is actually in*first, before the operation, because of the way heaps are defined) into the position*(last-1)and reorganizes the remaining range so that it’s still in heap order. If you simply grabbed*first, the next element would not be the next-largest element; so you must usepop_heap( ) if you want to maintain the heap in its proper priority-queue order.
   voidsort_heap(RandomAccessIterator first, RandomAccessIterator last); voidsort_heap(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering binary_pred);
   This could be thought of as the complement ofmake_heap( ). It takes a range that is in heap order and turns it into ordinary sorted order, so it is no longer a heap. That means that if you callsort_heap( ), you can no longer usepush_heap( ) orpop_heap( ) on that range. (Rather, you can use those functions, but they won’t do anything sensible.) This is not a stable sort.
   Applying an operation to each element in a range
   These algorithms move through the entire range and perform an operation on each element. They differ in what they do with the results of that operation:for_each( ) discards the return value of the operation, andtransform( ) places the results of each operation into a destination sequence (which can be the original sequence).
   UnaryFunctionfor_each(InputIterator first, InputIterator last, UnaryFunction f);.
   Applies the function objectf to each element in[first, last), discarding the return value from each individual application off. Iffis just a function pointer, you are typically not interested in the return value; but iffis an object that maintains some internal state, it can capture the combined return value of being applied to the range. The final return value offor_each( ) isf.
   OutputIteratortransform(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction f); OutputIteratortransform(InputIterator1 first, InputIterator1 last, InputIterator2 first2, OutputIterator result, BinaryFunction f);
   Likefor_each( ),transform( ) applies a function objectf to each element in the range[first, last). However, instead of discarding the result of each function call,transform( ) copies the result (usingoperator=) into*result, incrementingresult after each copy. (The sequence pointed to byresult must have enough storage; otherwise, use an inserter to force insertions instead of assignments.)
   The first form oftransform( ) simply callsf(*first), where first ranges through the input sequence. Similarly, the second form callsf(*first1, *first2). (Note that the length of the second input range is determined by the length of the first.) The return value in both cases is the past-the-end iterator for the resulting output range.
   Examples
   Since much of what you do with objects in a container is to apply an operation to all those objects, these are fairly important algorithms and merit several illustrations.
   First, considerfor_each( ). This sweeps through the range, pulling out each element and passing it as an argument as it calls whatever function object it’s been given. Thus,for_each( ) performs operations that you might normally write out by hand. If you look in your compiler’s header file at the template definingfor_each( ), you’ll see something like this:.
   template&lt;class InputIterator, class Function&gt;
   Function for_each(InputIterator first,
      InputIterator last,
      Function f) {
       while (first != last) f(*first++);
       return f;
   }
   The following example shows several ways this template can be expanded. First, we need a class that keeps track of its objects so we can know that it’s being properly destroyed:.
   //: C06:Counted.h
   // An object that keeps track of itself
   #ifndef COUNTED_H
   #define COUNTED_H
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   class Counted {
     static int count;
     char* ident;
   public:
     Counted(char* id) : ident(id) { count++; }

     ~Counted() {
       std::cout&lt;&lt; ident&lt;&lt; " count = "
        &lt;&lt; --count&lt;&lt; std::endl;
     }
   };

   int Counted::count = 0;

   class CountedVector :
     public std::vector&lt;Counted*&gt; {
   public:
     CountedVector(char* id) {
       for(int i = 0; i&lt; 5; i++)
         push_back(new Counted(id));
     }
   };
   #endif // COUNTED_H ///:~

   Theclass Counted keeps a static count of how manyCounted objects have been created and tells you as they are destroyed.[89] In addition, eachCounted keeps achar* identifier to make tracking the output easier.
   TheCountedVector is derived fromvector&lt;Counted*&gt;, and in the constructor it creates someCounted objects, handing each one your desiredchar*. TheCountedVector makes testing quite simple, as you’ll see.
   //: C06:ForEach.cpp
   // Use of STL for_each() algorithm
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include "Counted.h"
   using namespace std;

   // Function object:
   template&lt;class T&gt;
   class DeleteT {
   public:
     void operator()(T* x) { delete x; }
   };

   // Template function:
   template&lt;class T&gt;
   void wipe(T* x) { delete x; }

   int main() {
     CountedVector B("two");
     for_each(B.begin(),B.end(),DeleteT&lt;Counted&gt;());
     CountedVector C("three");
     for_each(C.begin(), C.end(), wipe&lt;Counted&gt;);
   } ///:~

   Since this is obviously something you might want to do a lot, why not create an algorithm todelete all the pointers in a container? You could usetransform( ). The value oftransform( ) overfor_each( ) is thattransform( ) assigns the result of calling the function object into a resulting range, which can actually be the input range. That case means a literal transformation for the input range, since each element would be a modification of its previous value. In this example, this approach would be especially useful since it’s more appropriate to assign to each pointer the safe value of zero after callingdelete for that pointer.Transform( ) can easily do this:.
   //: C06:Transform.cpp
   // Use of STL transform() algorithm
   #include "Counted.h"
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   using namespace std;

   template&lt;class T&gt;
   T* deleteP(T* x) { delete x; return 0; }

   #ifdef _MSC_VER
   // Microsoft needs explicit instantiation
   template Counted* deleteP(Counted* x);
   #endif


   template&lt;class T&gt; struct Deleter {
     T* operator()(T* x) { delete x; return 0; }
   };

   int main() {
     CountedVector cv("one");
     transform(cv.begin(), cv.end(), cv.begin(),
       deleteP&lt;Counted&gt;);
     CountedVector cv2("two");
     transform(cv2.begin(), cv2.end(), cv2.begin(),
       Deleter&lt;Counted&gt;());
   } ///:~

   This shows both approaches: using a template function or a templatized function object. After the call totransform( ), the vector contains five null pointers, which is safer since any duplicatedeletes will have no effect.
   One thing you cannot do isdelete every pointer in a collection without wrapping the call todeleteinside a function or an object. That is, you do the following:.
   for_each(a.begin(), a.end(), ptr_fun(operator delete));

   This has the same problem as the call todestroy ( ) did earlier:operator delete( ) takes a void*, but iterators aren’t void pointers (or pointers at all). Even if you could make it compile, what you’d get is a sequence of calls to the function that releases the storage. You will not get the effect of callingdelete for each pointer ina, however; the destructor will not be called. This is typically not what you want, so you will need wrap your calls todelete.
   In the previous example offor_each( ), the return value of the algorithm was ignored. This return value is the function that is passed in tofor_each( ). If the function is just a pointer to a function, the return value is not very useful, but if it is a function object, that function object may have internal member data that it uses to accumulate information about all the objects that it sees duringfor_each( ).
   For example, consider a simple model of inventory. EachInventory object has the type of product it represents (here, single characters will be used for product names), the quantity of that product, and the price of each item:.
   //: C06:Inventory.h
   #ifndef INVENTORY_H
   #define INVENTORY_H
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;

   #ifndef _MSC_VER
   // Microsoft namespace work-around
   using std::rand;
   using std::srand;
   using std::time;
   #endif

   class Inventory {
     char item;
     int quantity;
     int value;
   public:
     Inventory(char it, int quant, int val)
       : item(it), quantity(quant), value(val) {}
     // Synthesized operator=& copy-constructor OK
     char getItem() const { return item; }
     int getQuantity() const { return quantity; }
     void setQuantity(int q) { quantity = q; }
     int getValue() const { return value; }
     void setValue(int val) { value = val; }
     friend std::ostream& operator&lt;&lt;(
       std::ostream& os, const Inventory& inv) {
       return os&lt;&lt; inv.item&lt;&lt; ": "
        &lt;&lt; "quantity "&lt;&lt; inv.quantity
        &lt;&lt; ", value "&lt;&lt; inv.value;
     }
   };

   // A generator:
   struct InvenGen {
     InvenGen() { srand(time(0)); }
     Inventory operator()() {
       static char c = 'a';
       int q = rand() % 100;
       int v = rand() % 500;
       return Inventory(c++, q, v);
     }
   };
   #endif // INVENTORY_H ///:~

   Member functions get the item name and get and set quantity and value. Anoperator&lt;&lt; prints theInventory object to anostream. A generator creates objects that have sequentially labeled items and random quantities and values.
   To find out the total number of items and total value, you can create a function object to use withfor_each( ) that has data members to hold the totals:.
   //: C06:CalcInventory.cpp
   // More use of for_each()
   #include "Inventory.h"
   #include "PrintSequence.h"
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   using namespace std;

   // To calculate inventory totals:
   class InvAccum {
     int quantity;
     int value;
   public:
     InvAccum() : quantity(0), value(0) {}
     void operator()(const Inventory& inv) {
       quantity += inv.getQuantity();
       value += inv.getQuantity() * inv.getValue();
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const InvAccum& ia) {
       return os&lt;&lt; "total quantity: "
        &lt;&lt; ia.quantity
        &lt;&lt; ", total value: "&lt;&lt; ia.value;
     }
   };

   int main() {
     vector&lt;Inventory&gt; vi;
     generate_n(back_inserter(vi), 15, InvenGen());
     print(vi.begin(), vi.end(), "vi");
     InvAccum ia = for_each(vi.begin(),vi.end(),
       InvAccum());
     cout&lt;&lt; ia&lt;&lt; endl;
   } ///:~

   InvAccum’soperator( ) takes a single argument, as required byfor_each( ). Asfor_each( ) moves through its range, it takes each object in that range and passes it toInvAccum::operator( ), which performs calculations and saves the result. At the end of this process,for_each( ) returns theInvAccum object that you can then examine; in this case, it is simply printed.
   You can do most things to theInventory objects usingfor_each( ). For example,for_each( ) can handily increase all the prices by 10%. But you’ll notice that theInventory objects have no way to change theitem value. The programmers who designedInventory thought this was a good idea. After all, why would you want to change the name of an item? But marketing has decided that they want a "new, improved" look by changing all the item names to uppercase; they’ve done studies and determined that the new names will boost sales (well, marketing has to havesomething to do…). Sofor_each( ) will not work here, buttransform( ) will:
   //: C06:TransformNames.cpp
   // More use of transform()
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;vector&gt;
   #include "Inventory.h"
   #include "PrintSequence.h"
   using namespace std;

   struct NewImproved {
     Inventory operator()(const Inventory& inv) {
       return Inventory(toupper(inv.getItem()),
         inv.getQuantity(), inv.getValue());
     }
   };

   int main() {
     vector&lt;Inventory&gt; vi;
     generate_n(back_inserter(vi), 15, InvenGen());
     print(vi.begin(), vi.end(), "vi");
     transform(vi.begin(), vi.end(), vi.begin(),
       NewImproved());
     print(vi.begin(), vi.end(), "vi");
   } ///:~

   Notice that the resulting range is the same as the input range; that is, the transformation is performed in place.
   Now suppose that the sales department needs to generate special price lists with different discounts for each item. The original list must stay the same, and any number of special lists need to be generated. Sales will give you a separate list of discounts for each new list. To solve this problem, we can use the second version oftransform( ):
   //: C06:SpecialList.cpp
   // Using the second version of transform()
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;vector&gt;
   #include "Inventory.h"
   #include "PrintSequence.h"
   using namespace std;

   struct Discounter {
     Inventory operator()(const Inventory& inv,
       float discount) {
       return Inventory(inv.getItem(),
         inv.getQuantity(),
         int(inv.getValue() * (1 - discount)));
     }
   };

   struct DiscGen {
     DiscGen() { srand(time(0)); }
     float operator()() {
       float r = float(rand() % 10);
       return r / 100.0;
     }
   };

   int main() {
     vector&lt;Inventory&gt; vi;
     generate_n(back_inserter(vi), 15, InvenGen());
     print(vi.begin(), vi.end(), "vi");
     vector&lt;float&gt; disc;
     generate_n(back_inserter(disc), 15, DiscGen());
     print(disc.begin(), disc.end(), "Discounts:");
     vector&lt;Inventory&gt; discounted;
     transform(vi.begin(),vi.end(), disc.begin(),
       back_inserter(discounted), Discounter());
     print(discounted.begin(), discounted.end(),
           "discounted");
   } ///:~

   Given anInventory object and a discount percentage, the Discounter function object produces a newInventory with the discounted price. TheDiscGen function object just generates random discount values between 1% and 10% to use for testing. Inmain( ), twovectors are created, one forInventory and one for discounts. These are passed totransform( ) along with aDiscounter object, andtransform( )fills a newvector&lt;Inventory&gt; calleddiscounted.
   Numeric algorithms
   These algorithms are all tucked into the header&lt;numeric&gt;, since they are primarily useful for performing numeric calculations.
   &lt;numeric&gt; Taccumulate(InputIterator first, InputIterator last, T result); Taccumulate(InputIterator first, InputIterator last, T result, BinaryFunction f);
   The first form is a generalized summation; for each element pointed to by an iteratori in[first, last), it performs the operationresult = result + *i, in whichresult is of typeT. However, the second form is more general; it applies the functionf(result, *i) on each element*i in the range from beginning to end.
   Note the similarity between the second form oftransform( ) and the second form ofaccumulate( ).
   &lt;numeric&gt; Tinner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init); Tinner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 op1, BinaryFunction2 op2);
   Calculates a generalized inner product of the two ranges[first1, last1) and[first2, first2 + (last1 - first1)). The return value is produced by multiplying the element from the first sequence by the "parallel" element in the second sequence and then adding it to the sum. Thus, if you have two sequences {1, 1, 2, 2} and {1, 2, 3, 4}, the inner product becomes.
   (1*1) + (1*2) + (2*3) + (2*4)

   which is 17. Theinit argument is the initial value for the inner product; this is probably zero but may be anything and is especially important for an empty first sequence, because then it becomes the default return value. The second sequence must have at least as many elements as the first.
   The second form simply applies a pair of functions to its sequence. Theop1 function is used in place of addition, andop2 is used instead of multiplication. Thus, if you applied the second version ofinner_product( ) to the sequence, the result would be the following operations:
   init = op1(init, op2(1,1));
   init = op1(init, op2(1,2));
   init = op1(init, op2(2,3));
   init = op1(init, op2(2,4));

   Thus, it’s similar totransform( ), but two operations are performed instead of one.
   &lt;numeric&gt; OutputIteratorpartial_sum(InputIterator first, InputIterator last, OutputIterator result); OutputIteratorpartial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction op);
   Calculates a generalized partial sum. This means that a new sequence is created, beginning atresult; each element is the sum of all the elements up to the currently selected element in[first, last). For example, if the original sequence is{1, 1, 2, 2, 3}, the generated sequence is{1, 1 + 1, 1 + 1 + 2, 1 + 1 + 2 + 2, 1 + 1 + 2 + 2 + 3}, that is,{1, 2, 4, 6, 9}.
   In the second version, the binary functionop is used instead of the+ operator to take all the "summation" up to that point and combine it with the new value. For example, if you usemultiplies&lt;int&gt;( ) as the object for the sequence, the output is{1, 1, 2, 4, 12}. Note that the first output value is always the same as the first input value.
   The return value is the end of the output range[result, result + (last - first) ).
   &lt;numeric&gt; OutputIteratoradjacent_difference(InputIterator first, InputIterator last, OutputIterator result); OutputIteratoradjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction op);
   Calculates the differences of adjacent elements throughout the range[first, last). This means that in the new sequence, the value is the value of the difference of the current element and the previous element in the original sequence (the first value is unchanged). For example, if the original sequence is{1, 1, 2, 2, 3}, the resulting sequence is{1, 1– 1, 2 – 1, 2 – 2, 3 – 2}, that is:{1, 0, 1, 0, 1}.
   The second form uses the binary functionop instead of the– operator to perform the "differencing." For example, if you usemultiplies&lt;int&gt;( ) as the function object for the sequence, the output is{1, 1, 2, 4, 6}.
   The return value is the end of the output range[result, result + (last - first) ).
   Example
   This program tests all the algorithms in&lt;numeric&gt; in both forms, on integer arrays. You’ll notice that in the test of the form where you supply the function or functions, the function objects used are the ones that produce the same result as form one, so the results will be exactly the same. This should also demonstrate a bit more clearly the operations that are going on and how tosubstitute your own operations.
   //: C06:NumericTest.cpp
   //{L} ../TestSuite/Test
   #include "PrintSequence.h"
   #include&lt;numeric&gt;
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;functional&gt;
   using namespace std;

   int main() {
     int a[] = { 1, 1, 2, 2, 3, 5, 7, 9, 11, 13 };
     const int asz = sizeof a / sizeof a[0];
     print(a, a + asz, "a", " ");
     int r = accumulate(a, a + asz, 0);
     cout&lt;&lt; "accumulate 1: "&lt;&lt; r&lt;&lt; endl;
     // Should produce the same result:
     r = accumulate(a, a + asz, 0, plus&lt;int&gt;());
     cout&lt;&lt; "accumulate 2: "&lt;&lt; r&lt;&lt; endl;
     int b[] = { 1, 2, 3, 4, 1, 2, 3, 4, 1, 2 };
     print(b, b + sizeof b / sizeof b[0], "b", " ");
     r = inner_product(a, a + asz, b, 0);
     cout&lt;&lt; "inner_product 1: "&lt;&lt; r&lt;&lt; endl;
     // Should produce the same result:
     r = inner_product(a, a + asz, b, 0,
       plus&lt;int&gt;(), multiplies&lt;int&gt;());
     cout&lt;&lt; "inner_product 2: "&lt;&lt; r&lt;&lt; endl;
     int* it = partial_sum(a, a + asz, b);
     print(b, it, "partial_sum 1", " ");
     // Should produce the same result:
     it = partial_sum(a, a + asz, b, plus&lt;int&gt;());
     print(b, it, "partial_sum 2", " ");
     it = adjacent_difference(a, a + asz, b);
     print(b, it, "adjacent_difference 1"," ");
     // Should produce the same result:
     it = adjacent_difference(a, a + asz, b,
       minus&lt;int&gt;());
     print(b, it, "adjacent_difference 2"," ");
   } ///:~

   Note that the return value ofinner_product( ) andpartial_sum( ) is the past-the-end iterator for the resulting sequence, so it is used as the second iterator in theprint( ) function.
   Since the second form of each function allows you to provide your own function object, only the first form of the functions is purely "numeric." You could conceivably do some things that are not intuitively numeric with something likeinner_product( ).
   General utilities
   Finally, here are some basic tools that are used with the other algorithms; you may or may not use them directly yourself.
   &lt;utility&gt; structpair;make_pair( );
   This was described and used earlier in this chapter. Apair is simply a way to package two objects (which may be of different types) together into a single object. This is typically used when you need to return more than one object from a function, but it can also be used to create a container that holdspairobjects or to pass more than one object as a single argument. You access the elements by sayingp.first andp.second, in whichp is thepair object. The functionequal_range( ), described in the last chapter and in this one, returns its result as apair of iterators. You caninsert( ) apair directly into amap ormultimap; apair is thevalue_type for those containers.
   If you want to create apair"on the fly,", you typically use the template functionmake_pair( ) rather than explicitly constructing apair object.
   &lt;iterator&gt;distance(InputIterator first, InputIterator last);
   Tells you the number of elements betweenfirst andlast. More precisely, it returns an integral value that tells you the number of timesfirst must be incremented before it is equal tolast. No dereferencing of the iterators occurs during this process.
   &lt;iterator&gt; voidadvance(InputIterator& i, Distance n);
   Moves the iteratori forward by the value ofn. (The iterator can also be moved backward for negative values ofn if the iterator is also a bidirectional iterator.) This algorithm is aware of bidirectional iterators and will use the most efficient approach.
   &lt;iterator&gt; back_insert_iterator&lt;Container&gt;back_inserter(Container& x); front_insert_iterator&lt;Container&gt;front_inserter(Container& x); insert_iterator&lt;Container&gt;inserter(Container& x, Iterator i);
   These functions are used to create iterators for the given containers that will insert elements into the container, rather than overwrite the existing elements in the container usingoperator=(which is the default behavior). Each type of iterator uses a different operation for insertion:back_insert_iterator usespush_back( ),front_insert_iterator usespush_front( ), andinsert_iterator usesinsert( ) (and thus it can be used with the associative containers, while the other two can be used with sequence containers). These will be shown in some detail in the next chapter.
   const LessThanComparable&min(const LessThanComparable& a, const LessThanComparable& b); const T&min(const T& a, const T& b, BinaryPredicate binary_pred);
   Returns the lesser of its two arguments, or returns the first argument if the two are equivalent. The first version performs comparisons usingoperator&lt;, and the second passes both arguments tobinary_pred to perform the comparison.
   const LessThanComparable&max(const LessThanComparable& a,  const LessThanComparable& b); const T&max(const T& a, const T& b,  BinaryPredicate binary_pred);
   Exactly likemin( ), but returns the greater of its two arguments.
   voidswap(Assignable& a, Assignable& b); voiditer_swap(ForwardIterator1 a, ForwardIterator2 b);
   Exchanges the values ofa andb using assignment. Note that all container classes use specialized versions ofswap( ) that are typically more efficient than this general version.
   Theiter_swap( ) function swaps the values that its two arguments reference.
   Creating your own STL-style algorithms
   Once you become comfortable with the STL algorithm style, you can begin to create your own generic algorithms. Because these will conform to the conventions of all the other algorithms in the STL, they’re easy to use for programmers who are familiar with the STL, and thus they become a way to "extend the STL vocabulary.".
   The easiest way to approach the problem is to go to the&lt;algorithm&gt; header file, find something similar to what you need, and pattern your code after that.[90] (Virtually all STL implementations provide the code for the templates directly in the header files.)
   Now that you’re comfortable with the ideas of the various iterator types, the actual implementation is quite straightforward. You can imagine creating an entire additional library of your own useful algorithms that follow the format of the STL.
   If you take a close look at the list of algorithms in the standard C++ library, you might notice a glaring omission: there is nocopy_if( ) algorithm. Although it’s true that you can accomplish the same thing withremove_copy_if( ), this is not quite as convenient because you have to invert the condition. (Remember,remove_copy_if( ) only copies those elements thatdon’t match its predicate, in effectremoving those that do.) You might be tempted to write a function object adapter that negates its predicate before passing it toremove_copy_if( ), by including a statement something like this:
   // Assumes pred is the incoming condition
   replace_copy_if(begin, end, not1(pred));

   This seems reasonable, but when you remember that you want to be able to use predicates that are pointers to raw functions, you see why this won’t work—not1 expects an adaptable function object. The only solution is to write acopy_if( ) algorithm from scratch. Since you know from inspecting the other copy algorithms that conceptually you need separate iterators for input and output, the following example will do the job.
   //: C06:copy_if.h
   // Roll your own STL-style algorithm
   #ifndef COPY_IF_H
   #define COPY_IF_H

   template&lt;typename ForwardIter,
     typename OutputIter, typename UnaryPred&gt;
   OutputIter copy_if(ForwardIter begin, ForwardIter end,
     OutputIter dest, UnaryPred f) {
     while(begin != end) {
       if(f(*begin))
         *dest++ = *begin;
       ++begin;
     }
     return dest;
   }
   #endif // COPY_IF_H ///:~

   Summary
   The goal of this chapter was to give you a practical understanding of the algorithms in the Standard Template Library. That is, to make you aware of and comfortable enough with the STL that you begin to use it on a regular basis (or, at least, to think of using it so you can come back here and hunt for the appropriate solution). It is powerful not only because it’s a reasonably complete library of tools, but also because it provides a vocabulary for thinking about problem solutions and because it is a framework for creating additional tools.
   Although this chapter did show some examples of creating your own tools, we did not go into the full depth of the theory of the STL that is necessary to completely understand all the STL nooks and crannies to allow you to create tools more sophisticated than those shown here. This was in part because of space limitations, but mostly because it is beyond the charter of this book; our goal here is to give you practical understanding that will affect your day-to-day programming skills.
   A number of books are dedicated solely to the STL (these are listed in the appendices), but we especially recommend Matthew H. Austern’sGeneric Programming and the STL (Addison-Wesley, 1999) and Scott Meyers’sEffective STL (Addison-Wesley, 2002).
   Exercises
                4.             Create a generator that returns the current value ofclock( ) (in&lt;ctime&gt;). Create alist&lt;clock_t&gt;, and fill it with your generator usinggenerate_n( ). Remove any duplicates in the list and print it tocout usingcopy( ).
                4.             Usingtransform( ) andtoupper( ) (in&lt;cctype&gt;), write a single function call that will convert a string to all uppercase letters.
                5.             Create aSum function object template that will accumulate all the values in a range when used withfor_each( ).
                6.             Write an anagram generator that takes a word as a command-line argument and produces all possible permutations of the letters.
                7.             Write a "sentence anagram generator" that takes a sentence as a command-line argument and produces all possible permutations of the words in the sentence. (It leaves the words alone and just moves them around.)
                8.             Create a class hierarchy with a base classB and a derived classD. Put avirtual member functionvoid f( ) inB such that it will print a message indicating thatB’sf( ) was called, and redefine this function forD to print a different message. Create avector&lt;B*&gt;, and fill it withB andD objects. Usefor_each( ) to callf( ) for each of the objects in your vector.
                9.             ModifyFunctionObjects.cpp so that it usesfloat instead ofint.
           10.             ModifyFunctionObjects.cpp so that it templatizes the main body of tests so you can choose which type you’re going to test. (You’ll have to pull most ofmain( ) out into a separate template function.)
            11.             Write a program that takes an integer as a command line argument and finds all of its factors.
            12.             Write a program that takes as a command-line argument the name of a text file. Open this file and read it a word at a time (hint: use&gt;&gt;). Store each word into avector&lt;string&gt;. Force all the words to lowercase, sort them, remove all the duplicates, and print the results.
            13.             Write a program that finds all the words that are in common between two input files, usingset_intersection( ). Change it to show the words that are not in common, usingset_symmetric_difference( ).
            14.             Create a program that, given an integer on the command line, creates a "factorial table" of all the factorials up to and including the number on the command line. To do this, write a generator to fill avector&lt;int&gt;, and then usepartial_sum( ) with a standard function object.
            15.             ModifyCalcInventory.cpp so that it will find all the objects that have a quantity that’s less than a certain amount. Provide this amount as a command-line argument, and usecopy_if( ) andbind2nd( ) to create the collection of values less than the target value.
            16.             UseUrandGen( ) to generate 100 numbers. (The size of the numbers does not matter.) Find which numbers in your range are congruent mod 23 (meaning they have the same remainder when divided by 23). Manually pick a random number yourself, and find if that number is in your range by dividing each number in the list by your number and checking if the result is 1 instead of just usingfind( ) with your value.
            17.             Fill avector&lt;double&gt; with numbers representing angles in radians. Using function object composition, take the sine of all the elements in your vector (see&lt;cmath&gt;).
            18.             Test the speed of your computer. Callsrand(time(0)), then make an array of random numbers. Callsrand(time(0)) again and generate the same number of random numbers in a second array. Useequal( ) to see if the arrays are the same. (If your computer is fast enough,time(0) will return the same value both times it is called.) If the arrays are not the same, sort them and usemismatch( ) to see where they differ. If they are the same, increase the length of your array and try again.
            19.             Create an STL-style algorithmtransform_if( ) following the first form oftransform( ) that performs transformations only on objects that satisfy a unary predicate. Objects that don’t satisfy the predicate are omitted from the result. It needs to return a new "end" iterator.
           20.             Create an STL-style algorithm that is an overloaded version offor_each( ) which follows the second form oftransform( ) and takes two input ranges so it can pass the objects of the second input range a to a binary function that it applies to each object of the first range.
            21.             Create aMatrix class that is made from avector&lt;vector&lt;int&gt;&gt;. Provide it with a friendostream& operator&lt;&lt;(ostream&, const Matrix&) to display the matrix. Create the following binary operations using the STL function objects where possible:operator+(const Matrix&, const Matrix&) for matrix addition,operator*(const Matrix&, const vector&lt;int&gt;&) for multiplying a matrix by a vector, andoperator*(const Matrix&, const Matrix&) for matrix multiplication. (You might need to look up the mathematical meanings of the matrix operations if you don’t remember them.) Demonstrate each.
           22.             Using the characters "~`!@#$%^&*()_-+=}{[]|\:;"'&lt;.&gt;,?/", generate a codebook using an input file given on the command line as a dictionary of words. Don't worry about stripping off the non-alphabetic characters nor worry about case of the words in the dictionary file. Map each permutation of the character string to a word such as the following: "=')/%[}]|{*@?!"`,;&gt;&^-~_:$+.#(&lt;\"   apple "|]\~&gt;#.+%(/-_[`':;=}{*"$^!&?),@&lt;"   carrot "@=~['].\/&lt;-`&gt;#*)^%+,";&?!_{:|$}("   Carrot etc. Make sure that no duplicate codes or words exist in your code book. Uselexicographical_compare( ) to perform a sort on the codes. Use your code book to encode the dictionary file. Decode your encoding of the dictionary file, and make sure you get the same contents back.
           23.             Using the following names:

   Jon Brittle
   Jane Brittle
   Mike Brittle
   Sharon Brittle
   George Jensen
   Evelyn Jensen

   Find all the possible ways to arrange them for a wedding picture.
           24.             After being separated for one picture, the bride and groom decided they wanted to be together for all of them. Find all the possible ways to arrange the people for the picture if the bride and groom (Jon Brittle and Jane Brittle) are to be next to each other.&lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I350&gt;
           25.             A travel company wants to find out the average number of days people take to travel from one end of the continent to another. The problem is that in the survey, some people did not take a direct route and took much longer than is needed (such unusual data points are called "outliers"). Using the following generator following, generate travel days into a vector. Useremove_if( ) to remove all the outliers in your vector. Take the average of the data in the vector to find out how long people generally take to travel.

   int travelTime() {
           // The "outlier"
           if(rand() % 10 == 0)
             return rand() % 100;
           // Regular route
           return rand() % 10 + 10;
   }
    &lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I353&gt;
           26.             Determine how much fasterbinary_search( ) is tofind( ) when it comes to searchingsorted ranges.&lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I354&gt;
            27.             The army wants to recruit people from its selective service list. They have decided to recruit those that signed up for the service in 1997 starting from the oldest down to the youngest. Generate an arbitrary amount of people (give them data members suchasage andyearEnrolled) into a vector. Partition the vector so that those who enrolled in 1997 are ordered at the beginning of the list, starting from the youngest to the oldest, and leave the remaining part of the list sorted according to age.
           28.             Make aclass called Town with population, altitude, and weather data members. Make the weather anenum with{ RAINY, SNOWY, CLOUDY, CLEAR }. Make a class that generates Town objects. Generate town names (whether they make sense or not it doesn’t matter) or pull them off the internet. Ensure that the whole town name is lower case and there are no duplicate names. For simplicity, we recommend keeping your town names to one word. For the population, altitudes, and weather fields, make a generator that will randomly generate weather conditions, populations within the range [100 to 1,000,000) and altitudes between [0, 8000) feet. Fill a vector with your Town objects. Rewrite the vector out to a new file called Towns.txt.
           29.             There was a baby boom, resulting in a 10% population increase in every town. Update your town data usingtransform( ), rewrite your data back out to file.
           30.             Find the towns with the highest and lowest population. Temporarily implementoperator&lt; for your town object for this exercise. Also try implementing a function that returns true if its first parameter is less than its second. Use it as a predicate to call the algorithm you use.
            31.             Find all the towns within the altitudes 2500-3500 feet inclusive. Implement equality operators for theTown class as needed.
           32.             We need to place an airport in a certain altitude, but location is not a problem. Organize your list of towns so that there are no duplicate (duplicate meaning that no two altitudes are within the same 100 ft range. Such classes would include [100, 199), [200, 199), etc. altitudes. Sort this list in ascending order in at least two different ways using the function objects in&lt;functional&gt;. Do the same for descending order. Implement relational operators forTown as needed.
           33.             Generate an arbitrary number of random numbers in a stack-based array. Usemax_element( ) to find the largest number in array. Swap it with the number at the end of your array. Find the next largest number and place it in the array in the position before the previous number. Continue doing this until all elements have been moved. When the algorithm is complete, you will have a sorted array. (This is a "selection sort".)
           34.             Write a program that will take phone numbers from a file (that also contains names and other suitable information) and change the numbers that begin with 222 to 863. Be sure to save the old numbers. The file format is be as follows:
   222 8945
   756 3920
   222 8432
   etc.
           35.             Write a program that given a last name will find everyone with that last name with his or her corresponding phone number. Use the algorithms that deal with ranges (lower_bound,upper_bound,equal_range, etc.). Sort with the last name acting as a primary key and the first name acting as a secondary key. Assume that you will read the names and numbers from a file where the format will be as follows. (Be sure to order them so that the last names are ordered, and the first names are ordered within the last names.):

   John Doe             345 9483
   Nick Bonham    349 2930
   Jane Doe              283 2819

           36.             Given a file with data similar to the following, pull all the state acronyms from the file and put them in a separate file. (Note that you can’t depend on the line number for the type of data. The data is on random lines.)

   ALABAMA
   AL
   AK
   ALASKA
   ARIZONA
   AZ
   ARKANSAS
   AR
   CA
   CALIFORNIA
   CO
   COLORADO
   etc.

   When complete, you should have a file with all the state acronyms which are:
   AL AK AZ AR CA CO CT DE FL GA HI ID IL IN IA KS KY LA ME MD MA MI MN MS MO MT NE NV NH NJ NM NY NC ND OH OK OR PA RI SC SD TN TX UT VT VA WA WV WI WY
            37.             Make anEmployeeclass with two data members:hoursandhourlyPay. Employee shall also have acalcSalary( ) function which returns the pay for that employee. Generate random hourly pay and hours for an arbitrary amount of employees. Keep avector&lt;Employee*&gt;. Find out how much money the company is going to spend for this pay period.
           38.             Racesort( ), partial_sort( ),andnth_element( ) against each other and find out if it’s really worth the time saved to use one of the weaker sorts if they’re all that’s needed.
   7: Generic containers
   Container classesare the solution to a specific kind of code reuse problem. They are building blocks used to create object-oriented programs—they make the internals of a program much easier to construct.
   A container class describes an object that holds other objects. Container classes are so important that they were considered fundamental to early object-oriented languages. In Smalltalk, for example, programmers think of the language as the program translator together with the class library, and a critical part of that library is the container classes. So it became natural that C++ compiler vendors also include a container class library. You’ll note that thevector was so useful that it was introduced in its simplest form early in Volume 1 of this book.
   Like many other early C++ libraries, early container class libraries followed Smalltalk’sobject-based hierarchy, which worked well for Smalltalk, but turned out to be awkward and difficult to use in C++. Another approach was required.
   The C++ approach to containers is based, of course, on templates. The containers in the standard C++ library represent a broad range of data structures designed to work well with the standard algorithms and to meet common software development needs.
   Containers and iterators
   If you don’t know how many objects you’re going to need to solve a particular problem, or how long they will last, you also don’t know ahead of time how to store those objects. How can you know how much space to create? You don’t until run time.
   The solution to most problems in object-oriented design seems simple: you create another type of object. For the storage problem, the new type of object holds other objects or pointers to objects. This new type of object, which is typically referred to in C++ as acontainer (also called acollection in some languages), expands itself whenever necessary to accommodate everything you place inside it. You don’t need to know ahead of time how many objects you’re going to place in a container; you just create a container object and let it take care of the details.
   Fortunately, a good object-oriented programming language comes with a set of containers. In C++, it’s the Standard Template Library. In some libraries, a generic container is considered good enough for all needs, and in others (C++ in particular) the library has different types of containers for different needs: a vector for consistent access to all elements, and a linked list for consistent insertion at all positions, and many more, so you can choose the particular type that fits your needs.
   All containers have some way to put things in and get things out. The way you place something into a container is fairly obvious. There’s a function called "push" or "add" or a similar name. Fetching things out of a container is not always as apparent; if an entity is array-like, such as a vector, you might be able to use an indexing operator or function. But in many situations this doesn’t make sense. Also, a single-selectionfunction is restrictive. What if you want to manipulate or compare a group of elements in the container?.
   The solution for flexible element access is aniterator, an object whose job is to select the elements within a container and present them to the user of the iterator. As a class, an iterator also provides a level of abstraction, which you can use to separate the details of the container from the code that’s accessing that container. The container, via the iterator, is seen as a sequence. The iterator lets you traverse that sequence without worrying about the underlying structure—that is, whether it’s a vector, a linked list, a set, or something else. This gives you the flexibility to easily change the underlying data structure without disturbing the code in your program that traverses the container. Separating iteration from the control of the container traversed also allows having multiple iterators simultaneously.
   From a design standpoint, all you really want is a sequence that can be manipulated to solve your problem. If a single type of sequence satisfied all your needs, there’d be no reason to have different kinds. You need a choice of containers for two reasons. First, containers provide different types of interfaces and external behavior. A stack has an interface and a behavior that is different from that of a queue, which is different from that of a set or a list.One of these might provide a more flexible solution to your problem than the other. Second, different containers have different efficiencies for certain operations. Compare a vector to a list, as an example. Both are simple sequences that can have nearly identical interfaces and external behaviors.But certain operations can have radically different costs. Randomly accessing elements in a vector is a constant-time operation; it takes the same amount of time regardless of the element you select. However, it is expensive to move through a linked list to randomly access an element, and it takes longer to find an element if it is farther down the list. On the other hand, if you want to insert an element in the middle of a sequence, it’s much cheaper in a list than in a vector. The efficiencies of these and other operations depend on the underlying structure of the sequence. In the design phase, you might start with a list and, when tuning for performance, change to a vector, or vice-versa. Because of iterators, code that merely traverses sequences is insulated from changes in the underlying sequence implementation.
   Remember that a container is only a storage cabinet in which to put objects. If that cabinet solves all your needs, it probably doesn’t really matterhow it is implemented. If you’re working in a programming environment that has built-in overhead due to other factors, the cost difference between a vector and a linked list might not matter. You might need only one type of sequence. You can even imagine the "perfect" container abstraction, which can automatically change itsunderlying implementation according to the way it is used.
   STL reference documentation
   As in the previous chapter, you will notice that this chapter does not contain exhaustive documentation describing each of the member functions in each STL container. Although we describe the member functions we use, we’ve left the full descriptions to others. We recommend the online resources available for the Dinkumware, Silicon Graphics, and STLPort STL implementations.[91] 
   A first look
   Here’s an example using theset class template, a container modeled after a traditional mathematical set and which does not accept duplicate values. This simpleset was created to work withints:.
   //: C07:Intset.cpp
   // Simple use of STL set
   #include&lt;cassert&gt;
   #include&lt;set&gt;
   using namespace std;

   int main() {
     set&lt;int&gt; intset;
       for(int i = 0; i&lt; 25; i++)
         for(int j = 0; j&lt; 10; j++)
           // Try to insert duplicates:
           intset.insert(j);
     assert(intset.size() == 10);
   } ///:~

   Theinsert( ) member does all the work: it attempts to insert an element and ignores it if it’s already there. Often the only activities involved in using a set are simply insertion and testing to see whether it contains the element. You can also form a union, an intersection, or a difference of sets and test to see if one set is a subset of another. In this example, the values 0–9 areinserted into the set 25 times, but only the 10 unique instances are accepted.
   Now consider taking the form ofIntset.cpp and modifying it to display a list of the words used in a document. The solution becomes remarkably simple.
   //: C07:WordSet.cpp
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;set&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   void wordSet(char* fileName) {
     ifstream source(fileName);
     assure(source, fileName);
     string word;
     set&lt;string&gt; words;
     while(source&gt;&gt; word)
       words.insert(word);
     copy(words.begin(), words.end(),
       ostream_iterator&lt;string&gt;(cout, "\n"));
     cout&lt;&lt; "Number of unique words:"
      &lt;&lt; words.size()&lt;&lt; endl;
   }

   int main(int argc, char* argv[]) {
     if(argc&gt; 1)
       wordSet(argv[1]);
     else
       wordSet("WordSet.cpp");
   } ///:~

   The only substantive difference here is thatstring is used instead ofint. The words are pulled from a file, but the other operations are similar to those inIntset.cpp. Not only does the output reveal that duplicates have been ignored, but because of the wayset is implemented, the words are automatically sorted.
   A set is an example of anassociative container, one of the three categories of containers provided by the standard C++ library. The containers and their categories are summarized in the following table.CategoryContainersSimple Sequence Containersvector, list, dequeContainer Adaptersqueue, stack, priority_queueAssociative Containersset, map, multiset, multimap

   All the containers in the standard library hold objects and expand their resources as needed. The key difference between one container and another is the way the objects are stored in memory and what operations are available to the user.
   Avector, as you already know, is a linear sequence that allows rapid random access to its elements. However, it’s expensive to insert an element in the middle of a co-located sequence like a vector, just as it is with an array. Adeque (double-ended-queue, pronounced "deck") also allows random access that’s nearly as fast asvector, but it’s significantly faster when it needs to allocate new storage, and you can easily add new elements at the front as well as the back of the sequence. Alist is a doubly linked list, so it’s expensive to move around randomly but cheap to insert an element anywhere. Thuslist,deque andvector are similar in their basic functionality (they all hold linear sequences), but different in the cost of their activities. So for your first shot at a program, you could choose any one and experiment with the others only if you’re tuning for efficiency.
   Many of the problems you set out to solve will only require a simple linear sequence such as avector,deque, orlist. All three have a member functionpush_back( ) that you use to insert a new element at the back of the sequence (deque andlist also havepush_front( )).
   But now how do you retrieve those elements? With avector ordeque, it is possible to use the indexingoperator[ ], but that doesn’t work withlist. You can use iterators on all three sequences to access elements. Each container provides the appropriate type of iterator for accessing its elements.
   One more observation and then we’ll be ready for another example. Even though the containers hold objects by value (that is, they hold copies of whole objects), sometimes you’ll want to store pointers so that you can refer to objects from a hierarchy and therefore take advantage of the polymorphic behavior of the classes represented. Consider the classic "shape" example in which shapes have a set of common operations, and you have different types of shapes. Here’s what it looks like using the STLvector to hold pointers to variousShape types created on the heap:.
   //: C07:Stlshape.cpp
   // Simple shapes w/ STL
   #include&lt;vector&gt;
   #include&lt;iostream&gt;
   using namespace std;

   class Shape {
   public:
     virtual void draw() = 0;
     virtual ~Shape() {};
   };

   class Circle : public Shape {
   public:
     void draw() { cout&lt;&lt; "Circle::draw\n"; }
     ~Circle() { cout&lt;&lt; "~Circle\n"; }
   };

   class Triangle : public Shape {
   public:
     void draw() { cout&lt;&lt; "Triangle::draw\n"; }
     ~Triangle() { cout&lt;&lt; "~Triangle\n"; }
   };

   class Square : public Shape {
   public:
     void draw() { cout&lt;&lt; "Square::draw\n"; }
     ~Square() { cout&lt;&lt; "~Square\n"; }
   };

   typedef std::vector&lt;Shape*&gt; Container;
   typedef Container::iterator Iter;

   int main() {
     Container shapes;
     shapes.push_back(new Circle);
     shapes.push_back(new Square);
     shapes.push_back(new Triangle);
     for(Iter i = shapes.begin();
         i != shapes.end(); i++)
       (*i)-&gt;draw();
     // ... Sometime later:
     for(Iter j = shapes.begin();
         j != shapes.end(); j++)
       delete *j;
   } ///:~

   The creation ofShape,Circle,Square, andTriangle should be fairly familiar.Shape is a pure abstract base class (because of thepure specifier=0) that defines the interface for all types ofshapes. The derived classes redefine thevirtual functiondraw( ) to perform the appropriate operation. Now we’d like to create a bunch of different types ofShape objects, but where to put them? In an STL container, of course. For convenience, thistypedef:
   typedef std::vector&lt;Shape*&gt; Container;

   creates an alias for avector ofShape*, and thistypedef:
   typedef Container::iterator Iter;

   uses that alias to create another one, forvector&lt;Shape*&gt;::iterator. Notice that thecontainer type name must be used to produce the appropriate iterator, which is defined as a nested class. Although there are different types of iterators (forward, bidirectional, reverse, and so on), they all have the same basic interface: you can increment them with++, you can dereference them to produce the object they’re currently selecting, and you can test them to see if they’re at the end of the sequence. That’s what you’ll want to do 90 percent of the time. And that’s what is done in the previous example: after a container is created, it’s filled with different types ofShape pointers. Notice that the upcast happens as theCircle,Square, orRectangle pointer is added to theshapes container, which doesn’t know about those specific types but instead holds onlyShape*. As soon as the pointer is added to the container, it loses its specific identity and becomes an anonymousShape*. This is exactly what we want: toss them all in and let polymorphism sort it out.
   The firstfor loop creates an iterator and sets it to the beginning of the sequence by calling thebegin( ) member function for the container. All containers havebegin( ) andend( ) member functions that produce an iterator selecting, respectively, the beginning of the sequence and one past the end of the sequence. To test to see if you’re done, you make sure you’re!= to the iterator produced byend( ). Not&lt; or&lt;=. The only test that works is!=. So it’s common to write a loop like:.
   for(Iter i = shapes.begin(); i != shapes.end(); i++)

   This says "take me through every element in the sequence.".
   What do you do with the iterator to produce the element it’s selecting? You dereference it using (what else?) the ‘*’ (which is actually an overloaded operator). What you get back is whatever the container is holding. This container holdsShape*, so that’s what*i produces. If you want to call aShape member function, you must do so with the-&gt; operator, so you write the line:.
   (*i)-&gt;draw();

   This calls thedraw( ) function for theShape* the iterator is currently selecting. The parentheses are ugly but necessary to produce the desired operator precedence.
   As they are destroyed or in other cases where the pointers are removed, the STL containersdo not automatically calldelete for the pointers they contain. If you create an object on the heap withnew and place its pointer in a container, the container can’t tell if that pointer is also placed inside another container, nor if it refers to heap memory in the first place. As always, you are responsible for managing your own heap allocations. The last lines in the program move through and delete every object in the container so that proper cleanup occurs.
   You can change the type of container that this program uses with two lines. Instead of including&lt;vector&gt;, you include&lt;list&gt;, and in the firsttypedef you say:.
   typedef std::list&lt;Shape*&gt; Container;

   instead of using avector. Everything else goes untouched. This is possible not because of an interface enforced by inheritance (there is little inheritance in the STL, which may come as a surprise), but because the interface is enforced by a convention adopted by the designers of the STL, precisely so you could perform this kind of interchange. Now you can easily switch betweenvector andlist or any other container that supports the same interface and see which one works fastest for your needs.
   Containers of strings
   In the previous example, at the end ofmain( ) it was necessary to move through the whole list anddelete all theShape pointers:.
   for(Iter j = shapes.begin();
         j != shapes.end(); j++)
       delete *j;

   This highlights what could be seen as an oversight in the STL: there’s no facility in any of the STL containers to automaticallydelete the pointers they contain, so you must do it by hand. It’s as if the assumption of the STL designers was that containers of pointers weren’t an interesting problem.
   Automatically deleting a pointer turns out to be a rather aggressive thing to do because of themultiple membership problem. If a container holds a pointer to an object, it’s not unlikely that pointer could also be in another container. A pointer to anAluminum object in a list ofTrash pointers could also reside in a list ofAluminum pointers. If that happens, which list is responsible for cleaning up that object—that is, which list "owns" the object?.
   This question is virtually eliminated if the object rather than a pointer resides in the list. Then it seems clear that when the list is destroyed, the objects it contains must also be destroyed. Here, the STL shines, as you can see when creating a container ofstring objects. The following example stores each incoming line as astring in avector&lt;string&gt;:
   //: C07:StringVector.cpp
   // A vector of strings
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     char* fname = "StringVector.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     vector&lt;string&gt; strings;
     string line;
     while(getline(in, line))
       strings.push_back(line);
     // Do something to the strings...
     int i = 1;
     vector&lt;string&gt;::iterator w;
     for(w = strings.begin();
         w != strings.end(); w++) {
       ostringstream ss;
       ss&lt;&lt; i++;
       *w = ss.str() + ": " + *w;
     }
     // Now send them out:
     copy(strings.begin(), strings.end(),
       ostream_iterator&lt;string&gt;(cout, "\n"));
     // Since they aren't pointers, string
     // objects clean themselves up!
   } ///:~

   Once thevector&lt;string&gt;calledstrings is created, each line in the file is read into astring and put in thevector:.
     while(getline(in, line))
       strings.push_back(line);

   The operation that’s being performed on this file is to add line numbers. Astringstream provides easy conversion from anint to astring of characters representing thatint.
   Assemblingstring objects is quite easy, sinceoperator+ is overloaded. Sensibly enough, the iteratorw can be dereferenced to produce a string that can be used as both an rvalueand an lvalue:.
   *w = ss.str() + ": " + *w;

   You may be surprised that you can assign back into the container via the iterator , but it’s a tribute to the careful design of the STL.
   Because thevector&lt;string&gt; contains the objects themselves, a number of interesting things take place. First, no explicit cleanup of thestring objects on your part is necessary. Even if you were to put addresses of thestring objects as pointers intoother containers, it’s clear thatstrings is the "master list" and maintains ownership of the objects.
   Second, you are effectively using dynamic object creation, and yet you never usenew ordelete! That’s because, somehow, it’s all taken care of for you by thevector because it storescopies of the objects you give it. Thus your coding is significantly cleaned up.
   Inheriting from STL containers
   The power of instantly creating a sequence of elements is amazing, and it makes you realize how much time you may have spent (or rather wasted) in the past solving this particular problem. For example, many utility programs involve reading a file into memory, modifying the file, and writing it back out to disk. You might as well take the functionality inStringVector.cpp and package it into a class for later reuse.
   Now the question is: do you create a member object of typevector, or do you inherit? A general object-oriented design guideline is to prefer composition (member objects) over inheritance, but the standard algorithms expect sequences that implement a specified interface, so inheritance is often called for.
   //: C07:FileEditor.h
   // File editor tool
   #ifndef FILEEDITOR_H
   #define FILEEDITOR_H
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;

   class FileEditor :
     public std::vector&lt;std::string&gt; {
   public:
     void open(const char* filename);
     FileEditor(const char* filename) {
       open(filename);
     }
     FileEditor() {};
     void write(std::ostream& out = std::cout);
   };
   #endif // FILEEDITOR_H ///:~

   Note the careful avoidance of a globalusing namespace std statement here, to prevent the opening of thestd namespace in every file that includes this header.
   The constructor opens the file and reads it into theFileEditor, andwrite( ) puts thevector ofstring onto anyostream. Notice inwrite( )that you can have a default argument for the reference.
   The implementation is quite simple:.
   //: C07:FileEditor.cpp {O}
   #include "FileEditor.h"
   #include&lt;fstream&gt;
   #include "../require.h"
   using namespace std;

   void FileEditor::open(const char* filename) {
     ifstream in(filename);
     assure(in, filename);
     string line;
     while(getline(in, line))
       push_back(line);
   }

   // Could also use copy() here:
   void FileEditor::write(ostream& out) {
     for(iterator w = begin();  w != end(); w++)
       out&lt;&lt; *w&lt;&lt; endl;
   } ///:~

   The functions fromStringVector.cpp are simply repackaged. Often this is the way classes evolve—you start by creating a program to solve a particular application and then discover some commonly used functionality within the program that can be turned into a class.
   The line-numbering program can now be rewritten usingFileEditor:.
   //: C07:FEditTest.cpp
   //{L} FileEditor
   // Test the FileEditor tool
   #include&lt;sstream&gt;
   #include "FileEditor.h"
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     FileEditor file;
     if(argc&gt; 1) {
       file.open(argv[1]);
     } else {
       file.open("FEditTest.cpp");
     }
     // Do something to the lines...
     int i = 1;
     FileEditor::iterator w = file.begin();
     while(w != file.end()) {
       ostringstream ss;
       ss&lt;&lt; i++;
       *w = ss.str() + ": " + *w;
       w++;
     }
     // Now send them to cout:
     file.write();
   } ///:~
   Now the operation of reading the file is in the constructor:.
   FileEditor file(argv[1]);

   (or in theopen( )member function), and writing happens in the single line (which defaults to sending the output tocout):
   file.write();

   The bulk of the program is involved with actually modifying the file in memory.
   A plethora of iterators
   As mentioned earlier in this and the previous chapter, an iterator is an abstraction that allows code to be generic, that is, to work with different types of containers without knowing the underlying structure of those containers. Most containers support iterators.[92] You can always say:.
   &lt;ContainerType&gt;::iterator
   &lt;ContainerType&gt;::const_iterator

   to produce the types of the iterators produced by that container. Every container has abegin( ) member function that produces an iterator indicating the beginning of the elements in the container, and anend( ) member function that produces an iterator which is the as thepast-the-endmarker of the container. If the container isconst,begin( ) andend( ) produceconst iterators, which disallow changing the elements pointed to (because the appropriate operators areconst).
   All iterators can advance within their sequence (viaoperator++) and allow== and!= comparisons. Thus, to move an iteratorit forward without running it off the end, you say something like:.
   while(it != pastEnd) {
     // Do something
     it++;
   }

   in whichpastEnd is the past-the-end marker produced by the container’send( ) member function.
   An iterator can be used to produce the element that it is currently selecting within a container through the dereferencing operator (operator*). This can take two forms. Ifitis an iterator andf( )is a member function of the objects held in the container that the iterator is pointing within, you can say either:.
   (*it).f();

   or.
   it-&gt;f();

   Knowing this, you can create a template that works with any container. Here, theapply( ) function template calls a member function for every object in the container, using a pointer to member that is passed as an argument:.
   //: C07:Apply.cpp
   // Using simple iteration
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;iterator&gt;
   using namespace std;

   template&lt;class Cont, class PtrMemFun&gt;
   void apply(Cont& c, PtrMemFun f) {
     typename Cont::iterator it = c.begin();
     while(it != c.end()) {
       ((*it).*f)(); // Alternate form
       it++;
     }
   }

   class Z {
     int i;
   public:
     Z(int ii) : i(ii) {}
     void g() { i++; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Z& z) {
       return os&lt;&lt; z.i;
     }
   };

   int main() {
     ostream_iterator&lt;Z&gt; out(cout, " ");
     vector&lt;Z&gt; vz;
     for(int i = 0; i&lt; 10; i++)
       vz.push_back(Z(i));
     copy(vz.begin(), vz.end(), out);
     cout&lt;&lt; endl;
     apply(vz,&Z::g);
     copy(vz.begin(), vz.end(), out);
   } ///:~

   You can’t useoperator-&gt; in this case, because the resulting statement would be
   (it-&gt;*f)();

   which attempts to use the iterator’soperator-&gt;*, which is not provided by the iterator classes.[93]
   It is much easier to use eitherfor_each( ) ortransform( ) to apply functions to sequences anyway, as you saw in the previous chapter.
   Iterators in reversible containers
   A container may also bereversible, which means that it can produce iterators that move backward from the end, as well as the iterators that move forward from the beginning. All standard containers support such bidirectional iteration.
   A reversible container has the member functionsrbegin( ) (to produce areverse_iterator selecting the end) andrend( ) (to produce areverse_iterator indicating "one past the beginning"). If the container isconst, rbegin( ) andrend( ) will produceconst_reverse_iterators.
   The following example usesvector, but will work with all containers that support iteration:
   //: C07:Reversible.cpp
   // Using reversible containers
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream in("Reversible.cpp");
     assure(in, "Reversible.cpp");
     string line;
     vector&lt;string&gt; lines;
     while(getline(in, line))
       lines.push_back(line);
     for(vector&lt;string&gt;::reverse_iterator r = lines.rbegin();
         r != lines.rend(); r++)
       cout&lt;&lt; *r&lt;&lt; endl;
   } ///:~

   You move backward through the container using the same syntax as moving forward through a container with an ordinary iterator.
   Iterator categories
   The iterators are classified into "categories" that describe their capabilities. The order in which they are generally described moves from the categories with the most restricted behavior to those with the most powerful behavior.
   Input: read-only, one pass
   The only predefined implementations of input iterators areistream_iterator andistreambuf_iterator, to read from anistream. As you can imagine, an input iterator can only be dereferenced once for each element that’s selected, just as you can only read a particular portion of an input stream once. They can only move forward. A special constructor defines the past-the-end value. In summary, you can dereference it for reading (once only for each value) and move it forward.
   Output: write-only, one pass
   This is the complement of an input iterator, but for writing rather than reading. The only predefined implementations of output iterators areostream_iterator andostreambuf_iterator, to write to anostream, and the less commonly usedraw_storage_iterator. Again, these can only be dereferenced once for each written value, and they can only move forward. There is no concept of a terminal past-the-end value for an output iterator. Summarizing, you can dereference it for writing (once only for each value) and move it forward.
   Forward: multiple read/write
   The forward iterator contains all the functionality of both the input iterator and the output iterator, plus you can dereference an iterator location multiple times, so you can read and write to a value multiple times. As the name implies, you can only move forward. There are no predefined iterators that are only forward iterators.
   Bidirectional: operator--
   The bidirectional iterator has all the functionality of the forward iterator, and in addition it can be moved backward one location at a time usingoperator--.
   Random-access: like a pointer
   Finally, the random-access iterator has all the functionality of the bidirectional iterator plus all the functionality of a pointer (a pointeris a random-access iterator), except that there is no "null" iterator analogue to a null pointer. Basically, anything you can do with a pointer you can do with a random-access iterator, including indexing withoperator[ ], adding integral values to a pointer to move it forward or backward by a number of locations, and comparing one iterator to another with&lt;,&gt;=, and so on.
   Is this really important?
   Why do you care about this categorization? When you’re just using containers in a straightforward way (for example, just hand-coding all the operations you want to perform on the objects in the container), it usually doesn’t impact you too much. Things either work or they don’t. The iterator categories become important when:
   3.You use some of the fancier built-in iterator types that will be demonstrated shortly. Or you graduate to creating your own iterators (this will also be demonstrated later in this chapter).
   4.You use the STL algorithms (the subject of the previous chapter). Each of the algorithms has requirements that it places on the iterators with which it works. Knowledge of the iterator categories is even more important when you create your own reusable algorithm templates, because the iterator category that your algorithm requires determines how flexible the algorithm will be. If you require only the most primitive iterator category (input or output), your algorithm will work witheverything (copy( ) is an example of this).
   A hierarchy of iterator tag classes identify the category of an iterator. The class names correspond to the iterator categories, as you would expect, and their derivation reflects the relationship between them:
   struct input_iterator_tag {};
   struct output_iterator_tag {};
   struct forward_iterator_tag: public input_iterator_tag {};
   struct bidirectional_iterator_tag : public
     forward_iterator_tag {};
   struct random_access_iterator_tag : public
     bidirectional_iterator_tag {};

   The classforward_iterator_tag derives only frominput_iterator_tag, not fromoutput_iterator_tag, because we need to have past-the-end iterator values in algorithms that use forward iterators, but algorithms that use output iterators always assume thatoperator* can be dereferenced. For this reason, it is important to make sure that a past-the-end value is never passed to an algorithm that expects an output iterator.
   For efficiency, certain algorithms provide different implementations for different iterator types, which they infer from the iterator tag defined by the iterator. We will use some of these tag classes later in this chapter when we define our own iterator types.
   Predefined iterators
   The STL has a predefined set of iterators that can be quite handy. For example, you’ve already seen thereverse_iterator objects produced by callingrbegin( ) andrend( ) for all the basic containers.
   Theinsertion iterators are necessary because some of the STL algorithms—copy( ), for example—use the assignmentoperator= to place objects in the destination container. This is a problem when you’re using the algorithm tofill the container rather than to overwrite items that are already in the destination container—that is, when the space isn’t already there. What the insert iterators do is change the implementation ofoperator= so that instead of doing an assignment, it calls a "push" or "insert" function for that container, thus causing it to allocate new space. The constructors for bothback_insert_iterator andfront_insert_iterator take a basic sequence container object (vector,deque orlist) as their argument and produce an iterator that callspush_back( ) orpush_front( ), respectively, to perform assignment. The helper functionsback_inserter( ) andfront_inserter( ) produce the same objects with a little less typing. Since all the basic sequence containers supportpush_back( ), you will probably find yourself usingback_inserter( ) with some regularity.
   Aninsert_iterator lets you insert elements in the middle of the sequence, again replacing the meaning ofoperator=, but this time by automatically callinginsert( ) instead of one of the "push" functions. Theinsert( ) member function requires an iterator indicating the place to insert before, so theinsert_iterator requires this iterator in addition to the container object. The shorthand functioninserter( ) produces the same object.
   The following example shows the use of the different types of inserters:
   //: C07:Inserters.cpp
   // Different types of iterator inserters
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;deque&gt;
   #include&lt;list&gt;
   #include&lt;iterator&gt;
   using namespace std;

   int a[] = { 1, 3, 5, 7, 11, 13, 17, 19, 23 };

   template&lt;class Cont&gt;
   void frontInsertion(Cont& ci) {
     copy(a, a + sizeof(a)/sizeof(Cont::value_type),
       front_inserter(ci));
     copy(ci.begin(), ci.end(),
       ostream_iterator&lt;typename Cont::value_type&gt;(
       cout, " "));
     cout&lt;&lt; endl;
   }

   template&lt;class Cont&gt;
   void backInsertion(Cont& ci) {
     copy(a, a + sizeof(a)/sizeof(Cont::value_type),
       back_inserter(ci));
     copy(ci.begin(), ci.end(),
       ostream_iterator&lt;typename Cont::value_type&gt;(
       cout, " "));
     cout&lt;&lt; endl;
   }

   template&lt;class Cont&gt;
   void midInsertion(Cont& ci) {
     typename Cont::iterator it = ci.begin();
     it++; it++; it++;
     copy(a, a + sizeof(a)/(sizeof(Cont::value_type) * 2),
       inserter(ci, it));
     copy(ci.begin(), ci.end(),
       ostream_iterator&lt;typename Cont::value_type&gt;(
       cout, " "));
     cout&lt;&lt; endl;
   }

   int main() {
     deque&lt;int&gt; di;
     list&lt;int&gt;  li;
     vector&lt;int&gt; vi;
     // Can't use a front_inserter() with vector
     frontInsertion(di);
     frontInsertion(li);
     di.clear();
     li.clear();
     backInsertion(vi);
     backInsertion(di);
     backInsertion(li);
     midInsertion(vi);
     midInsertion(di);
     midInsertion(li);
   } ///:~

   Sincevector does not supportpush_front( ), it cannot produce afront_insertion_iterator. However, you can see thatvector does support the other two types of insertions (even though, as you shall see later,insert( ) is not an efficient operation forvector). Note the use of the nested typeCont::value_type instead of hard-codingint.
   More on stream iterators
   We introduced the use of the stream iteratorsostream_iterator (an output iterator) andistream_iterator (an input iterator) in conjunction withcopy( ) in the previous chapter. Remember that an output stream doesn’t have any concept of an "end," since you can always just keep writing more elements. However, an input stream eventually terminates (for example, when you reach the end of a file), so you need a way to represent that. Anistream_iterator has two constructors, one that takes anistream and produces the iterator you actually read from, and the other which is the default constructor and produces an object that is the past-the-end sentinel. In the following program this object is namedend:
   //: C07:StreamIt.cpp
   // Iterators for istreams and ostreams
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream in("StreamIt.cpp");
     assure(in, "StreamIt.cpp");
     istream_iterator&lt;string&gt; begin(in), end;
     ostream_iterator&lt;string&gt; out(cout, "\n");
     vector&lt;string&gt; vs;
     copy(begin, end, back_inserter(vs));
     copy(vs.begin(), vs.end(), out);
     *out++ = vs[0];
     *out++ = "That's all, folks!";
   } ///:~

   Whenin runs out of input (in this case when the end of the file is reached),init becomes equivalent toend, and thecopy( ) terminates.
   Becauseout is anostream_iterator&lt;string&gt;, you can simply assign anystring object to the dereferenced iterator usingoperator=, and thatstring will be placed on the output stream, as seen in the two assignments toout. Becauseout is defined with a newline as its second argument, these assignments also insert a newline along with each assignment.
   Although it is possible to create anistream_iterator&lt;char&gt; andostream_iterator&lt;char&gt;, these actuallyparsethe input and thus will, for example, automatically eat whitespace (spaces, tabs, and newlines), which is not desirable if you want to manipulate an exact representation of anistream. Instead, you can use the special iteratorsistreambuf_iterator andostreambuf_iterator, which are designed strictly to move characters[94]. Although these are templates, they are meant to be used with template arguments of eitherchar orwchar_t.[95] The following example lets you compare the behavior of the stream iterators with the streambuf iterators:.
   //: C07:StreambufIterator.cpp
   // istreambuf_iterator& ostreambuf_iterator
   #include&lt;algorithm&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include "../require.h"
   using namespace std;

   int main() {
     ifstream in("StreambufIterator.cpp");
     assure(in, "StreambufIterator.cpp");
     // Exact representation of stream:
     istreambuf_iterator&lt;char&gt; isb(in), end;
     ostreambuf_iterator&lt;char&gt; osb(cout);
     while(isb != end)
       *osb++ = *isb++; // Copy 'in' to cout
     cout&lt;&lt; endl;
     ifstream in2("StreambufIterator.cpp");
     // Strips white space:
     istream_iterator&lt;char&gt; is(in2), end2;
     ostream_iterator&lt;char&gt; os(cout);
     while(is != end2)
       *os++ = *is++;
     cout&lt;&lt; endl;
   } ///:~

   The stream iterators use the parsing defined byistream::operator&gt;&gt;, which is probably not what you want if you are parsing characters directly—it’s fairly rare that you want all the whitespace stripped out of your character stream. You’ll virtually always want to use a streambuf iterator when using characters and streams, rather than a stream iterator. In addition,istream::operator&gt;&gt; adds significant overhead for each operation, so it is only appropriate for higher-level operations such as parsing numbers.[96]
   Manipulating raw storage
   Theraw_storage_iterator is defined in&lt;memory&gt; and is an output iterator. It is provided to enable algorithms to store their results in uninitialized memory. The interface is quite simple: the constructor takes an output iterator that is pointing to the raw memory (thus it is typically a pointer), and theoperator= assigns an object into that raw memory. The template parameters are the type of the output iterator pointing to the raw storage and the type of object that will be stored. Here’s an example that createsNoisy objects, which print trace statements for their construction, assignment, and destruction (we’ll show the class definition later):
   //: C07:RawStorageIterator.cpp
   // Demonstrate the raw_storage_iterator
   //{-bor}
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;algorithm&gt;
   #include "Noisy.h"
   using namespace std;

   int main() {
     const int quantity = 10;
     // Create raw storage and cast to desired type:
     Noisy* np =
       reinterpret_cast&lt;Noisy*&gt;(
         new char[quantity * sizeof(Noisy)]);
     raw_storage_iterator&lt;Noisy*, Noisy&gt; rsi(np);
     for(int i = 0; i&lt; quantity; i++)
       *rsi++ = Noisy(); // Place objects in storage
     cout&lt;&lt; endl;
     copy(np, np + quantity,
       ostream_iterator&lt;Noisy&gt;(cout, " "));
     cout&lt;&lt; endl;
     // Explicit destructor call for cleanup:
     for(int j = 0; j&lt; quantity; j++)
       (&np[j])-&gt;~Noisy();
     // Release raw storage:
     delete reinterpret_cast&lt;char*&gt;(np);
   } ///:~

   To make theraw_storage_iteratortemplate happy, the raw storage must be of the same type as the objects you’re creating. That’s why the pointer from the new array ofchar is cast to aNoisy*. The assignment operator forces the objects into the raw storage using the copy-constructor. Note that the explicit destructor call must be made for proper cleanup, and this also allows the objects to be deleted one at a time during container manipulation. In addition, the expressiondelete np; would be invalid anyway since the static type of a pointer in adelete expression must be the same as the type assigned to in thenew expression.
   The basic sequences: vector, list, deque
   Sequences keep objects in whatever order you store them. They differ in the efficiency of their operations, however, so if you are going to manipulate a sequence in a particular fashion, choose the appropriate container for those types of manipulations. So far in this book we’ve been usingvector as the container of choice. This is quite often the case in applications. However, when you start making more sophisticated uses of containers, it becomes important to know more about their underlying implementations and behavior so that you can make the right choices.
   Basic sequence operations
   Using a template, the following example shows the operations that all the basic sequences,vector,deque, andlist, support.
   //: C07:BasicSequenceOperations.cpp
   // The operations available for all the
   // basic sequence Containers.
   #include&lt;deque&gt;
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;vector&gt;
   using namespace std;

   template&lt;typename Container&gt;
   void print(Container& c, char* title = "") {
     cout&lt;&lt; title&lt;&lt; ':'&lt;&lt; endl;
     if(c.empty()) {
       cout&lt;&lt; "(empty)"&lt;&lt; endl;
       return;
     }
     typename Container::iterator it;
     for(it = c.begin(); it != c.end(); it++)
       cout&lt;&lt; *it&lt;&lt; " ";
     cout&lt;&lt; endl;
     cout&lt;&lt; "size() "&lt;&lt; c.size()
      &lt;&lt; " max_size() "&lt;&lt; c.max_size()
      &lt;&lt; " front() "&lt;&lt; c.front()
      &lt;&lt; " back() "&lt;&lt; c.back()&lt;&lt; endl;
   }

   template&lt;typename ContainerOfInt&gt;
   void basicOps(char* s) {
     cout&lt;&lt; "------- "&lt;&lt; s&lt;&lt; " -------"&lt;&lt; endl;
     typedef ContainerOfInt Ci;
     Ci c;
     print(c, "c after default constructor");
     Ci c2(10, 1); // 10 elements, values all 1
     print(c2, "c2 after constructor(10,1)");
     int ia[] = { 1, 3, 5, 7, 9 };
     const int iasz = sizeof(ia)/sizeof(*ia);
     // Initialize with begin& end iterators:
     Ci c3(ia, ia + iasz);
     print(c3, "c3 after constructor(iter,iter)");
     Ci c4(c2); // Copy-constructor
     print(c4, "c4 after copy-constructor(c2)");
     c = c2; // Assignment operator
     print(c, "c after operator=c2");
     c.assign(10, 2); // 10 elements, values all 2
     print(c, "c after assign(10, 2)");
     // Assign with begin& end iterators:
     c.assign(ia, ia + iasz);
     print(c, "c after assign(iter, iter)");
     cout&lt;&lt; "c using reverse iterators:"&lt;&lt; endl;
     typename Ci::reverse_iterator rit = c.rbegin();
     while(rit != c.rend())
       cout&lt;&lt; *rit++&lt;&lt; " ";
     cout&lt;&lt; endl;
     c.resize(4);
     print(c, "c after resize(4)");
     c.push_back(47);
     print(c, "c after push_back(47)");
     c.pop_back();
     print(c, "c after pop_back()");
     typename Ci::iterator it = c.begin();
     it++; it++;
     c.insert(it, 74);
     print(c, "c after insert(it, 74)");
     it = c.begin();
     it++;
     c.insert(it, 3, 96);
     print(c, "c after insert(it, 3, 96)");
     it = c.begin();
     it++;
     c.insert(it, c3.begin(), c3.end());
     print(c, "c after insert("
       "it, c3.begin(), c3.end())");
     it = c.begin();
     it++;
     c.erase(it);
     print(c, "c after erase(it)");
     typename Ci::iterator it2 = it = c.begin();
     it++;
     it2++; it2++; it2++; it2++; it2++;
     c.erase(it, it2);
     print(c, "c after erase(it, it2)");
     c.swap(c2);
     print(c, "c after swap(c2)");
     c.clear();
     print(c, "c after clear()");
   }

   int main() {
     basicOps&lt;vector&lt;int&gt;&gt;("vector");
     basicOps&lt;deque&lt;int&gt;&gt;("deque");
     basicOps&lt;list&lt;int&gt;&gt;("list");
   } ///:~

   The first function template,print( ), demonstrates the basic information you can get from any sequence container: whether it’s empty, its current size, the size of the largest possible container, the element at the beginning, and the element at the end. You can also see that every container hasbegin( ) andend( ) member functions that return iterators.
   ThebasicOps( ) function tests everything else (and in turn callsprint( )), including a variety of constructors: default, copy-constructor, quantity and initial value, and beginning and ending iterators. There are an assignmentoperator= and two kinds ofassign( ) member functions. One takes a quantity and an initial value, and the other takes a beginning and ending iterator.
   All the basic sequence containers are reversible containers, as shown by the use of therbegin( ) andrend( ) member functions. A sequence container can be resized, and the entire contents of the container can be removed withclear( ). When you call resize( ) to expand a sequence, the new elements use the default constructor of the type of element in the sequence, or if they are built-in types, they are zero-initialized.
   Using an iterator to indicate where you want to start inserting into any sequence container, you caninsert( ) a single element, a number of elements that all have the same value, and a group of elements from another container using the beginning and ending iterators of that group.
   Toerase( ) a single element from the middle, use an iterator; toerase( ) a range of elements, use a pair of iterators. Notice that since alist supports only bidirectional iterators, all the iterator motion must be performed with increments and decrements. (If the containers were limited tovectoranddeque, which produce random-access iterators,operator+ andoperator- could have been used to move the iterators in big jumps.)
   Although bothlist anddeque supportpush_front( ) andpop_front( ),vector does not, so the only member functions that work with all three arepush_back( ) andpop_back( ).
   The naming of the member functionswap( ) is a little confusing, since there’s also a nonmemberswap( ) algorithm that interchanges the values of any two objects of same type. The memberswap( ) swaps everything in one container for another (if the containers hold the same type), effectively swapping the containers themselves. It does this efficiently by swapping the contents of each container, which consists mostly of just pointers. The nonmemberswap( ) algorithm normally uses assignment to interchange its arguments (an expensive operation for an entire container), but is customized through template specialization to call the memberswap( ) for the standard containers. There is also aniter_swap algorithm that interchanges two elements in the same container pointed to by iterators.
   The following sections discuss the particulars of each type of sequence container.
   vector
   Thevector class template is intentionally made to look like a souped-up array, since it has array-style indexing, but also can expand dynamically. Thevector class template is so fundamentally useful that it was introduced in a primitive way early in this book and was used regularly in previous examples. This section will give a more in-depth look atvector.
   To achieve maximally fast indexing and iteration, thevector maintains its storage as a single contiguous array of objects. This is a critical point to observe in understanding the behavior ofvector. It means that indexing and iteration are lightning-fast, being basically the same as indexing and iterating over an array of objects. But it also means that inserting an object anywhere but at the end (that is, appending) is not really an acceptable operation for avector. In addition, when avector runs out of preallocated storage, to maintain its contiguous array it must allocate a whole new (larger) chunk of storage elsewhere and copy the objects to the new storage. This approach produces a number of unpleasant side-effects.
   Cost of overflowing allocated storage
   Avectorstarts by grabbing a block of storage, as if it’s taking a guess at how many objects you plan to put in it. As long as you don’t try to put in more objects than can be held in the initial block of storage, everything is rapid and efficient. (If youdoknow how many objects to expect, you can preallocate storage usingreserve( ).) But eventually you will put in one too many objects, and thevectorresponds by:
   1.Allocating a new, bigger piece of storage
   2.Copying all the objects from the old storage to the new (using the copy-constructor)
   3.Destroying all the old objects (the destructor is called for each one)
   4.Releasing the old memory
   For complex objects, this copy-construction and destruction can end up being expensive if you overfill your vector a lot, which is why vectors (and STL containers in general) are designed for value types (i.e. types that are cheap to copy). Of course, that includes pointers.
   To see what happens when you’re filling avector, here is theNoisy class mentioned earlier that prints information about its creations, destructions, assignments, and copy-constructions:
   //: C07:Noisy.h
   // A class to track various object activities
   #ifndef NOISY_H
   #define NOISY_H
   #include&lt;iostream&gt;
   using std::endl;

   class Noisy {
     static long create, assign, copycons, destroy;
     long id;
   public:
     Noisy() : id(create++) {
       std::cout&lt;&lt; "d["&lt;&lt; id&lt;&lt; "]"&lt;&lt; std::endl;
     }
     Noisy(const Noisy& rv) : id(rv.id) {
       std::cout&lt;&lt; "c["&lt;&lt; id&lt;&lt; "]"&lt;&lt; std::endl;
       copycons++;
     }
     Noisy& operator=(const Noisy& rv) {
       std::cout&lt;&lt; "("&lt;&lt; id&lt;&lt; ")=["&lt;&lt;
         rv.id&lt;&lt; "]"&lt;&lt; std::endl;
       id = rv.id;
       assign++;
       return *this;
     }
     friend bool
     operator&lt;(const Noisy& lv, const Noisy& rv) {
       return lv.id&lt; rv.id;
     }
     friend bool
     operator==(const Noisy& lv, const Noisy& rv) {
       return lv.id == rv.id;
     }
     ~Noisy() {
       std::cout&lt;&lt; "~["&lt;&lt; id&lt;&lt; "]"&lt;&lt; std::endl;
       destroy++;
     }
     friend std::ostream&
     operator&lt;&lt;(std::ostream& os, const Noisy& n) {
       return os&lt;&lt; n.id;
     }
     friend class NoisyReport;
   };

   struct NoisyGen {
     Noisy operator()() { return Noisy(); }
   };

   // A Singleton. Will automatically report the
   // statistics as the program terminates:
   class NoisyReport {
     static NoisyReport nr;
     NoisyReport() {} // Private constructor
   public:
     ~NoisyReport() {
       std::cout&lt;&lt; "\n-------------------\n"
        &lt;&lt; "Noisy creations: "&lt;&lt; Noisy::create
        &lt;&lt; "\nCopy-Constructions: "
        &lt;&lt; Noisy::copycons
        &lt;&lt; "\nAssignments: "&lt;&lt; Noisy::assign
        &lt;&lt; "\nDestructions: "&lt;&lt; Noisy::destroy
        &lt;&lt; std::endl;
     }
   };

   // Because of the following definitions, this file
   // can only be used in simple test situations. Move
   // them to a .cpp file for more complex programs:
   long Noisy::create = 0, Noisy::assign = 0,
     Noisy::copycons = 0, Noisy::destroy = 0;
   NoisyReport NoisyReport::nr;
   #endif // NOISY_H ///:~

   EachNoisy object has its own identifier, andstatic variables keep track of all the creations, assignments (usingoperator=), copy-constructions, and destructions. Theid is initialized using thecreate counter inside the default constructor; the copy-constructor and assignment operator take theirid values from the rvalue. Of course, withoperator= the lvalue is already an initialized object, so the old value ofid is printed before it is overwritten with theid from the rvalue.
   To support certain operations such as sorting and searching (which are used implicitly by some of the containers),Noisy must have anoperator&lt; andoperator==. These simply compare theid values. Theostream inserter follows the standard form and simply prints theid.
   Objects of typeNoisyGen are function objects (since there is anoperator( )) that produceNoisy objects during testing.
   NoisyReport is a Singleton object, because we only want one report printed at program termination. It has aprivate constructor, therefore, so no additionalNoisyReport objects can be created, and it has a single static instance ofNoisyReport callednr. The only executable statements are in the destructor, which is called as the program exits and the static destructors are called; this destructor prints the statistics captured by thestatic variables inNoisy.
   The one snag to this header file is the inclusion of the definitions for thestatics at the end. If you include this header in more than one place in your project, you’ll get multiple-definition errors at link time. Of course, you can put thestatic definitions in a separatecpp file and link it in, but that is less convenient, and sinceNoisy is just intended for quick-and-dirty experiments, the header file should be reasonable for most situations.
   UsingNoisy.h, the following program will show the behaviors that occur when avector overflows its currently allocated storage:
   //: C07:VectorOverflow.cpp
   //{-bor}
   // Shows the copy-construction and destruction
   // That occurs when a vector must reallocate
   #include&lt;cstdlib&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "Noisy.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     int size = 1000;
     if(argc&gt;= 2) size = atoi(argv[1]);
     vector&lt;Noisy&gt; vn;
     Noisy n;
     for(int i = 0; i&lt; size; i++)
       vn.push_back(n);
     cout&lt;&lt; "\n cleaning up \n";
   } ///:~

   You can use the default value of 1000, or you can use your own value by putting it on the command line.
   When you run this program, you’ll see a single default constructor call (forn), then a lot of copy-constructor calls, then some destructor calls, then some more copy-constructor calls, and so on. When the vector runs out of space in the linear array of bytes it has allocated, it must (to maintain all the objects in a linear array, which is an essential part of its job) get a bigger piece of storage and move everything over, copying first and then destroying the old objects. You can imagine that if you store a lot of large and complex objects, this process could rapidly become prohibitive.
   There are two solutions to this problem. The nicest one requires that you know beforehand how many objects you’re going to make. In that case, you can usereserve( ) to tell the vector how much storage to preallocate, thus eliminating all the copies and destructions and making everything very fast (especially random access to the objects withoperator[ ]). Note that the use ofreserve( ) is different from using thevector constructor with an integral first argument; the latter initializes each element using the default copy-constructor.
   However, in the more general case you won’t know how many objects you’ll need. Ifvector reallocations are slowing things down, you can change sequence containers. You could use alist, but as you’ll see, thedeque allows speedy insertions at either end of the sequence and never needs to copy or destroy objects as it expands its storage. Thedeque also allows random access withoperator[ ], but it’s not quite as fast asvector’soperator[ ]. So if you’re creating all your objects in one part of the program and randomly accessing them in another, you may find yourself filling adeque and then creating avector from thedeque and using thevector for rapid indexing. Of course, you don’t want to program this way habitually; just be aware of these issues (avoid premature optimization).
   There is a darker side tovector’s reallocation of memory, however. Becausevector keeps its objects in a nice, neat array (allowing, for one thing, maximally fast random access), the iterators used byvector can be simple pointers. This is a good thing—of all the sequence containers, these pointers allow the fastest selection and manipulation. Whether they are simple pointers, or whether they are iterator objects that hold an internal pointer into their container, consider what happens when you add the one additional object that causes thevector to reallocate storage and move it elsewhere. The iterator’s pointer is now pointing off into nowhere:.
   //: C07:VectorCoreDump.cpp
   // Invalidating an iterator
   #include&lt;iterator&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   using namespace std;

   int main() {
     vector&lt;int&gt; vi(10, 0);
     ostream_iterator&lt;int&gt; out(cout, " ");
     vector&lt;int&gt;::iterator i = vi.begin();
     *i = 47;
     copy(vi.begin(), vi.end(), out);
     cout&lt;&lt; endl;
     // Force it to move memory (could also just add
     // enough objects):
     vi.resize(vi.capacity() + 1);
     // Now i points to wrong memory:
     *i = 48;  // Access violation
     copy(vi.begin(), vi.end(), out); // No change to vi[0]
   } ///:~

   This illustrates the concept ofiterator invalidation. Certain operations cause internal changes to a container’s underlying data, so any iterators in effect before such changes may no longer be valid afterward. If your program is breaking mysteriously, look for places where you hold onto an iterator while adding more objects to avector. You’ll need to get a new iterator after adding elements or useoperator[ ]instead for element selections. If you combine this observation with the awareness of the potential expense for adding new objects to avector, you may conclude that the safest way to use one is to fill it up all at once (ideally, knowing first how many objects you’ll need) and then just use it (without adding more objects) elsewhere in the program. This is the wayvector has been used in the book up to this point. The standard C++ library documents which container operations invalidate iterators.
   You may observe that usingvectoras the "basic" container in the earlier chapters of this book might not be the best choice in all cases. This is a fundamental issue in containers and in data structures in general: the "best" choice varies according to the way the container is used. The reasonvector has been the "best" choice up until now is that it looks a lot like an array and was thus familiar and easy for you to adopt. But from now on it’s also worth thinking about other issues when choosing containers.
   Inserting and erasing elements
   Thevector is most efficient if:
   5.Youreserve( ) the correct amount of storage at the beginning so thevector never has to reallocate.
   6.You only add and remove elements from the back end.
   It is possible to insert and erase elements from the middle of avector using an iterator, but the following program demonstrates what a bad idea this is:
   //: C07:VectorInsertAndErase.cpp
   // Erasing an element from a vector
   //{-bor}
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   #include "Noisy.h"
   using namespace std;

   int main() {
     vector&lt;Noisy&gt; v;
     v.reserve(11);
     cout&lt;&lt; "11 spaces have been reserved"&lt;&lt; endl;
     generate_n(back_inserter(v), 10, NoisyGen());
     ostream_iterator&lt;Noisy&gt; out(cout, " ");
     cout&lt;&lt; endl;
     copy(v.begin(), v.end(), out);
     cout&lt;&lt; "Inserting an element:"&lt;&lt; endl;
     vector&lt;Noisy&gt;::iterator it =
       v.begin() + v.size() / 2; // Middle
     v.insert(it, Noisy());
     cout&lt;&lt; endl;
     copy(v.begin(), v.end(), out);
     cout&lt;&lt; "\nErasing an element:"&lt;&lt; endl;
     // Cannot use the previous value of it:
     it = v.begin() + v.size() / 2;
     v.erase(it);
     cout&lt;&lt; endl;
     copy(v.begin(), v.end(), out);
     cout&lt;&lt; endl;
   } ///:~

   When you run the program, you’ll see that the call toreserve( ) really does only allocate storage—no constructors are called. Thegenerate_n( ) call is busy: each call toNoisyGen::operator( ) results in a construction, a copy-construction (into thevector), and a destruction of the temporary. But when an object is inserted into thevector in the middle, it must shove everything down to maintain the linear array, and, since there is enough space, it does this with the assignment operator. (If the argument ofreserve( ) is 10 instead of 11, it would have to reallocate storage.) When an object is erased from thevector, the assignment operator is once again used to move everything up to cover the place that is being erased. (Notice that this requires that the assignment operator properly clean up the lvalue.) Last, the object on the end of the array is deleted.
   deque
   Thedeque container is a basic sequence optimized for adding and removing elements from either end. It also allows for reasonably fast random access—it has anoperator[ ] likevector. However, it does not havevector’s constraint of keeping everything in a single sequential block of memory. Instead, a typical implementation ofdeque uses multiple blocks of sequential storage (keeping track of all the blocks and their order in a mapping structure). For this reason, the overhead for adeque to add or remove elements at either end is low. In addition, it never needs to copy and destroy contained objects during a new storage allocation (likevector does), so it is far more efficient thanvector if you are adding an unknown quantity of objects at either end. This means thatvector is the best choice only if you have a good idea of how many objects you need. In addition, many of the programs shown earlier in this book that usevector andpush_back( ) might be more efficient with adeque. The interface todeque is only slightly different from avector (deque has apush_front( ) andpop_front( ) whilevector does not, for example), so converting code from usingvector to usingdeque is almost trivial. ConsiderStringVector.cpp, which can be changed to usedeque by replacing the word "vector" with "deque" everywhere. The following program adds paralleldeque operations to thevector operations inStringVector.cpp and performs timing comparisons:
   //: C07:StringDeque.cpp
   // Converted from StringVector.cpp
   #include&lt;cstddef&gt;
   #include&lt;ctime&gt;
   #include&lt;deque&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     char* fname = "StringDeque.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     vector&lt;string&gt; vstrings;
     deque&lt;string&gt; dstrings;
     string line;
     // Time reading into vector:
     clock_t ticks = clock();
     while(getline(in, line))
       vstrings.push_back(line);
     ticks = clock() - ticks;
     cout&lt;&lt; "Read into vector: "&lt;&lt; ticks&lt;&lt; endl;
     // Repeat for deque:
     ifstream in2(fname);
     assure(in2, fname);
     ticks = clock();
     while(getline(in2, line))
       dstrings.push_back(line);
     ticks = clock() - ticks;
     cout&lt;&lt; "Read into deque: "&lt;&lt; ticks&lt;&lt; endl;
     // Now compare indexing:
     ticks = clock();
     for(size_t i = 0; i&lt; vstrings.size(); i++) {
       ostringstream ss;
       ss&lt;&lt; i;
       vstrings[i] = ss.str() + ": " + vstrings[i];
     }
     ticks = clock() - ticks;
     cout&lt;&lt; "Indexing vector: "&lt;&lt; ticks&lt;&lt; endl;
     ticks = clock();
     for(size_t j = 0; j&lt; dstrings.size(); j++) {
       ostringstream ss;
       ss&lt;&lt; j;
       dstrings[j] = ss.str() + ": " + dstrings[j];
     }
     ticks = clock() - ticks;
     cout&lt;&lt; "Indexing deque: "&lt;&lt; ticks&lt;&lt; endl;
     // Compare iteration
     ofstream tmp1("tmp1.tmp"), tmp2("tmp2.tmp");
     ticks = clock();
     copy(vstrings.begin(), vstrings.end(),
       ostream_iterator&lt;string&gt;(tmp1, "\n"));
     ticks = clock() - ticks;
     cout&lt;&lt; "Iterating vector: "&lt;&lt; ticks&lt;&lt; endl;
     ticks = clock();
     copy(dstrings.begin(), dstrings.end(),
       ostream_iterator&lt;string&gt;(tmp2, "\n"));
     ticks = clock() - ticks;
     cout&lt;&lt; "Iterating deque: "&lt;&lt; ticks&lt;&lt; endl;
   } ///:~

   Knowing now what you do about the inefficiency of adding things tovector because of storage reallocation, you might expect dramatic differences between the two. However, on a 1.7MB text file, one compiler’s program produced the following (measured in platform/compiler specific clock ticks, not seconds):
   Read into vector: 8350
   Read into deque: 7690
   Indexing vector: 2360
   Indexing deque: 2480
   Iterating vector: 2470
   Iterating deque: 2410

   A different compiler and platform roughly agreed with this. It’s not so dramatic, is it? This points out some important issues:
   1.We (programmers and authors) are typically bad at guessing where inefficiencies occur in our programs.
   2.Efficiency comes from a combination of effects. Here, reading the lines in and converting them to strings may dominate over the cost of thevector vs.deque.
   3.Thestring class is probably fairly well designed in terms of efficiency.
   Of course, this doesn’t mean you shouldn’t use adeque rather than avector when you know that an uncertain number of objects will be pushed onto the end of the container. On the contrary, you should—when you’re tuning for performance. But also be aware that performance issues are usually not where you think they are, and the only way to know for sure where your bottlenecks are is by testing. Later in this chapter, you’ll see a more "pure" comparison of performance betweenvector,deque, andlist.
   Converting between sequences
   Sometimes you need the behavior or efficiency of one kind of container for one part of your program, and you need a different container’s behavior or efficiency in another part of the program. For example, you may need the efficiency of adeque when adding objects to the container but the efficiency of avector when indexing them. Each of the basic sequence containers (vector,deque, andlist) has a two-iterator constructor (indicating the beginning and ending of the sequence to read from when creating a new object) and anassign( ) member function to read into an existing container, so you can easily move objects from one sequence container to another.
   The following example reads objects into adeque and then converts to avector:
   //: C07:DequeConversion.cpp
   // Reading into a Deque, converting to a vector
   //{-bor}
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;deque&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "Noisy.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     int size = 25;
     if(argc&gt;= 2) size = atoi(argv[1]);
     deque&lt;Noisy&gt; d;
     generate_n(back_inserter(d), size, NoisyGen());
     cout&lt;&lt; "\n Converting to a vector(1)"&lt;&lt; endl;
     vector&lt;Noisy&gt; v1(d.begin(), d.end());
     cout&lt;&lt; "\n Converting to a vector(2)"&lt;&lt; endl;
     vector&lt;Noisy&gt; v2;
     v2.reserve(d.size());
     v2.assign(d.begin(), d.end());
     cout&lt;&lt; "\n Cleanup"&lt;&lt; endl;
   } ///:~

   You can try various sizes, but note that it makes no difference—the objects are simply copy-constructed into the newvectors. What’s interesting is thatv1 does not cause multiple allocations while building thevector, no matter how many elements you use. You might initially think that you must follow the process used forv2 and preallocate the storage to prevent messy reallocations, but this is unnecessary because the constructor used forv1 determines the memory need ahead of time.
   Cost of overflowing allocated storage
   It’s illuminating to see what happens with adeque when it overflows a block of storage, in contrast withVectorOverflow.cpp:
   //: C07:DequeOverflow.cpp
   //{-bor}
   // A deque is much more efficient than a vector
   // when pushing back a lot of elements, since it
   // doesn't require copying and destroying.
   #include&lt;cstdlib&gt;
   #include&lt;deque&gt;
   #include "Noisy.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     int size = 1000;
     if(argc&gt;= 2) size = atoi(argv[1]);
     deque&lt;Noisy&gt; dn;
     Noisy n;
     for(int i = 0; i&lt; size; i++)
       dn.push_back(n);
     cout&lt;&lt; "\n cleaning up \n";
   } ///:~

   Here you will have relatively few (if any) destructors called before the words "cleaning up" appear. Since thedeque allocates all its storage in blocks instead of a contiguous array likevector, it never needs to move existing storage of each of its data blocks. (Thus, no additional copy-constructions and destructions occur.) Thedeque simply allocates a new block. For the same reason, thedeque can just as efficiently add elements to thebeginning of the sequence, since if it runs out of storage, it (again) just allocates a new block for the beginning. (The index block that holds the data blocks together may need to be reallocated, however.) Insertions in the middle of adeque, however, could be even messier than forvector (but not as costly).
   Because ofdeque’s clever storage management, an existing iterator is not invalidated after you add new things to either end of a deque, as it was demonstrated to do withvector (inVectorCoreDump.cpp). If you stick to whatdeque is best at—insertions and removals from either end, reasonably rapid traversals and fairly fast random-access usingoperator[ ]—you’ll be in good shape.
   Checked random-access
   Bothvectoranddeque provide two ways to perform random access of their elements: theoperator[ ], which you’ve seen already, andat( ), which checks the boundaries of the container that’s being indexed and throws an exception if you go out of bounds. It does cost more to useat( ):
   //: C07:IndexingVsAt.cpp
   // Comparing "at()" to operator[]
   #include&lt;ctime&gt;
   #include&lt;deque&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     long count = 1000;
     int sz = 1000;
     if(argc&gt;= 2) count = atoi(argv[1]);
     if(argc&gt;= 3) sz = atoi(argv[2]);
     vector&lt;int&gt; vi(sz);
     clock_t ticks = clock();
     for(int i1 = 0; i1&lt; count; i1++)
       for(int j = 0; j&lt; sz; j++)
         vi[j];
     cout&lt;&lt; "vector[] "&lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i2 = 0; i2&lt; count; i2++)
       for(int j = 0; j&lt; sz; j++)
         vi.at(j);
     cout&lt;&lt; "vector::at() "&lt;&lt; clock()-ticks&lt;&lt;endl;
     deque&lt;int&gt; di(sz);
     ticks = clock();
     for(int i3 = 0; i3&lt; count; i3++)
       for(int j = 0; j&lt; sz; j++)
         di[j];
     cout&lt;&lt; "deque[] "&lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i4 = 0; i4&lt; count; i4++)
       for(int j = 0; j&lt; sz; j++)
         di.at(j);
     cout&lt;&lt; "deque::at() "&lt;&lt; clock()-ticks&lt;&lt;endl;
     // Demonstrate at() when you go out of bounds:
     try {
       di.at(vi.size() + 1);
     } catch(...) {
       cerr&lt;&lt; "Exception thrown"&lt;&lt; endl;
     }
   } ///:~

   As you saw in Chapter 1, different systems may handle the uncaught exception in different ways, but you’ll know one way or another that something went wrong with the program when usingat( ), whereas it’s possible to go blundering ahead usingoperator[ ].
   list
   Alist is implemented as a doubly linked list data structure and is thus designed for rapid insertion and removal of elementsanywhere in the sequence, whereas forvector anddequethis is a much more costly operation. A list is so slow when randomly accessing elements that it does not have anoperator[ ]. It’s best used when you’re traversing a sequence, in order, from beginning to end (or vice-versa), rather than choosing elements randomly from the middle. Even then the traversal can be slower than with avector, but if you aren’t doing a lot of traversals, that won’t be your bottleneck.
   Another thing to be aware of with alist is the memory overhead of each link, which requires a forward and backward pointer on top of the storage for the actual object. Thus, alist is a better choice when you have larger objects that you’ll be inserting and removing from the middle of thelist.
   It’s better not to use alistif you think you might be traversing it a lot, looking for objects, since the amount of time it takes to get from the beginning of thelist—which is the only place you can start unless you’ve already got an iterator to somewhere you know is closer to your destination—to the object of interest is proportional to the number of objects between the beginning and that object.
   The objects in alistnever move after they are created; "moving" a list element means changing the links, but never copying or assigning the actual objects. This means that iterators aren't invalidated when items are added to the list as it was demonstrated earlier to be the casevector. Here’s an example using theNoisy class:
   //: C07:ListStability.cpp
   // Things don't move around in lists
   //{-bor}
   #include "Noisy.h"
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;list&gt;
   using namespace std;

   int main() {
     list&lt;Noisy&gt; l;
     ostream_iterator&lt;Noisy&gt; out(cout, " ");
     generate_n(back_inserter(l), 25, NoisyGen());
     cout&lt;&lt; "\n Printing the list:"&lt;&lt; endl;
     copy(l.begin(), l.end(), out);
     cout&lt;&lt; "\n Reversing the list:"&lt;&lt; endl;
     l.reverse();
     copy(l.begin(), l.end(), out);
     cout&lt;&lt; "\n Sorting the list:"&lt;&lt; endl;
     l.sort();
     copy(l.begin(), l.end(), out);
     cout&lt;&lt; "\n Swapping two elements:"&lt;&lt; endl;
     list&lt;Noisy&gt;::iterator it1, it2;
     it1 = it2 = l.begin();
     it2++;
     swap(*it1, *it2);
     cout&lt;&lt; endl;
     copy(l.begin(), l.end(), out);
     cout&lt;&lt; "\n Using generic reverse(): "&lt;&lt; endl;
     reverse(l.begin(), l.end());
     cout&lt;&lt; endl;
     copy(l.begin(), l.end(), out);
     cout&lt;&lt; "\n Cleanup"&lt;&lt; endl;
   } ///:~

   Operations as seemingly radical as reversing and sorting the list require no copying of objects, because instead of moving the objects, the links are simply changed. However, notice thatsort( ) andreverse( ) are member functions oflist, so they have special knowledge of the internals oflist and can rearrange the elements instead of copying them. On the other hand, theswap( ) function is a generic algorithm and doesn’t know aboutlist in particular, so it uses the copying approach for swapping two elements. In general, use the member version of an algorithm if that is supplied instead of its generic algorithm equivalent. In particular, use the genericsort( ) andreverse( ) algorithms only with arrays,vectors, anddeques.
   If you have large, complex objects, you might want to choose alist first, especially if construction, destruction, copy-construction, and assignment are expensive and if you are doing things like sorting the objects or otherwise reordering them a lot.
   Special list operations
   Thelist has some special built-in operations to make the best use of the structure of thelist. You’ve already seenreverse( ) andsort( ), and here are some of the others in use:
   //: C07:ListSpecialFunctions.cpp
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;list&gt;
   #include "Noisy.h"
   using namespace std;
   ostream_iterator&lt;Noisy&gt; out(cout, " ");

   void print(list&lt;Noisy&gt;& ln, char* comment = "") {
     cout&lt;&lt; "\n"&lt;&lt; comment&lt;&lt; ":\n";
     copy(ln.begin(), ln.end(), out);
     cout&lt;&lt; endl;
   }

   int main() {
     typedef list&lt;Noisy&gt; LN;
     LN l1, l2, l3, l4;
     generate_n(back_inserter(l1), 6, NoisyGen());
     generate_n(back_inserter(l2), 6, NoisyGen());
     generate_n(back_inserter(l3), 6, NoisyGen());
     generate_n(back_inserter(l4), 6, NoisyGen());
     print(l1, "l1"); print(l2, "l2");
     print(l3, "l3"); print(l4, "l4");
     LN::iterator it1 = l1.begin();
     it1++; it1++; it1++;
     l1.splice(it1, l2);
     print(l1, "l1 after splice(it1, l2)");
     print(l2, "l2 after splice(it1, l2)");
     LN::iterator it2 = l3.begin();
     it2++; it2++; it2++;
     l1.splice(it1, l3, it2);
     print(l1, "l1 after splice(it1, l3, it2)");
     LN::iterator it3 = l4.begin(), it4 = l4.end();
     it3++; it4--;
     l1.splice(it1, l4, it3, it4);
     print(l1, "l1 after splice(it1,l4,it3,it4)");
     Noisy n;
     LN l5(3, n);
     generate_n(back_inserter(l5), 4, NoisyGen());
     l5.push_back(n);
     print(l5, "l5 before remove()");
     l5.remove(l5.front());
     print(l5, "l5 after remove()");
     l1.sort(); l5.sort();
     l5.merge(l1);
     print(l5, "l5 after l5.merge(l1)");
     cout&lt;&lt; "\n Cleanup"&lt;&lt; endl;
   } ///:~

   Theprint( ) function displays results. After filling fourlists withNoisy objects, one list is spliced into another in three ways. In the first, the entire listl2 is spliced intol1 at the iteratorit1. Notice that after the splice,l2 is empty—splicing means removing the elements from the source list. The second splice inserts elements froml3starting atit2 intol1starting atit1. The third splice starts atit1 and uses elements froml4 starting atit3 and ending atit4 (the seemingly redundant mention of the source list is because the elements must be erased from the source list as part of the transfer to the destination list).
   The output from the code that demonstratesremove( ) shows that the list does not have to be sorted in order for all the elements of a particular value to be removed.
   Finally, if youmerge( ) one list with another, the merge only works sensibly if the lists have been sorted. What you end up with in that case is a sorted list containing all the elements from both lists (the source list is erased—that is, the elements aremoved to the destination list).
   Aunique( ) member function removes all duplicates, but only if you sort thelist first:
   //: C07:UniqueList.cpp
   // Testing list's unique() function
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;list&gt;
   using namespace std;

   int a[] = { 1, 3, 1, 4, 1, 5, 1, 6, 1 };
   const int asz = sizeof a / sizeof *a;

   int main() {
     // For output:
     ostream_iterator&lt;int&gt; out(cout, " ");
     list&lt;int&gt; li(a, a + asz);
     li.unique();
     // Oops! No duplicates removed:
     copy(li.begin(), li.end(), out);
     cout&lt;&lt; endl;
     // Must sort it first:
     li.sort();
     copy(li.begin(), li.end(), out);
     cout&lt;&lt; endl;
     // Now unique() will have an effect:
     li.unique();
     copy(li.begin(), li.end(), out);
     cout&lt;&lt; endl;
   } ///:~

   Thelist constructor used here takes the starting and past-the-end iterator from another container and copies all the elements from that container into itself. (A similar constructor is available for all the containers.) Here, the "container" is just an array, and the "iterators" are pointers into that array, but because of the design of the STL, it works with arrays just as easily as any other container.
   Theunique( ) function will remove onlyadjacent duplicate elements, and thus sorting is necessary before callingunique( ).
   Four additionallistmember functions are not demonstrated here: aremove_if( ) that takes a predicate, which decides whether an object should be removed; aunique( ) that takes a binary predicate to perform uniqueness comparisons; amerge( ) that takes an additional argument which performs comparisons; and asort( ) that takes a comparator (to provide a comparison or override the existing one).
   list vs. set
   Looking at the previous example, you might note that if you want a sorted list with no duplicates, aset can give you that, right? It’s interesting to compare the performance of the two containers:
   //: C07:ListVsSet.cpp
   // Comparing list and set performance
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;set&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   using namespace std;

   class Obj {
     int a[20]; // To take up extra space
     int val;
   public:
     Obj() : val(rand() % 500) {}
     friend bool
     operator&lt;(const Obj& a, const Obj& b) {
       return a.val&lt; b.val;
     }
     friend bool
     operator==(const Obj& a, const Obj& b) {
       return a.val == b.val;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Obj& a) {
       return os&lt;&lt; a.val;
     }
   };

   template&lt;class Container&gt;
   void print(Container& c) {
     typename Container::iterator it;
     for(it = c.begin(); it != c.end(); it++)
       cout&lt;&lt; *it&lt;&lt; " ";
     cout&lt;&lt; endl;
   }

   struct ObjGen {
     Obj operator()() { return Obj(); }
   };

   int main() {
     const int sz = 5000;
     srand(time(0));
     list&lt;Obj&gt; lo;
     clock_t ticks = clock();
     generate_n(back_inserter(lo), sz, ObjGen());
     lo.sort();
     lo.unique();
     cout&lt;&lt; "list:"&lt;&lt; clock() - ticks&lt;&lt; endl;
     set&lt;Obj&gt; so;
     ticks = clock();
     generate_n(inserter(so, so.begin()),
       sz, ObjGen());
     cout&lt;&lt; "set:"&lt;&lt; clock() - ticks&lt;&lt; endl;
     print(lo);
     print(so);
   } ///:~

   When you run the program, you should discover thatset is much faster thanlist. This is reassuring—after all, itisset’s primary job description!.
   Swapping basic sequences
   We mentioned earlier that all basic sequences have a member functionswap( ) that’s designed to switch one sequence with another (but only for sequences of the same type). The memberswap( ) makes use of its knowledge of the internal structure of the particular container in order to be efficient:
   //: C07:Swapping.cpp
   //{-bor}
   // All basic sequence containers can be swapped
   #include "Noisy.h"
   #include&lt;algorithm&gt;
   #include&lt;deque&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;list&gt;
   #include&lt;vector&gt;
   using namespace std;
   ostream_iterator&lt;Noisy&gt; out(cout, " ");

   template&lt;class Cont&gt;
   void print(Cont& c, char* comment = "") {
     cout&lt;&lt; "\n"&lt;&lt; comment&lt;&lt; ": ";
     copy(c.begin(), c.end(), out);
     cout&lt;&lt; endl;
   }

   template&lt;class Cont&gt;
   void testSwap(char* cname) {
     Cont c1, c2;
     generate_n(back_inserter(c1), 10, NoisyGen());
     generate_n(back_inserter(c2), 5, NoisyGen());
     cout&lt;&lt; "\n"&lt;&lt; cname&lt;&lt; ":"&lt;&lt; endl;
     print(c1, "c1"); print(c2, "c2");
     cout&lt;&lt; "\n Swapping the "&lt;&lt; cname
      &lt;&lt; ":"&lt;&lt; endl;
     c1.swap(c2);
     print(c1, "c1"); print(c2, "c2");
   }

   int main() {
     testSwap&lt;vector&lt;Noisy&gt;&gt;("vector");
     testSwap&lt;deque&lt;Noisy&gt;&gt;("deque");
     testSwap&lt;list&lt;Noisy&gt;&gt;("list");
   } ///:~

   When you run this, you’ll discover that each type of sequence container can swap one sequence for another without any copying or assignments, even if the sequences are of different sizes. In effect, you’re completely swapping the resources of one object for another.
   The STL algorithms also contain aswap( ), and when this function is applied to two containers of the same type, it uses the memberswap( ) to achieve fast performance. Consequently, if you apply thesort( ) algorithm to a container of containers, you will find that the performance is very fast—it turns out that fast sorting of a container of containers was a design goal of the STL.
   set
   Theset produces a container that will accept only one of each thing you place in it; it also sorts the elements. (Sorting isn’t intrinsic to the conceptual definition of a set, but the STLset stores its elements in a balanced tree data structure to provide rapid lookups, thus producing sorted results when you traverse it.) The first two examples in this chapter usedsets.
   Consider the problem of creating an index for a book. You might like to start with all the words in the book, but you only want one instance of each word, and you want them sorted. Of course, aset is perfect for this and solves the problem effortlessly. However, there’s also the problem of punctuation and any other nonalpha characters, which must be stripped off to generate proper words. One solution to this problem is to use the Standard C library functionsisalpha( ) andisspace( ) to extract only the characters you want. You can replace all unwanted characters with spaces so that you can easily extract valid words from each line you read:
   //: C07:WordList.cpp
   // Display a list of words used in a document
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;cstring&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;set&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;
   char replaceJunk(char c) {
      // Only keep alphas, space (as a delimiter), and '
      return (isalpha(c) || c == '\'') ? c : ' ';
   }
   int main(int argc, char* argv[]) {
     char* fname = "WordList.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     set&lt;string&gt; wordlist;
     string line;
     while(getline(in, line)) {
       transform(line.begin(), line.end(), line.begin(),
                 replaceJunk);
       istringstream is(line);
       string word;
       while (is&gt;&gt; word)
         wordlist.insert(word);
       }
     // Output results:
     copy(wordlist.begin(), wordlist.end(),
          ostream_iterator&lt;string&gt;(cout, "\n"));
   } ///:~

   The call totransform( ) replaces each character to be ignored with a space. The set container not only ignores duplicate words, but compares the words it keeps according to the function objectless&lt;string&gt; (the default second template argument for theset container), which in turn usesstring::operator&lt;( ), so the words emerge in alphabetical order.
   You don’t have to use aset just to get a sorted sequence. You can use thesort( ) function (along with a multitude of other functions in the STL) on different STL containers. However, it’s likely thatset will be faster. Using a set is particularly handy when you just want to do lookup, since itsfind( ) member function has logarithmic complexity and therefore is much faster than the genericfind( ) algorithm.
   The following version shows how to build the list of words with anistreambuf_iterator that moves the characters from one place (the input stream) to another (astringobject), depending on whether the Standard C library functionisalpha( ) returns true:
   //: C07:WordList2.cpp
   // Illustrates istreambuf_iterator and insert iterators
   #include&lt;cstring&gt;
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;set&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     char* fname = "WordList2.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     istreambuf_iterator&lt;char&gt; p(in), end;
     set&lt;string&gt; wordlist;
     while (p != end) {
       string word;
       insert_iterator&lt;string&gt;
         ii(word, word.begin());
       // Find the first alpha character:
       while(!isalpha(*p)&& p != end)
         p++;
       // Copy until the first non-alpha character:
       while (isalpha(*p)&& p != end)
         *ii++ = *p++;
       if (word.size() != 0)
         wordlist.insert(word);
     }
     // Output results:
     copy(wordlist.begin(), wordlist.end(),
       ostream_iterator&lt;string&gt;(cout, "\n"));
   } ///:~

   This example was suggested by Nathan Myers, who invented theistreambuf_iterator and its relatives. This iterator extracts information character by character from a stream. Although theistreambuf_iteratortemplate argument might suggest that you could extract, for example,ints instead ofchar, that’s not the case. The argument must be of some character type—a regularchar or a wide character.
   After the file is open, anistreambuf_iterator calledp is attached to theistream so characters can be extracted from it. Theset&lt;string&gt; calledwordlist will hold the resulting words.
   Thewhile loop reads words until the end of the input stream is found. This is detected using the default constructor foristreambuf_iterator, which produces the past-the-end iterator objectend. Thus, if you want to test to make sure you’re not at the end of the stream, you simply sayp != end.
   The second type of iterator that’s used here is theinsert_iterator, which creates an iterator that knows how to insert objects into a container. Here, the "container" is thestring calledword, which, for the purposes ofinsert_iterator, behaves like a container. The constructor forinsert_iterator requires the container and an iterator indicating where it should start inserting the characters. You could also use aback_insert_iterator, which requires that the container have apush_back( ) (string does).
   After thewhile loop sets everything up, it begins by looking for the first alpha character, incrementingstart until that character is found. It then copies characters from one iterator to the other, stopping when a nonalpha character is found. Eachword, assuming it is nonempty, is added towordlist.
   A completely reusable tokenizer
   The word list examples use different approaches to extract tokens from a stream, neither of which is very flexible. Since the STL containers and algorithms all revolve around iterators, the most flexible solution will itself use an iterator. You could think of theTokenIterator as an iterator that wraps itself around any other iterator that can produce characters. Because it is certainly a type of input iterator (the most primitive type of iterator), it can provide input to any STL algorithm. Not only is it a useful tool in itself, the followingTokenIterator is also a good example of how you can design your own iterators.[97]
   TheTokenIterator class is doubly flexible. First, you can choose the type of iterator that will produce thechar input. Second, instead of just saying what characters represent the delimiters,TokenIterator will use a predicate that is a function object whoseoperator( ) takes achar and decides whether it should be in the token. Although the two examples given here have a static concept of what characters belong in a token, you could easily design your own function object to change its state as the characters are read, producing a more sophisticated parser.
   The following header file contains two basic predicates,Isalpha andDelimiters, along with the template forTokenIterator:
   //: C07:TokenIterator.h
   #ifndef TOKENITERATOR_H
   #define TOKENITERATOR_H
   #include&lt;algorithm&gt;
   #include&lt;cctype&gt;
   #include&lt;functional&gt;
   #include&lt;iterator&gt;
   #include&lt;string&gt;

   struct Isalpha : std::unary_function&lt;char, bool&gt; {
     bool operator()(char c) {
       return std::isalpha(c);
     }
   };

   class Delimiters : std::unary_function&lt;char, bool&gt; {
     std::string exclude;
   public:
     Delimiters() {}
     Delimiters(const std::string& excl)
       : exclude(excl) {}
     bool operator()(char c) {
       return exclude.find(c) == std::string::npos;
     }
   };

   template&lt;class InputIter, class Pred = Isalpha&gt;
   class TokenIterator : public std::iterator&lt;
       std::input_iterator_tag,std::string, std::ptrdiff_t&gt; {
     InputIter first;
     InputIter last;
     std::string word;
     Pred predicate;
   public:
     TokenIterator(InputIter begin, InputIter end,
       Pred pred = Pred())
       : first(begin), last(end), predicate(pred) {
         ++*this;
     }
     TokenIterator() {} // End sentinel
     // Prefix increment:
     TokenIterator& operator++() {
       word.resize(0);
       first = std::find_if(first, last, predicate);
       while (first != last&& predicate(*first))
         word += *first++;
       return *this;
     }
     // Postfix increment
     class Proxy {
       std::string word;
     public:
       Proxy(const std::string& w) : word(w) {}
       std::string operator*() { return word; }
     };
     Proxy operator++(int) {
       Proxy d(word);
       ++*this;
       return d;
     }
     // Produce the actual value:
     std::string operator*() const { return word; }
     std::string* operator-&gt;() const {
       return&(operator*());
     }
     // Compare iterators:
     bool operator==(const TokenIterator&) {
       return word.size() == 0&& first == last;
     }
     bool operator!=(const TokenIterator& rv) {
       return !(*this == rv);
     }
   };
   #endif // TOKENITERATOR_H ///:~

   TheTokenIterator class derives from thestd::iterator template. It might appear that some kind of functionality comes withstd::iterator, but it is purely a way of tagging an iterator so that a container that uses it knows what it’s capable of. Here, you can seeinput_iterator_tag as theiterator_category template argument—this tells anyone who asks that aTokenIterator only has the capabilities of an input iterator and cannot be used with algorithms requiring more sophisticated iterators. Apart from the tagging,std::iterator doesn’t do anything beyond providing several useful type definitions, which means you must design all the other functionality in yourself.
   TheTokenIterator class may look a little strange at first, because the first constructor requires both a "begin" and an "end" iterator as arguments, along with the predicate. Remember, this is a "wrapper" iterator that has no idea how to tell whether it’s at the end of its input source, so the ending iterator is necessary in the first constructor. The reason for the second (default) constructor is that the STL algorithms (and any algorithms you write) need aTokenIteratorsentinel to be the past-the-end value. Since all the information necessary to see if theTokenIterator has reached the end of its input is collected in the first constructor, this second constructor creates aTokenIterator that is merely used as a placeholder in algorithms.
   The core of the behavior happens inoperator++. This erases the current value ofword usingstring::resize( ) and then finds the first character that satisfies the predicate (thus discovering the beginning of the new token) usingfind_if( ) (from the STL algorithms, discussed in the following chapter). The resulting iterator is assigned tofirst, thus movingfirst forward to the beginning of the token. Then, as long as the end of the input is not reached and the predicate is satisfied, input characters are copied intoword. Finally, theTokenIterator object is returned and must be dereferenced to access the new token.
   The postfix increment requires a proxy object to hold the value before the increment, so it can be returned. Producing the actual value is a straightforwardoperator*. The only other functions that must be defined for an output iterator are theoperator== andoperator!= to indicate whether theTokenIterator has reached the end of its input. You can see that the argument foroperator==is ignored—it only cares about whether it has reached its internallast iterator. Notice thatoperator!= is defined in terms ofoperator==.
   A good test ofTokenIterator includes a number of different sources of input characters, including astreambuf_iterator, achar*, and adeque&lt;char&gt;::iterator. Finally, the original word list problem is solved:
   //: C07:TokenIteratorTest.cpp
   //{-msc}
   #include "TokenIterator.h"
   #include "../require.h"
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;deque&gt;
   #include&lt;set&gt;
   using namespace std;

   int main(int argc, char* argv[]) {
     char* fname = "TokenIteratorTest.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     ostream_iterator&lt;string&gt; out(cout, "\n");
     typedef istreambuf_iterator&lt;char&gt; IsbIt;
     IsbIt begin(in), isbEnd;
     Delimiters
       delimiters(" \t\n~;()\"&lt;&gt;:{}[]+-=&*#.,/\\");
     TokenIterator&lt;IsbIt, Delimiters&gt;
       wordIter(begin, isbEnd, delimiters),
       end;
     vector&lt;string&gt; wordlist;
     copy(wordIter, end, back_inserter(wordlist));
     // Output results:
     copy(wordlist.begin(), wordlist.end(), out);
     *out++ = "-----------------------------------";
     // Use a char array as the source:
     char* cp =
       "typedef std::istreambuf_iterator&lt;char&gt; It";
     TokenIterator&lt;char*, Delimiters&gt;
       charIter(cp, cp + strlen(cp), delimiters),
       end2;
     vector&lt;string&gt; wordlist2;
     copy(charIter, end2, back_inserter(wordlist2));
     copy(wordlist2.begin(), wordlist2.end(), out);
     *out++ = "-----------------------------------";
     // Use a deque&lt;char&gt; as the source:
     ifstream in2("TokenIteratorTest.cpp");
     deque&lt;char&gt; dc;
     copy(IsbIt(in2), IsbIt(), back_inserter(dc));
     TokenIterator&lt;deque&lt;char&gt;::iterator,Delimiters&gt;
       dcIter(dc.begin(), dc.end(), delimiters),
       end3;
     vector&lt;string&gt; wordlist3;
     copy(dcIter, end3, back_inserter(wordlist3));
     copy(wordlist3.begin(), wordlist3.end(), out);
     *out++ = "-----------------------------------";
     // Reproduce the Wordlist.cpp example:
     ifstream in3("TokenIteratorTest.cpp");
     TokenIterator&lt;IsbIt, Delimiters&gt;
       wordIter2((IsbIt(in3)), isbEnd, delimiters);
     set&lt;string&gt; wordlist4;
     while(wordIter2 != end)
       wordlist4.insert(*wordIter2++);
     copy(wordlist4.begin(), wordlist4.end(), out);
   } ///:~

   When using anistreambuf_iterator, you create one to attach to theistream object and one with the default constructor as the past-the-end marker. Both are used to create theTokenIterator that will actually produce the tokens; the default constructor produces the fauxTokenIterator past-the-end sentinel. (This is just a placeholder and, as mentioned previously, is actually ignored.) TheTokenIterator producesstrings that are inserted into a container which must, naturally, be a container ofstring—here avector&lt;string&gt; is used in all cases except the last. (You could also concatenate the results onto astring.) Other than that, aTokenIterator works like any other input iterator.
   The strangest thing in the previous program is the declaration ofwordIter2. Note the extra parentheses in the first argument to the constructor. Without these, a conforming compiler will think thatwordIter2 is a prototype for a function that has three arguments and returns aTokenIterator&lt;IsbIt, Delimiters&gt;.[98] (Microsoft’s Visual C++ .NET compiler accepts it without the extra parentheses, but it shouldn’t.).
   stack
   Thestack, along with thequeue andpriority_queue, are classified asadapters, which means they adapt one of the basic sequence containers to store their data. This is an unfortunate case of confusing what something does with the details of its underlying implementation—the fact that these are called "adapters" is of primary value only to the creator of the library. When you use them, you generally don’t care that they’re adapters, but instead that they solve your problem. Admittedly at times it’s useful to know that you can choose an alternate implementation or build an adapter from an existing container object, but that’s generally one level removed from the adapter’s behavior. So, while you may see it emphasized elsewhere that a particular container is an adapter, we’ll only point out that fact when it’s useful. Note that each type of adapter has a default container that it’s built upon, and this default is the most sensible implementation. In most cases you won’t need to concern yourself with the underlying implementation.
   The following example showsstack&lt;string&gt; implemented in the three ways: the default (which usesdeque), with avector, and with alist:
   //: C07:Stack1.cpp
   // Demonstrates the STL stack
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;stack&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   using namespace std;

   // Rearrange comments below to use different versions.
   typedef stack&lt;string&gt; Stack1; // Default: deque&lt;string&gt;
   // typedef stack&lt;string, vector&lt;string&gt;&gt; Stack2;
   // typedef stack&lt;string, list&lt;string&gt;&gt; Stack3;

   int main() {
     ifstream in("Stack1.cpp");
     Stack1 textlines; // Try the different versions
     // Read file and store lines in the stack:
     string line;
     while(getline(in, line))
       textlines.push(line + "\n");
     // Print lines from the stack and pop them:
     while(!textlines.empty()) {
       cout&lt;&lt; textlines.top();
       textlines.pop();
     }
   } ///:~

   Thetop( ) andpop( ) operations will probably seem non-intuitive if you’ve used otherstack classes. When you callpop( ), it returns void rather than the top element that you might have expected. If you want the top element, you get a reference to it withtop( ). It turns out this is more efficient, since a traditionalpop( ) would have to return a value rather than a reference and thus invoke the copy-constructor. More important, it isexception safe, as we discussed in Chapter 1. Ifpop( ) both changed the state of the stack and attempted to return the top element, an exception in the element’s copy-constructor could cause the element to be lost. When you’re using astack (or apriority_queue, described later), you can efficiently refer totop( ) as many times as you want and then discard the top element explicitly usingpop( ). (Perhaps if some term other than the familiar "pop" had been used, this would have been a bit clearer.)
   Thestack template has a simple interface—essentially the member functions you saw earlier. Since it only makes sense to access a stack at its top, no iterators are available for traversing it. Nor are there sophisticated forms of initialization, but if you need that, you can use the underlying container upon which thestack is implemented. For example, suppose you have a function that expects astack interface, but in the rest of your program you need the objects stored in alist. The following program stores each line of a file along with the leading number of spaces in that line. (You might imagine it as a starting point for performing some kind of source-code reformatting.)
   //: C07:Stack2.cpp
   // Converting a list to a stack
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;stack&gt;
   #include&lt;list&gt;
   #include&lt;string&gt;
   using namespace std;

   // Expects a stack:
   template&lt;class Stk&gt;
   void stackOut(Stk& s, ostream& os = cout) {
     while(!s.empty()) {
       os&lt;&lt; s.top()&lt;&lt; "\n";
       s.pop();
     }
   }

   class Line {
     string line; // Without leading spaces
     int lspaces; // Number of leading spaces
   public:
     Line(string s) : line(s) {
       lspaces = line.find_first_not_of(' ');
       if(lspaces == string::npos)
         lspaces = 0;
       line = line.substr(lspaces);
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Line& l) {
       for(int i = 0; i&lt; l.lspaces; i++)
         os&lt;&lt; ' ';
       return os&lt;&lt; l.line;
     }
     // Other functions here...
   };

   int main() {
     ifstream in("Stack2.cpp");
     list&lt;Line&gt; lines;
     // Read file and store lines in the list:
     string s;
     while(getline(in, s))
       lines.push_front(s);
     // Turn the list into a stack for printing:
     stack&lt;Line, list&lt;Line&gt;&gt; stk(lines);
     stackOut(stk);
   } ///:~

   The function that requires thestack interface just sends eachtop( ) object to anostream and then removes it by callingpop( ). TheLine class determines the number of leading spaces and then stores the contents of the linewithout the leading spaces. Theostream operator&lt;&lt; re-inserts the leading spaces so the line prints properly, but you can easily change the number of spaces by changing the value oflspaces. (The member functions to do this are not shown here.)
   Inmain( ), the input file is read into alist&lt;Line&gt;, and then each line in the list is copied into astack that is sent tostackOut( ).
   You cannot iterate through astack; this emphasizes that you only want to performstack operations when you create astack. You can get equivalent "stack" functionality using avector and itsback( ),push_back( ), andpop_back( ) member functions, and then you have all the additional functionality of thevector.Stack1.cpp can be rewritten to show this:
   //: C07:Stack3.cpp
   // Using a vector as a stack; modified Stack1.cpp
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   using namespace std;

   int main() {
     ifstream in("Stack3.cpp");
     vector&lt;string&gt; textlines;
     string line;
     while(getline(in, line))
       textlines.push_back(line + "\n");
     while(!textlines.empty()) {
       cout&lt;&lt; textlines.back();
       textlines.pop_back();
     }
   } ///:~

   This produces the same output asStack1.cpp, but you can now performvector operations as well. Of course,list can also push things at the front, but it’s generally less efficient than usingpush_back( ) withvector. (In addition,deque is usually more efficient thanlist for pushing things at the front.)
   queue
   Thequeue is a restricted form of adeque—you can only enter elements at one end and pull them off the other end. Functionally, you could use adeque anywhere you need aqueue, and you would then also have the additional functionality of thedeque. The only reason you need to use aqueue rather than adeque, then, is if you want to emphasize that you will only be performing queue-like behavior.
   Thequeue is an adapter class likestack, in that it is built on top of another sequence container. As you might guess, the ideal implementation for aqueue is adeque, and that is the default template argument for thequeue; you’ll rarely need a different implementation.
   Queues are often used when modeling systems in which some elements of the system are waiting to be served by other elements in the system. A classic example of this is the "bank-teller problem": customers arrive at random intervals, get into a line, and then are served by a set of tellers. Since the customers arrive randomly and each takes a random amount of time to be served, there’s no way to deterministically know how long the line will be at any time. However, it’s possible to simulate the situation and see what happens.
   In a realistic simulation each customer and teller should be run by a separate thread. What we’d like is a multithreaded environment so that each customer or teller would have their own thread. However, Standard C++ has no model for multithreading, so there is no standard solution to this problem. On the other hand, with a little adjustment to the code, it’s possible to simulate enough multithreading to provide a satisfactory solution.[99] 
   In multithreading, multiple threads of control run simultaneously, sharing the same address space. Quite often you have fewer CPUs than you do threads (and often only one CPU). To give the illusion that each thread has its own CPU, atime-slicing mechanism says "OK, current thread, you’ve had enough time. I’m going to stop you and give time to some other thread." This automatic stopping and starting of threads is calledpreemptive,and it means you (the programmer) don’t need to manage the threading process at all.
   An alternative approach has each thread voluntarily yield the CPU to the scheduler, which then finds another thread that needs running. Instead, we’ll build the "time-slicing" into the classes in the system. In this case, it will be the tellers that represent the "threads," (the customers will be passive). Each teller will have an infinite-loopingrun( ) member function that will execute for a certain number of "time units" and then simply return. By using the ordinary return mechanism, we eliminate the need for any swapping. The resulting program, although small, provides a remarkably reasonable simulation:
   //: C07:BankTeller.cpp
   // Using a queue and simulated multithreading
   // To model a bank teller system
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;list&gt;
   #include&lt;queue&gt;
   using namespace std;

   class Customer {
     int serviceTime;
   public:
     Customer() : serviceTime(0) {}
     Customer(int tm) : serviceTime(tm) {}
     int getTime() { return serviceTime; }
     void setTime(int newtime) {
       serviceTime = newtime;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Customer& c) {
       return os&lt;&lt; '['&lt;&lt; c.serviceTime&lt;&lt; ']';
     }
   };

   class Teller {
     queue&lt;Customer&gt;& customers;
     Customer current;
     enum { slice = 5 };
     int ttime; // Time left in slice
     bool busy; // Is teller serving a customer?
   public:
     Teller(queue&lt;Customer&gt;& cq)
       : customers(cq), ttime(0), busy(false) {}
     Teller& operator=(const Teller& rv) {
       customers = rv.customers;
       current = rv.current;
       ttime = rv.ttime;
       busy = rv.busy;
       return *this;
     }
     bool isBusy() { return busy; }
     void run(bool recursion = false) {
       if(!recursion)
         ttime = slice;
       int servtime = current.getTime();
       if(servtime&gt; ttime) {
         servtime -= ttime;
         current.setTime(servtime);
         busy = true; // Still working on current
         return;
       }
       if(servtime&lt; ttime) {
         ttime -= servtime;
         if(!customers.empty()) {
           current = customers.front();
           customers.pop(); // Remove it
           busy = true;
           run(true); // Recurse
         }
         return;
       }
       if(servtime == ttime) {
         // Done with current, set to empty:
         current = Customer(0);
         busy = false;
         return; // No more time in this slice
       }
     }
   };

   // Inherit to access protected implementation:
   class CustomerQ : public queue&lt;Customer&gt; {
   public:
     friend ostream&
     operator&lt;&lt;(ostream& os, const CustomerQ& cd) {
       copy(cd.c.begin(), cd.c.end(),
         ostream_iterator&lt;Customer&gt;(os, ""));
       return os;
     }
   };

   int main() {
     CustomerQ customers;
     list&lt;Teller&gt; tellers;
     typedef list&lt;Teller&gt;::iterator TellIt;
     tellers.push_back(Teller(customers));
     srand(time(0)); // Seed random number generator
     clock_t ticks = clock();
     // Run simulation for at least 5 seconds:
     while(clock()&lt; ticks + 5 * CLOCKS_PER_SEC) {
       // Add a random number of customers to the
       // queue, with random service times:
       for(int i = 0; i&lt; rand() % 5; i++)
         customers.push(Customer(rand() % 15 + 1));
       cout&lt;&lt; '{'&lt;&lt; tellers.size()&lt;&lt; '}'
        &lt;&lt; customers&lt;&lt; endl;
       // Have the tellers service the queue:
       for(TellIt i = tellers.begin();
         i != tellers.end(); i++)
         (*i).run();
       cout&lt;&lt; '{'&lt;&lt; tellers.size()&lt;&lt; '}'
        &lt;&lt; customers&lt;&lt; endl;
       // If line is too long, add another teller:
       if(customers.size() / tellers.size()&gt; 2)
         tellers.push_back(Teller(customers));
       // If line is short enough, remove a teller:
       if(tellers.size()&gt; 1&&
         customers.size() / tellers.size()&lt; 2)
         for(TellIt i = tellers.begin();
           i != tellers.end(); i++)
           if(!(*i).isBusy()) {
             tellers.erase(i);
             break; // Out of for loop
           }
     }
   } ///:~

   Each customer requires a certain amount of service time, which is the number of time units that a teller must spend on the customer to serve that customer’s needs. Of course, the amount of service time will be different for each customer and will be determined randomly. In addition, you won’t know how many customers will be arriving in each interval, so this will also be determined randomly.
   TheCustomerobjects are kept in aqueue&lt;Customer&gt;, and eachTeller object keeps a reference to that queue. When aTeller object is finished with its currentCustomer object, thatTeller will get anotherCustomer from the queue and begin working on the newCustomer, reducing theCustomer’s service time during each time slice that theTeller is allotted. All this logic is in therun( ) member function, which is basically a three-wayif statement based on whether the amount of time necessary to serve the customer is less than, greater than, or equal to the amount of time left in the teller’s current time slice. Notice that if theTeller has more time after finishing with aCustomer, it gets a new customer and recurses into itself.
   Just as with astack, when you use aqueue, it’s only aqueue and doesn’t have any of the other functionality of the basic sequence containers. This includes the ability to get an iterator in order to step through thestack. However, the underlying sequence container (that thequeue is built upon) is held as aprotected member inside thequeue, and the identifier for this member is specified in the C++ Standard as‘c’, which means that you can derive fromqueue to access the underlying implementation. TheCustomerQ class does exactly that, for the sole purpose of defining anostream operator&lt;&lt; that can iterate through thequeue and print out its members.
   The driver for the simulation is thewhile loop inmain( ), which uses processor ticks (defined in&lt;ctime&gt;) to determine if the simulation has run for at least 5 seconds. At the beginning of each pass through the loop, a random number of customers is added, with random service times. Both the number of tellers and the queue contents are displayed so you can see the state of the system. After running each teller, the display is repeated. At this point, the system adapts by comparing the number of customers and the number of tellers; if the line is too long, another teller is added, and if it is short enough, a teller can be removed. In this adaptation section of the program you can experiment with policies regarding the optimal addition and removal of tellers. If this is the only section that you’re modifying, you might want to encapsulate policies inside different objects. We’ll revisit this problem with a multithreaded solution in Chapter 10.
   Priority queues
   When youpush( ) an object onto apriority_queue, that object is sorted into the queue according to a function or function object. (You can allow the defaultless template to supply this, or you can provide one of your own.) Thepriority_queue ensures that when you look at thetop( ) element, it will be the one with the highest priority. When you’re done with it, you callpop( ) to remove it and bring the next one into place. Thus, thepriority_queue has nearly the same interface as astack, but it behaves differently.
   Likestack andqueue,priority_queue is an adapter that is built on top of one of the basic sequences—the default isvector.
   It’s trivial to make apriority_queue that works withints:
   //: C07:PriorityQueue1.cpp
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;queue&gt;
   using namespace std;

   int main() {
     priority_queue&lt;int&gt; pqi;
     srand(time(0)); // Seed random number generator
     for(int i = 0; i&lt; 100; i++)
       pqi.push(rand() % 25);
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   This pushes into thepriority_queue100 random values from 0 to 24. When you run this program you’ll see that duplicates are allowed, and the highest values appear first. To show how you can change the ordering by providing your own function or function object, the following program gives lower-valued numbers the highest priority:
   //: C07:PriorityQueue2.cpp
   // Changing the priority
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;
   #include&lt;queue&gt;
   using namespace std;
   int main() {
     priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pqi;
     srand(time(0));
     for(int i = 0; i&lt; 100; i++)
       pqi.push(rand() % 25);
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   A more interesting problem is a to-do list, in which each object contains astring and a primary and secondary priority value:
   //: C07:PriorityQueue3.cpp
   // A more complex use of priority_queue
   #include&lt;iostream&gt;
   #include&lt;queue&gt;
   #include&lt;string&gt;
   using namespace std;

   class ToDoItem {
     char primary;
     int secondary;
     string item;
   public:
     ToDoItem(string td, char pri ='A', int sec =1)
       : item(td), primary(pri), secondary(sec) {}
     friend bool operator&lt;(
       const ToDoItem& x, const ToDoItem& y) {
       if(x.primary&gt; y.primary)
         return true;
       if(x.primary == y.primary)
         if(x.secondary&gt; y.secondary)
           return true;
       return false;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const ToDoItem& td) {
       return os&lt;&lt; td.primary&lt;&lt; td.secondary
        &lt;&lt; ": "&lt;&lt; td.item;
     }
   };

   int main() {
     priority_queue&lt;ToDoItem&gt; toDoList;
     toDoList.push(ToDoItem("Empty trash", 'C', 4));
     toDoList.push(ToDoItem("Feed dog", 'A', 2));
     toDoList.push(ToDoItem("Feed bird", 'B', 7));
     toDoList.push(ToDoItem("Mow lawn", 'C', 3));
     toDoList.push(ToDoItem("Water lawn", 'A', 1));
     toDoList.push(ToDoItem("Feed cat", 'B', 1));
     while(!toDoList.empty()) {
       cout&lt;&lt; toDoList.top()&lt;&lt; endl;
       toDoList.pop();
     }
   } ///:~

   TheToDoItem’soperator&lt; must be a nonmember function for it to work withless&lt;&gt;. Other than that, everything happens automatically. The output is:
   A1: Water lawn
   A2: Feed dog
   B1: Feed cat
   B7: Feed bird
   C3: Mow lawn
   C4: Empty trash

   You cannot iterate through apriority_queue, but it’s possible to simulate the behavior of apriority_queue using avector, thus allowing you access to thatvector. You can do this by looking at the implementation ofpriority_queue, which usesmake_heap( ),push_heap( ), andpop_heap( ). (They are the soul of thepriority_queue; in fact you could say that the heapis the priority queue and thatpriority_queueis just a wrapper around it.) This turns out to be reasonably straightforward, but you might think that a shortcut is possible. Since the container used bypriority_queue isprotected (and has the identifier, according to the Standard C++ specification, namedc), you can inherit a new class that provides access to the underlying implementation:
   //: C07:PriorityQueue4.cpp
   // Manipulating the underlying implementation
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;queue&gt;
   using namespace std;

   class PQI : public priority_queue&lt;int&gt; {
   public:
     vector&lt;int&gt;& impl() { return c; }
   };

   int main() {
     PQI pqi;
     srand(time(0));
     for(int i = 0; i&lt; 100; i++)
       pqi.push(rand() % 25);
     copy(pqi.impl().begin(), pqi.impl().end(),
       ostream_iterator&lt;int&gt;(cout, " "));
     cout&lt;&lt; endl;
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   However, if you run this program, you’ll discover that thevector doesn’t contain the items in the descending order that you get when you callpop( ), the order that you want from the priority queue. It would seem that if you want to create avector that is a priority queue, you have to do it by hand, like this:
   //: C07:PriorityQueue5.cpp
   // Building your own priority queue
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;queue&gt;
   using namespace std;

   template&lt;class T, class Compare&gt;
   class PQV : public vector&lt;T&gt; {
     Compare comp;
   public:
     PQV(Compare cmp = Compare()) : comp(cmp) {
       make_heap(begin(), end(), comp);
     }
     const T& top() { return front(); }
     void push(const T& x) {
       push_back(x);
       push_heap(begin(), end(), comp);
     }
     void pop() {
       pop_heap(begin(), end(), comp);
       pop_back();
     }
   };

   int main() {
     PQV&lt;int, less&lt;int&gt;&gt; pqi;
     srand(time(0));
     for(int i = 0; i&lt; 100; i++)
       pqi.push(rand() % 25);
     copy(pqi.begin(), pqi.end(),
       ostream_iterator&lt;int&gt;(cout, " "));
     cout&lt;&lt; endl;
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   But this program behaves in the same way as the previous one! What you are seeing in the underlyingvector is called aheap. This heap data structure represents the tree of the priority queue (stored in the linear structure of thevector), but when you iterate through it, you do not get a linear priority-queue order. You might think that you can simply callsort_heap( ), but that only works once, and then you don’t have a heap anymore, but instead a sorted list. This means that to go back to using it as a heap, the user must remember to callmake_heap( )first. This can be encapsulated into your custom priority queue:
   //: C07:PriorityQueue6.cpp
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;queue&gt;
   using namespace std;

   template&lt;class T, class Compare&gt;
   class PQV : public vector&lt;T&gt; {
     Compare comp;
     bool sorted;
     void assureHeap() {
       if(sorted) {
         // Turn it back into a heap:
         make_heap(begin(), end(), comp);
         sorted = false;
       }
     }
   public:
     PQV(Compare cmp = Compare()) : comp(cmp) {
       make_heap(begin(), end(), comp);
       sorted = false;
     }
     const T& top() {
       assureHeap();
       return front();
     }
     void push(const T& x) {
       assureHeap();
       // Put it at the end:
       push_back(x);
       // Re-adjust the heap:
       push_heap(begin(), end(), comp);
     }
     void pop() {
       assureHeap();
       // Move the top element to the last position:
       pop_heap(begin(), end(), comp);
       // Remove that element:
       pop_back();
     }
     void sort() {
       if(!sorted) {
         sort_heap(begin(), end(), comp);
         reverse(begin(), end());
         sorted = true;
       }
     }
   };

   int main() {
     PQV&lt;int, less&lt;int&gt;&gt; pqi;
     srand(time(0));
     for(int i = 0; i&lt; 100; i++) {
       pqi.push(rand() % 25);
       copy(pqi.begin(), pqi.end(),
         ostream_iterator&lt;int&gt;(cout, " "));
       cout&lt;&lt; "\n-----\n";
     }
     pqi.sort();
     copy(pqi.begin(), pqi.end(),
       ostream_iterator&lt;int&gt;(cout, " "));
     cout&lt;&lt; "\n-----\n";
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   Ifsorted is true, thevector is not organized as a heap, but instead as a sorted sequence. TheassureHeap( ) function guarantees that it’s put back into heap form before performing any heap operations on it.
   The firstfor loop inmain( ) now has the additional quality that it displays the heap as it’s being built.
   The only drawback to this solution is that the user must remember to callsort( )before viewing it as a sorted sequence (although one could conceivably override all the member functions that produce iterators so that they guarantee sorting). Another solution is to build a priority queue that is not avector, but will build you avector whenever you want one:
   //: C07:PriorityQueue7.cpp
   // A priority queue that will hand you a vector
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;queue&gt;
   using namespace std;

   template&lt;class T, class Compare&gt;
   class PQV {
     vector&lt;T&gt; v;
     Compare comp;
   public:
     // Don't need to call make_heap(); it's empty:
     PQV(Compare cmp = Compare()) : comp(cmp) {}
     void push(const T& x) {
       // Put it at the end:
       v.push_back(x);
       // Re-adjust the heap:
       push_heap(v.begin(), v.end(), comp);
     }
     void pop() {
       // Move the top element to the last position:
       pop_heap(v.begin(), v.end(), comp);
       // Remove that element:
       v.pop_back();
     }
     const T& top() { return v.front(); }
     bool empty() const { return v.empty(); }
     int size() const { return v.size(); }
     typedef vector&lt;T&gt; TVec;
     TVec vector() {
       TVec r(v.begin(), v.end());
       // It’s already a heap
       sort_heap(r.begin(), r.end(), comp);
       // Put it into priority-queue order:
       reverse(r.begin(), r.end());
       return r;
     }
   };

   int main() {
     PQV&lt;int, less&lt;int&gt;&gt; pqi;
     srand(time(0));
     for(int i = 0; i&lt; 100; i++)
       pqi.push(rand() % 25);
     const vector&lt;int&gt;& v = pqi.vector();
     copy(v.begin(), v.end(),
       ostream_iterator&lt;int&gt;(cout, " "));
     cout&lt;&lt; "\n-----------\n";
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   ThePQV class template follows the same form as the STL’spriority_queue, but has the additional membervector( ), which creates a newvector that’s a copy of the one inPQV(which means that it’s already a heap). It then sorts that copy (leavingPQV’svector untouched), and reverses the order so that traversing the newvector produces the same effect as popping the elements from the priority queue.
   You may observe that the approach of deriving frompriority_queue used inPriorityQueue4.cpp could be used with the above technique to produce more succinct code:
   //: C07:PriorityQueue8.cpp
   // A more compact version of PriorityQueue7.cpp
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;queue&gt;
   using namespace std;

   template&lt;class T&gt;
   class PQV : public priority_queue&lt;T&gt; {
   public:
     typedef vector&lt;T&gt; TVec;
     TVec vector() {
       TVec r(c.begin(), c.end());
       // c is already a heap
       sort_heap(r.begin(), r.end(), comp);
       // Put it into priority-queue order:
       reverse(r.begin(), r.end());
       return r;
     }
   };

   int main() {
     PQV&lt;int&gt; pqi;
     srand(time(0));
     for(int i = 0; i&lt; 100; i++)
       pqi.push(rand() % 25);
     const vector&lt;int&gt;& v = pqi.vector();
     copy(v.begin(), v.end(),
       ostream_iterator&lt;int&gt;(cout, " "));
     cout&lt;&lt; "\n-----------\n";
     while(!pqi.empty()) {
       cout&lt;&lt; pqi.top()&lt;&lt; ' ';
       pqi.pop();
     }
   } ///:~

   The brevity of this solution makes it the simplest and most desirable, plus it’s guaranteed that the user will not have avector in the unsorted state. The only potential problem is that thevector( ) member function returns thevector&lt;T&gt; by value, which might cause some overhead issues with complex values of the parameter typeT.
   Holding bits
   Because C was a language that purported to be "close to the hardware," many have found it dismaying that there was no native binary representation for numbers. Decimal, of course, and hexadecimal (tolerable only because it’s easier to group the bits in your mind), but octal? Ugh. Whenever you read specs for chips you’re trying to program, they don’t describe the chip registers in octal or even hexadecimal—they use binary. And yet C won’t let you say0b0101101, which is the obvious solution for a language close to the hardware.
   Although there’s still no native binary representation in C++, things have improved with the addition of two classes:bitset andvector&lt;bool&gt;, both of which are designed to manipulate a group of on-off values.[100] The primary differences between these types are:
   1.Eachbitset holds a fixed number of bits. You establish the quantity of bits in thebitset template argument. Thevector&lt;bool&gt; can, like a regularvector, expand dynamically to hold any number ofbool values.
   2.Thebitset template is explicitly designed for performance when manipulating bits, and is not a "regular" STL container. As such, it has no iterators. The number of bits, being a template parameter, is known at compile time and allows the underlying integral array to be stored on the runtime stack. Thevector&lt;bool&gt; container, on the other hand, is a specialization of avector and so has all the operations of a normalvector—the specialization is just designed to be space efficient forbool.
   There is no trivial conversion between abitset and avector&lt;bool&gt;, which implies that the two are for very different purposes. Furthermore, neither is a traditional "STL container." Thebitset template class has an interface for bit-level operations and in no way resembles the STL containers we’ve discussed up to this point. Thevector&lt;bool&gt; specialization ofvector is similar to an STL-like container, but it differs as discussed below.
   bitset&lt;n&gt;
   The template forbitset accepts an unsigned integral template argument that is the number of bits to represent. Thus,bitset&lt;10&gt; is a different type thanbitset&lt;20&gt;, and you cannot perform comparisons, assignments, and so on between the two.
   Abitset provides the most commonly used bitwise operations in an efficient form. However, eachbitset is implemented by logically packing bits in an array of integral types (typicallyunsigned longs, which contain at least 32 bits). In addition, the only conversion from abitset to a numerical value is to anunsigned long (via the functionto_ulong( )).
   The following example tests almost all the functionality of thebitset (the missing operations are redundant or trivial). You’ll see the description of each of the bitset outputs to the right of the output so that the bits all line up, and you can compare them to the source values. If you still don’t understand bitwise operations, running this program should help.
   //: C07:BitSet.cpp
   //{-bor}
   // Exercising the bitset class
   #include&lt;bitset&gt;
   #include&lt;climits&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;
   const int sz = 32;
   typedef bitset&lt;sz&gt; BS;

   template&lt;int bits&gt;
   bitset&lt;bits&gt; randBitset() {
     bitset&lt;bits&gt; r(rand());
     for(int i = 0; i&lt; bits/16 - 1; i++) {
       r&lt;&lt;= 16;
       // "OR" together with a new lower 16 bits:
       r |= bitset&lt;bits&gt;(rand());
     }
     return r;
   }

   int main() {
     srand(time(0));
     cout&lt;&lt; "sizeof(bitset&lt;16&gt;) = "
      &lt;&lt; sizeof(bitset&lt;16&gt;)&lt;&lt; endl;
     cout&lt;&lt; "sizeof(bitset&lt;32&gt;) = "
      &lt;&lt; sizeof(bitset&lt;32&gt;)&lt;&lt; endl;
     cout&lt;&lt; "sizeof(bitset&lt;48&gt;) = "
      &lt;&lt; sizeof(bitset&lt;48&gt;)&lt;&lt; endl;
     cout&lt;&lt; "sizeof(bitset&lt;64&gt;) = "
      &lt;&lt; sizeof(bitset&lt;64&gt;)&lt;&lt; endl;
     cout&lt;&lt; "sizeof(bitset&lt;65&gt;) = "
      &lt;&lt; sizeof(bitset&lt;65&gt;)&lt;&lt; endl;
     BS a(randBitset&lt;sz&gt;()), b(randBitset&lt;sz&gt;());
     // Converting from a bitset:
     unsigned long ul = a.to_ulong();
     cout&lt;&lt; a&lt;&lt; endl;
     // Converting a string to a bitset:
     string cbits("111011010110111");
     cout&lt;&lt; "as a string = "&lt;&lt; cbits&lt;&lt;endl;
     cout&lt;&lt; BS(cbits)&lt;&lt; " [BS(cbits)]"&lt;&lt; endl;
     cout&lt;&lt; BS(cbits, 2)
      &lt;&lt; " [BS(cbits, 2)]"&lt;&lt; endl;
     cout&lt;&lt; BS(cbits, 2, 11)
      &lt;&lt; " [BS(cbits, 2, 11)]"&lt;&lt; endl;
     cout&lt;&lt; a&lt;&lt; " [a]"&lt;&lt; endl;
     cout&lt;&lt; b&lt;&lt; " [b]"&lt;&lt; endl;
     // Bitwise AND:
     cout&lt;&lt; (a& b)&lt;&lt; " [a& b]"&lt;&lt; endl;
     cout&lt;&lt; (BS(a)&= b)&lt;&lt; " [a&= b]"&lt;&lt; endl;
     // Bitwise OR:
     cout&lt;&lt; (a | b)&lt;&lt; " [a | b]"&lt;&lt; endl;
     cout&lt;&lt; (BS(a) |= b)&lt;&lt; " [a |= b]"&lt;&lt; endl;
     // Exclusive OR:
     cout&lt;&lt; (a ^ b)&lt;&lt; " [a ^ b]"&lt;&lt; endl;
     cout&lt;&lt; (BS(a) ^= b)&lt;&lt; " [a ^= b]"&lt;&lt; endl;
     cout&lt;&lt; a&lt;&lt; " [a]"&lt;&lt; endl; // For reference
     // Logical left shift (fill with zeros):
     cout&lt;&lt; (BS(a)&lt;&lt;= sz/2)
      &lt;&lt; " [a&lt;&lt;= (sz/2)]"&lt;&lt; endl;
     cout&lt;&lt; (a&lt;&lt; sz/2)&lt;&lt; endl;
     cout&lt;&lt; a&lt;&lt; " [a]"&lt;&lt; endl; // For reference
     // Logical right shift (fill with zeros):
     cout&lt;&lt; (BS(a)&gt;&gt;= sz/2)
      &lt;&lt; " [a&gt;&gt;= (sz/2)]"&lt;&lt; endl;
     cout&lt;&lt; (a&gt;&gt; sz/2)&lt;&lt; endl;
     cout&lt;&lt; a&lt;&lt; " [a]"&lt;&lt; endl; // For reference
     cout&lt;&lt; BS(a).set()&lt;&lt; " [a.set()]"&lt;&lt; endl;
     for(int i = 0; i&lt; sz; i++)
       if(!a.test(i)) {
         cout&lt;&lt; BS(a).set(i)
          &lt;&lt; " [a.set("&lt;&lt; i&lt;&lt;")]"&lt;&lt; endl;
         break; // Just do one example of this
       }
     cout&lt;&lt; BS(a).reset()&lt;&lt; " [a.reset()]"&lt;&lt; endl;
     for(int j = 0; j&lt; sz; j++)
       if(a.test(j)) {
         cout&lt;&lt; BS(a).reset(j)
          &lt;&lt; " [a.reset("&lt;&lt; j&lt;&lt;")]"&lt;&lt; endl;
         break; // Just do one example of this
       }
     cout&lt;&lt; BS(a).flip()&lt;&lt; " [a.flip()]"&lt;&lt; endl;
     cout&lt;&lt; ~a&lt;&lt; " [~a]"&lt;&lt; endl;
     cout&lt;&lt; a&lt;&lt; " [a]"&lt;&lt; endl; // For reference
     cout&lt;&lt; BS(a).flip(1)&lt;&lt; " [a.flip(1)]"&lt;&lt; endl;
     BS c;
     cout&lt;&lt; c&lt;&lt; " [c]"&lt;&lt; endl;
     cout&lt;&lt; "c.count() = "&lt;&lt; c.count()&lt;&lt; endl;
     cout&lt;&lt; "c.any() = "
      &lt;&lt; (c.any() ? "true" : "false")&lt;&lt; endl;
     cout&lt;&lt; "c.none() = "
      &lt;&lt; (c.none() ? "true" : "false")&lt;&lt; endl;
     c[1].flip(); c[2].flip();
     cout&lt;&lt; c&lt;&lt; " [c]"&lt;&lt; endl;
     cout&lt;&lt; "c.count() = "&lt;&lt; c.count()&lt;&lt; endl;
     cout&lt;&lt; "c.any() = "
      &lt;&lt; (c.any() ? "true" : "false")&lt;&lt; endl;
     cout&lt;&lt; "c.none() = "
      &lt;&lt; (c.none() ? "true" : "false")&lt;&lt; endl;
     // Array indexing operations:
     c.reset();
     for(int k = 0; k&lt; c.size(); k++)
       if(k % 2 == 0)
         c[k].flip();
     cout&lt;&lt; c&lt;&lt; " [c]"&lt;&lt; endl;
     c.reset();
     // Assignment to bool:
     for(int ii = 0; ii&lt; c.size(); ii++)
       c[ii] = (rand() % 100)&lt; 25;
     cout&lt;&lt; c&lt;&lt; " [c]"&lt;&lt; endl;
     // bool test:
     if(c[1])
       cout&lt;&lt; "c[1] == true";
     else
       cout&lt;&lt; "c[1] == false"&lt;&lt; endl;
   } ///:~

   To generate interesting randombitsets, therandBitset( ) function is created. This function demonstratesoperator&lt;&lt;= by shifting each 16 random bits to the left until thebitset (which is templatized in this function for size) is full. The generated number and each new 16 bits are combined using theoperator|=.
   The first thing demonstrated inmain( ) is the unit size of abitset. If it is less than 32 bits,sizeof produces 4 (4 bytes = 32 bits), which is the size of a singlelong on most implementations. If it’s between 32 and 64, it requires twolongs, greater than 64 requires 3longs, and so on. Thus, you make the best use of space if you use a bit quantity that fits in an integral number oflongs. However, notice there’s no extra overhead for the object—it’s as if you were hand-coding to use along.
   Although there are no other numerical conversions frombitset besidesto_ulong( ), there is astream inserterthat produces astring containing ones and zeros, and this can be as long as the actualbitset.
   There’s still no primitive format for binary values, but the next best thing is supported bybitset: astring of ones and zeros with the least-significant bit (lsb) on the right. The three constructors demonstrated show taking the entirestring, thestring starting at character 2, and the string from character 2 through 11. You can write to anostream from abitset usingoperator&lt;&lt;,and it comes out as ones and zeros. You can also read from anistream usingoperator&gt;&gt; (not shown here).
   You’ll notice thatbitset only has three nonmember operators:and (&),or (|), andexclusive-or (^). Each of these creates a newbitsetas its return value. All the member operators opt for the more efficient&=,|=, and so on form in which a temporary is not created. However, these forms actually change thebitset’s value (which isa in most of the tests in the above example). To prevent this, we created a temporary to be used as the lvalue by invoking the copy-constructor ona; this is why you see the formBS(a). The result of each test is printed out, and occasionallya is reprinted so you can easily look at it for reference.
   The rest of the example should be self-explanatory when you run it; if not you can find the details in your compiler’s documentation or in the other documentation mentioned earlier in this chapter.
   vector&lt;bool&gt;
   Thevector&lt;bool&gt; container is a specialization of thevector template. A normalbool variable requires at least one byte, but since abool only has two states, the ideal implementation ofvector&lt;bool&gt; is such that eachbool value only requires one bit. This means the iterator must be specially defined and cannot be a pointer tobool.
   The bit-manipulation functions forvector&lt;bool&gt; are much more limited than those ofbitset. The only member function that was added to those already invector isflip( ), to invert all the bits; there is noset( ) orreset( ) as inbitset. When you useoperator[ ], you get back an object of typevector&lt;bool&gt;::reference, which also has aflip( ) to invert that individual bit.
   //: C07:VectorOfBool.cpp
   // Demonstrate the vector&lt;bool&gt; specialization
   #include&lt;bitset&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;sstream&gt;
   #include&lt;vector&gt;
   using namespace std;

   int main() {
     vector&lt;bool&gt; vb(10, true);
     vector&lt;bool&gt;::iterator it;
     for(it = vb.begin(); it != vb.end(); it++)
       cout&lt;&lt; *it;
     cout&lt;&lt; endl;
     vb.push_back(false);
     ostream_iterator&lt;bool&gt; out(cout, "");
     copy(vb.begin(), vb.end(), out);
     cout&lt;&lt; endl;
     bool ab[] = { true, false, false, true, true,
       true, true, false, false, true };
     // There's a similar constructor:
     vb.assign(ab, ab + sizeof(ab)/sizeof(bool));
     copy(vb.begin(), vb.end(), out);
     cout&lt;&lt; endl;
     vb.flip(); // Flip all bits
     copy(vb.begin(), vb.end(), out);
     cout&lt;&lt; endl;
     for(size_t i = 0; i&lt; vb.size(); i++)
       vb[i] = 0; // (Equivalent to "false")
     vb[4] = true;
     vb[5] = 1;
     vb[7].flip(); // Invert one bit
     copy(vb.begin(), vb.end(), out);
     cout&lt;&lt; endl;
     // Convert to a bitset:
     ostringstream os;
     copy(vb.begin(), vb.end(),
       ostream_iterator&lt;bool&gt;(os, ""));
     bitset&lt;10&gt; bs(os.str());
     cout&lt;&lt; "Bitset:\n"&lt;&lt; bs&lt;&lt; endl;
   } ///:~

   The last part of this example takes avector&lt;bool&gt; and converts it to abitset by first turning it into astring of ones and zeros. Of course, you must know the size of thebitset at compile time. You can see that this conversion is not the kind of operation you’ll want to do on a regular basis.
   Thevector&lt;bool&gt; specialization is a "crippled" STL container in the sense that certain guarantees that other containers provide are missing. For example, with the other containers the following relationships hold:
   // Let c be an STL container other than vector&lt;bool&gt;:
   T& r = c.front();
   T* p =&*c.begin();

   For all other containers, thefront( ) function yields an lvalue (something you can get a non-const reference to), andbegin( ) must yield something you can dereference and then take the address of. Neither is possible because bits are not addressable. Bothvector&lt;bool&gt; andbitset use a proxy class (reference, mentioned earlier) to read and set bits as necessary.
   Associative containers
   Theset,map,multiset, andmultimap are calledassociative containers because they associatekeys withvalues. Well, at leastmaps andmultimaps associate keys with values, but you can look at aset as amap that has no values, only keys (and they can in fact be implemented this way), and the same for the relationship betweenmultiset andmultimap. So, because of the structural similarity,sets andmultisets are lumped in with associative containers.
   The most important basic operations with associative containers are putting things in and, in the case of aset, seeing if something is in the set. In the case of amap, you want to first see if a key is in themap, and if it exists, you want the associated value for that key to be returned. Of course, there are many variations on this theme, but that’s the fundamental concept. The following example shows these basics:
   //: C07:AssociativeBasics.cpp
   //{-bor}
   // Basic operations with sets and maps
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;map&gt;
   #include&lt;set&gt;
   #include "Noisy.h"
   using namespace std;

   int main() {
     Noisy na[7];
     // Add elements via constructor:
     set&lt;Noisy&gt; ns(na, na + sizeof na/sizeof(Noisy));
     // Ordinary insertion:
     Noisy n;
     ns.insert(n);
     cout&lt;&lt; endl;
     // Check for set membership:
     cout&lt;&lt; "ns.count(n)= "&lt;&lt; ns.count(n)&lt;&lt; endl;
     if(ns.find(n) != ns.end())
       cout&lt;&lt; "n("&lt;&lt; n&lt;&lt; ") found in ns"&lt;&lt; endl;
     // Print elements:
     copy(ns.begin(), ns.end(),
       ostream_iterator&lt;Noisy&gt;(cout, " "));
     cout&lt;&lt; endl;
     cout&lt;&lt; "\n-----------\n";
     map&lt;int, Noisy&gt; nm;
     for(int i = 0; i&lt; 10; i++)
       nm[i]; // Automatically makes pairs
     cout&lt;&lt; "\n-----------\n";
     for(size_t j = 0; j&lt; nm.size(); j++)
       cout&lt;&lt; "nm["&lt;&lt; j&lt;&lt;"] = "&lt;&lt; nm[j]&lt;&lt; endl;
     cout&lt;&lt; "\n-----------\n";
     nm[10] = n;
     cout&lt;&lt; "\n-----------\n";
     nm.insert(make_pair(47, n));
     cout&lt;&lt; "\n-----------\n";
     cout&lt;&lt; "\n nm.count(10)= "
      &lt;&lt; nm.count(10)&lt;&lt; endl;
     cout&lt;&lt; "nm.count(11)= "
      &lt;&lt; nm.count(11)&lt;&lt; endl;
     map&lt;int, Noisy&gt;::iterator it = nm.find(6);
     if(it != nm.end())
       cout&lt;&lt; "value:"&lt;&lt; (*it).second
        &lt;&lt; " found in nm at location 6"&lt;&lt; endl;
     for(it = nm.begin(); it != nm.end(); it++)
       cout&lt;&lt; (*it).first&lt;&lt; ":"
        &lt;&lt; (*it).second&lt;&lt; ", ";
     cout&lt;&lt; "\n-----------\n";
   } ///:~

   Theset&lt;Noisy&gt; objectns is created using two iterators into an array ofNoisy objects, but there is also a default constructor and a copy-constructor, and you can pass in an object that provides an alternate scheme for doing comparisons. Bothsets andmaps have aninsert( ) member function to put things in, and you can check to see if an object is already in an associative container in a couple of ways. Thecount( )member function, when given a key, will tell you how many times that key occurs. (This can only be zero or one in aset ormap, but it can be more than one with amultiset ormultimap.) Thefind( ) member function will produce an iterator indicating the first occurrence (withset andmap, theonly occurrence) of the key that you give it or will produce the past-the-end iterator if it can’t find the key. Thecount( ) andfind( ) member functions exist for all the associative containers, which makes sense. The associative containers also have member functionslower_bound( ),upper_bound( ), andequal_range( ), which actually only make sense formultiset andmultimap, as you will see. (But don’t try to figure out how they would be useful forset andmap, since they are designed for dealing with a range of duplicate keys, which those containers don’t allow.)
   Designing anoperator[ ] always presents a bit of a dilemma. Because it’s intended to be treated as an array-indexing operation, people don’t tend to think about performing a test before they use it. But what happens if you decide to index out of the bounds of the array? One option, of course, is to throw an exception, but with amap "indexing out of the array" could mean that you want an entry there, and that’s the way the STLmap treats it. The firstfor loop after the creation of themap&lt;int, Noisy&gt; nm just "looks up" objects using theoperator[ ], but this is actually creating newNoisy objects! Themap creates a new key-value pair (using the default constructor for the value) if you look up a value withoperator[ ] and it isn’t there. This means that if you really just want to look something up and not create a new entry, you must use the member functionscount( ) (to see if it’s there) orfind( ) (to get an iterator to it).
   A number of problems are associated with thefor loop that prints the values of the container usingoperator[ ]. First, it requires integral keys (which we happen to have in this case). Next and worse, if all the keys are not sequential, you’ll end up counting from zero to the size of the container, and if some spots don’t have key-value pairs, you’ll automatically create them and miss some of the higher values of the keys. Finally, if you look at the output from thefor loop, you’ll see that things arevery busy, and it’s quite puzzling at first why there are so many constructions and destructions for what appears to be a simple lookup. The answer only becomes clear when you look at the code in themap template foroperator[ ], which will be something like this:
   mapped_type& operator[] (const key_type& k) {
     value_type tmp(k,T());
     return (*((insert(tmp)).first)).second;
   }

   Themap::insert( ) function takes a key-value pair and does nothing if there is already an entry in the map with the given key—otherwise it inserts an entry for the key. In either case, it returns a new key-value pair holding an iterator to the inserted pair as its first element and holding true as the second element if an insertion actually took place. The membersfirst andsecond give the key and value, respectively, becausemap::value_type is really just atypedef for astd::pair:
   typedef pair&lt;const Key, T&gt; value_type;

   We’ve seen thestd::pair template before, which just holds two values of independent types, as you can see by its definition:
   template&lt;class T1, class T2&gt;
   struct pair {
     typedef T1 first_type;
     typedef T2 second_type;
     T1 first;
     T2 second;
     pair();
     pair(const T1& x, const T2& y)
       : first(x), second(y) {}
     // Templatized copy-constructor:
     template&lt;class U, class V&gt;
      pair(const pair&lt;U, V&gt;&p);
   };

   Thepair template class is very useful, especially when you want to return two objects from a function (since areturn statement only takes one object). There’s even a shorthand for creating a pair calledmake_pair( ), which is used inAssociativeBasics.cpp.
   So to retrace the steps,map::value_type is apair of the key and the value of the map—actually, it’s a single entry for the map. But notice thatpair packages its objects by value, which means that copy-constructions are necessary to get the objects into thepair. Thus, the creation oftmp inmap::operator[ ] will involve at least a copy-constructor call and destructor call for each object in thepair. Here, we’re getting off easy because the key is anint. But if you want to really see what kind of activity can result frommap::operator[ ], try running this:
   //: C07:NoisyMap.cpp
   // Mapping Noisy to Noisy
   //{L} ../TestSuite/Test
   #include "Noisy.h"
   #include&lt;map&gt;
   using namespace std;

   int main() {
     map&lt;Noisy, Noisy&gt; mnn;
     Noisy n1, n2;
     cout&lt;&lt; "\n--------\n";
     mnn[n1] = n2;
     cout&lt;&lt; "\n--------\n";
     cout&lt;&lt; mnn[n1]&lt;&lt; endl;
     cout&lt;&lt; "\n--------\n";
   } ///:~

   You’ll see that both the insertion and lookup generate a lot of extra objects, and that’s because of the creation of thetmp object. If you look back up atmap::operator[ ], you’ll see that the second line callsinsert( ), passing ittmp—that is,operator[ ] does an insertion every time. The return value ofinsert( ) is a different kind ofpair, in whichfirst is an iterator pointing to the key-valuepair that was just inserted, andsecond is abool indicating whether the insertion took place. You can see thatoperator[ ] grabsfirst (the iterator), dereferences it to produce thepair, and then returns thesecond, which is the value at that location.
   So on the upside,map has this fancy "make a new entry if one isn’t there" behavior, but the downside is that youalways get a lot of extra object creations and destructions when you usemap::operator[ ]. Fortunately,AssociativeBasics.cpp also demonstrates how to reduce the overhead of insertions and deletions, by not usingoperator[ ] if you don’t have to. Theinsert( ) member function is slightly more efficient thanoperator[ ]. With aset, you hold only one object, but with amap, you hold key-value pairs; soinsert( ) requires apair as its argument. Here’s wheremake_pair( ) comes in handy, as you can see.
   For looking objects up in amap, you can usecount( ) to see whether a key is in the map, or you can usefind( ) to produce an iterator pointing directly at the key-value pair. Again, since themap containspairs, that’s what the iterator produces when you dereference it; so you have to selectfirst andsecond. When you runAssociativeBasics.cpp, you’ll notice that the iterator approach involves no extra object creations or destructions at all. It’s not as easy to write or read, though.
   Generators and fillers for associative containers
   You’ve seen how useful thefill( ),fill_n( ),generate( ), andgenerate_n( ) function templates in&lt;algorithm&gt; have been for filling the sequential containers (vector,list, anddeque) with data. However, these are implemented by usingoperator=to assign values into the sequential containers, and the way that you add objects to associative containers is with their respectiveinsert( ) member functions. Thus, the default "assignment" behavior causes a problem when trying to use the "fill" and "generate" functions with associative containers.
   One solution is to duplicate the "fill" and "generate" functions, creating new ones that can be used with associative containers. It turns out that only thefill_n( ) andgenerate_n( ) functions can be duplicated (fill( )andgenerate( )copy in between two iterators, which doesn’t make sense with associative containers), but the job is fairly easy, since you have the&lt;algorithm&gt; header file to work from (and since it contains templates, all the source code is there):
   //: C07:assocGen.h
   // The fill_n() and generate_n() equivalents
   // for associative containers.
   #ifndef ASSOCGEN_H
   #define ASSOCGEN_H

   template&lt;class Assoc, class Count, class T&gt;
   void
   assocFill_n(Assoc& a, Count n, const T& val) {
     while(n--&gt; 0)
       a.insert(val);
   }

   template&lt;class Assoc, class Count, class Gen&gt;
   void assocGen_n(Assoc& a, Count n, Gen g) {
     while(n--&gt; 0)
       a.insert(g());
   }
   #endif // ASSOCGEN_H ///:~

   You can see that instead of using iterators, the container class itself is passed (by reference, of course, since you wouldn’t want to make a local copy, fill it, and then have it discarded at the end of the scope).
   This code demonstrates two valuable lessons. The first is that if the algorithms don’t do what you want, copy the nearest thing and modify it. You have the example at hand in the STL header, so most of the work has already been done.
   The second lesson is more pointed: if you look long enough, there’s probably a way to do it in the STLwithout inventing anything new. The present problem can instead be solved by using aninsert_iterator (produced by a call toinserter( )), which callsinsert( ) to place items in the container instead ofoperator=. This isnot simply a variation offront_insert_iterator orback_insert_iterator, because those iterators usepush_front( ) andpush_back( ), respectively. Each of the insert iterators is different by virtue of the member function it uses for insertion, andinsert( ) is the one we need. Here’s a demonstration that shows filling and generating both amap and aset. (Of course, it can also be used withmultimap andmultiset.) First, some templatized, simple generators are created. (This may seem like overkill, but you never know when you’ll need them; for that reason they’re placed in a header file.)
   //: C07:SimpleGenerators.h
   // Generic generators, including
   // one that creates pairs
   #include&lt;iostream&gt;
   #include&lt;utility&gt;

   // A generator that increments its value:
   template&lt;typename T&gt;
   class IncrGen {
     T i;
   public:
     IncrGen(T ii) : i (ii) {}
     T operator()() { return i++; }
   };

   // A generator that produces an STL pair&lt;&gt;:
   template&lt;typename T1, typename T2&gt;
   class PairGen {
     T1 i;
     T2 j;
   public:
     PairGen(T1 ii, T2 jj) : i(ii), j(jj) {}
     std::pair&lt;T1,T2&gt; operator()() {
       return std::pair&lt;T1,T2&gt;(i++, j++);
     }
   };

   namespace std {
   // A generic global operator&lt;&lt;
   // for printing any STL pair&lt;&gt;:
   template&lt;typename F, typename S&gt; ostream&
   operator&lt;&lt;(ostream& os, const pair&lt;F,S&gt;& p) {
     return os&lt;&lt; p.first&lt;&lt; "\t"
      &lt;&lt; p.second&lt;&lt; endl;
   }} ///:~

   Both generators expect thatT can be incremented, and they simply useoperator++ to generate new values from whatever you used for initialization.PairGen creates an STLpair object as its return value, and that’s what can be placed into amap ormultimap usinginsert( ).
   The last function is a generalization ofoperator&lt;&lt; forostreams, so that anypair can be printed, assuming each element of thepairsupports a streamoperator&lt;&lt;. (It is in namespacestd for the strange name lookup reasons discussed in Chapter 5.) As you can see in the following, this allows the use ofcopy( ) to output themap:
   //: C07:AssocInserter.cpp
   // Using an insert_iterator so fill_n() and
   // generate_n() can be used with associative
   // containers
   #include "SimpleGenerators.h"
   #include&lt;iterator&gt;
   #include&lt;iostream&gt;
   #include&lt;algorithm&gt;
   #include&lt;set&gt;
   #include&lt;map&gt;
   using namespace std;

   int main() {
     set&lt;int&gt; s;
     fill_n(inserter(s, s.begin()), 10, 47);
     generate_n(inserter(s, s.begin()), 10,
       IncrGen&lt;int&gt;(12));
     copy(s.begin(), s.end(),
       ostream_iterator&lt;int&gt;(cout, "\n"));

     map&lt;int, int&gt; m;
     fill_n(inserter(m, m.begin()), 10,
       make_pair(90,120));
     generate_n(inserter(m, m.begin()), 10,
       PairGen&lt;int, int&gt;(3, 9));
     copy(m.begin(), m.end(),
       ostream_iterator&lt;pair&lt;int,int&gt;&gt;(cout,"\n"));
   } ///:~

   The second argument toinserter is an iterator, which is an optimization hint to help the insertion go faster (instead of always starting the search at the root of the underlying tree). Since aninsert_iterator can be used with many different types of containers, with non-associative containers it is more than a hint—it is required.
   Note how theostream_iterator is created to output apair; this wouldn’t have worked if theoperator&lt;&lt; hadn’t been created, and since it’s a template, it is automatically instantiated forpair&lt;int, int&gt;.
   The magic of maps
   An ordinary array uses an integral value to index into a sequential set of elements of some type. Amap is anassociative array, which means you associate one object with another in an array-like fashion, but instead of selecting an array element with a number as you do with an ordinary array, you look it up with an object! The example that follows counts the words in a text file, so the index is thestring object representing the word, and the value being looked up is the object that keeps count of the strings.
   In a single-item container such as avector or alist, only one thing is being held. But in amap, you’ve got two things: thekey (what you look up by, as inmapname[key]) and thevalue that results from the lookup with the key. If you simply want to move through the entiremap and list each key-value pair, you use an iterator, which when dereferenced produces apair object containing both the key and the value. You access the members of apair by selectingfirst orsecond.
   This same philosophy of packaging two items together is also used to insert elements into the map, but thepair is created as part of the instantiatedmap and is calledvalue_type, containing the key and the value. So one option for inserting a new element is to create avalue_type object, loading it with the appropriate objects and then calling theinsert( ) member function for themap. Instead, the following example uses the aforementioned special feature ofmap: if you’re trying to find an object by passing in a key tooperator[ ] and that object doesn’t exist,operator[ ] will automatically insert a new key-value pair for you, using the default constructor for the value object. With that in mind, consider an implementation of a word-counting program:
   //: C07:WordCount.cpp
   // Count occurrences of words using a map
   #include "../require.h"
   #include&lt;string&gt;
   #include&lt;map&gt;
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   using namespace std;

   typedef map&lt;string, int&gt; WordMap;
   typedef WordMap::iterator WMIter;

   int main(int argc, char* argv[]) {
     char* fname = "WordCount.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     WordMap wordmap;
     string word;
     while(in&gt;&gt; word)
       wordmap[word]++;
     for(WMIter w = wordmap.begin(); w != wordmap.end(); w++)
       cout&lt;&lt; w-&gt;first&lt;&lt; ": "
        &lt;&lt; w-&gt;second&lt;&lt; endl;
   } ///:~

   This example shows the power ofzero-initialization. Consider this line of code from the program above:.
   wordmap[word]++;

   This increments theint associated withword. If there isn’t such a word yet in the map, a key-value pair for the word is automatically inserted, with the value initialized to zero by a call to the pseudo-constructorint( ), which returns a 0.
   Printing the entire list requires traversing it with an iterator. (There’s nocopy( ) shortcut for amap unless you want to write anoperator&lt;&lt;for thepair in the map.) As previously mentioned, dereferencing this iterator produces apair object, with thefirst member the key and thesecond member the value.
   If you want to find the count for a particular word, you can use the array index operator, like this:
   cout&lt;&lt; "the: "&lt;&lt; wordmap["the"]&lt;&lt; endl;

   You can see that one of the great advantages of themap is the clarity of the syntax; an associative array makes intuitive sense to the reader. (Note, however, that if "the" isn’t already in thewordmap, a new entry will be created!)
   Multimaps and duplicate keys
   Amultimap is amap that can contain duplicate keys. At first this may seem like a strange idea, but it can occur surprisingly often. A phone book, for example, can have many entries with the same name.
   Suppose you are monitoring wildlife, and you want to keep track of where and when each type of animal is spotted. Thus, you may see many animals of the same kind, all in different locations and at different times. So if the type of animal is the key, you’ll need amultimap. Here’s what it looks like:
   //: C07:WildLifeMonitor.cpp
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;map&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   using namespace std;

   class DataPoint {
     int x, y; // Location coordinates
     time_t time; // Time of Sighting
   public:
     DataPoint() : x(0), y(0), time(0) {}
     DataPoint(int xx, int yy, time_t tm) :
       x(xx), y(yy), time(tm) {}
     // Synthesized operator=, copy-constructor OK
     int getX() const { return x; }
     int getY() const { return y; }
     const time_t* getTime() const { return&time; }
   };

   string animal[] = {
     "chipmunk", "beaver", "marmot", "weasel",
     "squirrel", "ptarmigan", "bear", "eagle",
     "hawk", "vole", "deer", "otter", "hummingbird",
   };
   const int asz = sizeof animal/sizeof *animal;
   vector&lt;string&gt; animals(animal, animal + asz);

   // All the information is contained in a
   // "Sighting," which can be sent to an ostream:
   typedef pair&lt;string, DataPoint&gt; Sighting;

   ostream&
   operator&lt;&lt;(ostream& os, const Sighting& s) {
     return os&lt;&lt; s.first&lt;&lt; " sighted at x= "&lt;&lt;
       s.second.getX()&lt;&lt; ", y= "&lt;&lt; s.second.getY()
      &lt;&lt; ", time = "&lt;&lt; ctime(s.second.getTime());
   }

   // A generator for Sightings:
   class SightingGen {
     vector&lt;string&gt;& animals;
     enum { d = 100 };
   public:
     SightingGen(vector&lt;string&gt;& an) :
       animals(an) { srand(time(0)); }
     Sighting operator()() {
       Sighting result;
       int select = rand() % animals.size();
       result.first = animals[select];
       result.second = DataPoint(
         rand() % d, rand() % d, time(0));
       return result;
     }
   };

   // Display a menu of animals, allow the user to
   // select one, return the index value:
   int menu() {
     cout&lt;&lt; "select an animal or 'q' to quit: ";
     for(int i = 0; i&lt; animals.size(); i++)
       cout&lt;&lt;'['&lt;&lt; i&lt;&lt;']'&lt;&lt; animals[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
     string reply;
     cin&gt;&gt; reply;
     if(reply.at(0) == 'q') return 0;
     istringstream r(reply);
     int i;
     r&gt;&gt; i; // Converts to int
     i %= animals.size();
     return i;
   }

   typedef multimap&lt;string, DataPoint&gt; DataMap;
   typedef DataMap::iterator DMIter;

   int main() {
     DataMap sightings;
     generate_n(
       inserter(sightings, sightings.begin()),
       50, SightingGen(animals));
     // Print everything:
     copy(sightings.begin(), sightings.end(),
       ostream_iterator&lt;Sighting&gt;(cout, ""));
     // Print sightings for selected animal:
     for(int count = 1; count&lt; 10; count++) {
       // Use menu to get selection:
       // int i = menu();
       // Generate randomly (for automated testing):
       int i = rand() % animals.size();
       // Iterators in "range" denote begin, one
       // past end of matching range:
       pair&lt;DMIter, DMIter&gt; range =
         sightings.equal_range(animals[i]);
       copy(range.first, range.second,
         ostream_iterator&lt;Sighting&gt;(cout, ""));
     }
   } ///:~

   All the data about a sighting is encapsulated into the classDataPoint, which is simple enough that it can rely on the synthesized assignment and copy-constructor. It uses the Standard C library time functions to record the time of the sighting.
   In the array ofstring animal, notice that thechar* constructor is automatically used during initialization, which makes initializing an array ofstring quite convenient. Since it’s easier to use the animal names in avector, the length of the array is calculated, and avector&lt;string&gt; is initialized using thevector(iterator, iterator) constructor.
   The key-value pairs that make up aSighting are thestring, which names the type of animal, and theDataPoint, which says where and when it was sighted. The standardpair template combines these two types and is typedefed to produce theSighting type. Then anostream operator&lt;&lt; is created forSighting; this will allow you to iterate through amap ormultimap ofSightings and print it out.
   SightingGen generates random sightings at random data points to use for testing. It has the usualoperator( ) necessary for a function object, but it also has a constructor to capture and store a reference to avector&lt;string&gt;, which is where the aforementioned animal names are stored.
   ADataMap is amultimap ofstring-DataPoint pairs, which means it storesSightings. It is filled with 50Sightings usinggenerate_n( ) and printed out. (Notice that because there is anoperator&lt;&lt; that takes aSighting, anostream_iterator can be created.) At this point the user is asked to select the animal for which they want to see all the sightings . If you pressq, the program will quit, but if you select an animal number, theequal_range( ) member function is invoked. This returns an iterator (DMIter) to the beginning of the set of matching pairs and an iterator indicating past-the-end of the set. Since only one object can be returned from a function,equal_range( ) makes use ofpair. Since therange pair has the beginning and ending iterators of the matching set, those iterators can be used incopy( ) to print out all the sightings for a particular type of animal.
   Multisets
   You’ve seen theset, which allows only one object of each value to be inserted. Themultiset is odd by comparison since it allows more than one object of each value to be inserted. This seems to go against the whole idea of "setness," in which you can ask, "Is‘it’ in this set?" If there can be more than one "it," what does that question mean?.
   With some thought, you can see that it makes little sense to have more than one object of the same value in a set if those duplicate objects areexactly the same (with the possible exception of counting occurrences of objects, but as seen earlier in this chapter that can be handled in an alternative, more elegant fashion). Thus, each duplicate object will have something that makes it "different" from the other duplicates—most likely different state information that is not used in the calculation of the key during the comparison. That is, to the comparison operation, the objects look the same, but they actually contain some differing internal state.
   Like any STL container that must order its elements, themultiset template uses theless template by default to determine element ordering. This uses the contained classes’operator&lt;, but you can of course substitute your own comparison function.
   Consider a simple class that contains one element that is used in the comparison and another that is not:
   //: C07:MultiSet1.cpp
   // Demonstration of multiset behavior
   #include&lt;algorithm&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;set&gt;
   using namespace std;

   class X {
     char c; // Used in comparison
     int i; // Not used in comparison
     // Don't need default constructor and operator=
     X();
     X& operator=(const X&);
     // Usually need a copy-constructor (but the
     // synthesized version works here)
   public:
     X(char cc, int ii) : c(cc), i(ii) {}
     // Notice no operator== is required
     friend bool operator&lt;(const X& x, const X& y) {
       return x.c&lt; y.c;
     }
     friend ostream& operator&lt;&lt;(ostream& os, X x) {
       return os&lt;&lt; x.c&lt;&lt; ":"&lt;&lt; x.i;
     }
   };

   class Xgen {
     static int i;
     // Number of characters to select from:
     enum { span = 6 };
   public:
     Xgen() { srand(time(0)); }
     X operator()() {
       char c = 'A' + rand() % span;
       return X(c, i++);
     }
   };

   int Xgen::i = 0;

   typedef multiset&lt;X&gt; Xmset;
   typedef Xmset::const_iterator Xmit;

   int main() {
     Xmset mset;
     // Fill it with X's:
     generate_n(inserter(mset, mset.begin()),
       25, Xgen());
     // Initialize a regular set from mset:
     set&lt;X&gt; unique(mset.begin(), mset.end());
     copy(unique.begin(), unique.end(),
       ostream_iterator&lt;X&gt;(cout, " "));
     cout&lt;&lt; "\n----\n";
     // Iterate over the unique values:
     for(set&lt;X&gt;::iterator i = unique.begin();
         i != unique.end(); i++) {
       pair&lt;Xmit, Xmit&gt; p = mset.equal_range(*i);
       copy(p.first, p.second,
         ostream_iterator&lt;X&gt;(cout, " "));
       cout&lt;&lt; endl;
     }
   } ///:~

   InX, all the comparisons are made with thechar c. The comparison is performed withoperator&lt;, which is all that is necessary for themultiset, since in this example the defaultless comparison object is used. The classXgen randomly generatesX objects, but the comparison value is restricted to the span from‘A’ to ‘E’. Inmain( ), amultiset&lt;X&gt; is created and filled with 25X objects usingXgen, guaranteeing that there will be duplicate keys. So that we know what the unique values are, a regularset&lt;X&gt; is created from themultiset (using theiterator, iterator constructor). These values are displayed, and then each one produces theequal_range( ) in themultiset (equal_range( ) has the same meaning here as it does withmultimap: all the elements with matching keys). Each set of matching keys is then printed.
   As a second example, a (possibly) more elegant version ofWordCount.cpp can be created usingmultiset:
   //: C07:MultiSetWordCount.cpp
   // Count occurrences of words using a multiset
   #include&lt;fstream&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;set&gt;
   #include&lt;string&gt;
   #include "../require.h"
   using namespace std;

   int main(int argc, char* argv[]) {
     char* fname = "MultiSetWordCount.cpp";
     if(argc&gt; 1) fname = argv[1];
     ifstream in(fname);
     assure(in, fname);
     multiset&lt;string&gt; wordmset;
     string word;
     while(in&gt;&gt; word)
       wordmset.insert(word);
     typedef multiset&lt;string&gt;::iterator MSit;
     MSit it = wordmset.begin();
     while(it != wordmset.end()) {
       pair&lt;MSit, MSit&gt; p = wordmset.equal_range(*it);
       int count = distance(p.first, p.second);
       cout&lt;&lt; *it&lt;&lt; ": "&lt;&lt; count&lt;&lt; endl;
       it = p.second; // Move to the next word
     }
   } ///:~

   The setup inmain( ) is identical toWordCount.cpp, but then each word is simply inserted into themultiset&lt;string&gt;. An iterator is created and initialized to the beginning of themultiset; dereferencing this iterator produces the current word. Theequal_range( ) member function (not generic algorithm) produces the starting and ending iterators of the word that’s currently selected, and the algorithmdistance( ) (defined in&lt;iterator&gt;) counts the number of elements in that range. The iteratoritis then moved forward to the end of the range, which puts it at the next word. If you’re unfamiliar with themultiset, this code can seem more complex. The density of it and the lack of need for supporting classes such asCount has a lot of appeal.
   In the end, is this really a "set," or should it be called something else? An alternative is the generic "bag" that is defined in some container libraries, since a bag holds anything at all without discrimination—including duplicate objects. This is close, but it doesn’t quite fit since a bag has no specification about how elements should be ordered. Amultiset (which requires that all duplicate elements be adjacent to each other) is even more restrictive than the concept of a set, which could use a hashing function to order its elements, in which case they would not be in sorted order. Besides, if you wanted to store a bunch of objects without any special criteria, you’d probably just use avector,deque, orlist.
   Combining STL containers
   When using a thesaurus, you want to know all the words that are similar to a particular word. When you look up a word, then, you want a list of words as the result. Here, the "multi" containers (multimap ormultiset) are not appropriate. The solution is to combine containers, which is easily done using the STL. Here, we need a tool that turns out to be a powerful general concept, which is amap ofvector:
   //: C07:Thesaurus.cpp
   // A map of vectors
   //{-msc}
   //{-g++}
   #include&lt;map&gt;
   #include&lt;vector&gt;
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;algorithm&gt;
   #include&lt;ctime&gt;
   #include&lt;cstdlib&gt;
   using namespace std;

   typedef map&lt;string, vector&lt;string&gt;&gt; Thesaurus;
   typedef pair&lt;string, vector&lt;string&gt;&gt; TEntry;
   typedef Thesaurus::iterator TIter;

   ostream& operator&lt;&lt;(ostream& os,const TEntry& t){
     os&lt;&lt; t.first&lt;&lt; ": ";
     copy(t.second.begin(), t.second.end(),
       ostream_iterator&lt;string&gt;(os, " "));
     return os;
   }

   // A generator for thesaurus test entries:
   class ThesaurusGen {
     static const string letters;
     static int count;
   public:
     int maxSize() { return letters.size(); }
     ThesaurusGen() { srand(time(0)); }
     TEntry operator()() {
       TEntry result;
       if(count&gt;= maxSize()) count = 0;
       result.first = letters[count++];
       int entries = (rand() % 5) + 2;
       for(int i = 0; i&lt; entries; i++) {
         int choice = rand() % maxSize();
         char cbuf[2] = { 0 };
         cbuf[0] = letters[choice];
         result.second.push_back(cbuf);
       }
       return result;
     }
   };

   int ThesaurusGen::count = 0;
   const string ThesaurusGen::letters("ABCDEFGHIJKL"
     "MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

   // Ask for a "word" to look up:
   string menu(Thesaurus& thesaurus) {
     while(true) {
       cout&lt;&lt; "Select a \"word\", 0 to quit: ";
       for(TIter it = thesaurus.begin();
         it != thesaurus.end(); it++)
         cout&lt;&lt; (*it).first&lt;&lt; ' ';
       cout&lt;&lt; endl;
       string reply;
       cin&gt;&gt; reply;
       if(reply.at(0) == '0') exit(0); // Quit
       if(thesaurus.find(reply) == thesaurus.end())
         continue; // Not in list, try again
       return reply;
     }
   }

   int main() {
     Thesaurus thesaurus;
     // Fill with 10 entries:
     generate_n(
       inserter(thesaurus, thesaurus.begin()),
       10, ThesaurusGen());
     // Print everything:
     copy(thesaurus.begin(), thesaurus.end(),
       ostream_iterator&lt;TEntry&gt;(cout, "\n"));
     // Create a list of the keys:
     string keys[10];
     int i = 0;
     for(TIter it = thesaurus.begin();
       it != thesaurus.end(); it++)
       keys[i++] = (*it).first;
     for(int count = 0; count&lt; 10; count++) {
       // Enter from the console:
       // string reply = menu(thesaurus);
       // Generate randomly
       string reply = keys[rand() % 10];
       vector&lt;string&gt;& v = thesaurus[reply];
       copy(v.begin(), v.end(),
         ostream_iterator&lt;string&gt;(cout, " "));
       cout&lt;&lt; endl;
     }
   } ///:~

   AThesaurus maps astring (the word) to avector&lt;string&gt; (the synonyms). ATEntryis a single entry in aThesaurus. By creating anostream operator&lt;&lt; for aTEntry, a single entry from theThesaurus can easily be printed (and the wholeThesaurus can easily be printed withcopy( )). TheThesaurusGen creates "words" (which are just single letters) and "synonyms" for those words (which are just other randomly chosen single letters) to be used as thesaurus entries. It randomly chooses the number of synonym entries to make, but there must be at least two. All the letters are chosen by indexing into astatic string that is part ofThesaurusGen.
   Inmain( ), aThesaurus is created, filled with 10 entries and printed using thecopy( ) algorithm. Themenu( ) function asks the user to choose a "word" to look up by typing the letter of that word. Thefind( ) member function discovers whether the entry exists in themap. (Remember, you don’t want to useoperator[ ], which will automatically make a new entry if it doesn’t find a match!) If so,operator[ ] fetches out thevector&lt;string&gt; that is displayed.
   In the previous code, the selection of thereply string is generated randomly, to allow automated testing.
   Because templates make the expression of powerful concepts easy, you can take this concept much further, creating amap ofvectors containingmaps, and so on. For that matter, you can combine any of the STL containers this way.
   Cleaning up containers of pointers
   InStlshape.cpp, the pointers did not clean themselves up automatically. It would be convenient to be able to do this easily, rather than writing out the code each time. Here is a function template that will clean up the pointers in any sequence container; note that it is placed in the book’s root directory for easy access:
   //: :purge.h
   // Delete pointers in an STL sequence container
   #ifndef PURGE_H
   #define PURGE_H
   #include&lt;algorithm&gt;

   template&lt;class Seq&gt; void purge(Seq& c) {
     typename Seq::iterator i;
     for(i = c.begin(); i != c.end(); ++i) {
       delete *i;
       *i = 0;
     }
   }

   // Iterator version:
   template&lt;class InpIt&gt;
   void purge(InpIt begin, InpIt end) {
     while(begin != end) {
       delete *begin;
       *begin = 0;
       begin++;
     }
   }
   #endif // PURGE_H ///:~

   In the first version ofpurge( ), note thattypename is absolutely necessary; indeed this is exactly the case that the keyword was added for:Seq is a template argument, anditerator is something that is nested within that template. So what doesSeq::iterator refer to? Thetypename keyword specifies that it refers to a type, and not something else.
   Although the container version ofpurge( ) must work with an STL-style container, the iterator version ofpurge( ) will work with any range, including an array.
   Here isStlshape.cpp, modified to use thepurge( ) function:
   //: C07:Stlshape2.cpp
   // Stlshape.cpp with the purge() function
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Shape {
   public:
     virtual void draw() = 0;
     virtual ~Shape() {};
   };

   class Circle : public Shape {
   public:
     void draw() { cout&lt;&lt; "Circle::draw\n"; }
     ~Circle() { cout&lt;&lt; "~Circle\n"; }
   };

   class Triangle : public Shape {
   public:
     void draw() { cout&lt;&lt; "Triangle::draw\n"; }
     ~Triangle() { cout&lt;&lt; "~Triangle\n"; }
   };

   class Square : public Shape {
   public:
     void draw() { cout&lt;&lt; "Square::draw\n"; }
     ~Square() { cout&lt;&lt; "~Square\n"; }
   };

   typedef std::vector&lt;Shape*&gt; Container;
   typedef Container::iterator Iter;

   int main() {
     Container shapes;
     shapes.push_back(new Circle);
     shapes.push_back(new Square);
     shapes.push_back(new Triangle);
     for(Iter i = shapes.begin();
         i != shapes.end(); i++)
       (*i)-&gt;draw();
     purge(shapes);
   } ///:~

   When usingpurge( ), carefully consider ownership issues. If an object pointer is held in more than one container, be sure not to delete it twice, and you don’t want to destroy the object in the first container before the second one is finished with it. Purging the same container twice is not a problem, becausepurge( ) sets the pointer to zero once it deletes that pointer, and callingdelete for a zero pointer is a safe operation.
   Creating your own containers
   With the STL as a foundation, you can create your own containers. Assuming you follow the same model of providing iterators, your new container will behave as if it were a built-in STL container.
   Consider the "ring" data structure, which is a circular sequence container. If you reach the end, it just wraps around to the beginning. This can be implemented on top of alist as follows:
   //: C07:Ring.cpp
   // Making a "ring" data structure from the STL
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;string&gt;
   using namespace std;

   template&lt;class T&gt;
   class Ring {
     list&lt;T&gt; lst;
   public:
     // Declaration necessary so the following
     // 'friend' statement sees this 'iterator'
     // instead of std::iterator:
     class iterator;
     friend class iterator;
     class iterator : public std::iterator&lt;
       std::bidirectional_iterator_tag,T,ptrdiff_t&gt;{
       typename list&lt;T&gt;::iterator it;
       list&lt;T&gt;* r;
     public:
       iterator(list&lt;T&gt;& lst,
         const typename list&lt;T&gt;::iterator& i)
         : r(&lst), it(i) {}
       bool operator==(const iterator& x) const {
         return it == x.it;
       }
       bool operator!=(const iterator& x) const {
         return !(*this == x);
       }
       typename list&lt;T&gt;::reference operator*() const {
         return *it;
       }
       iterator& operator++() {
         ++it;
         if(it == r-&gt;end())
           it = r-&gt;begin();
         return *this;
       }
       iterator operator++(int) {
         iterator tmp = *this;
         ++*this;
         return tmp;
       }
       iterator& operator--() {
         if(it == r-&gt;begin())
           it = r-&gt;end();
         --it;
         return *this;
       }
       iterator operator--(int) {
         iterator tmp = *this;
         --*this;
         return tmp;
       }
       iterator insert(const T& x){
         return iterator(*r, r-&gt;insert(it, x));
       }
       iterator erase() {
         return iterator(*r, r-&gt;erase(it));
       }
     };
     void push_back(const T& x) {
       lst.push_back(x);
     }
     iterator begin() {
       return iterator(lst, lst.begin());
     }
    int size() { return lst.size(); }
   };

   int main() {
     Ring&lt;string&gt; rs;
     rs.push_back("one");
     rs.push_back("two");
     rs.push_back("three");
     rs.push_back("four");
     rs.push_back("five");
     Ring&lt;string&gt;::iterator it = rs.begin();
     it++; it++;
     it.insert("six");
     it = rs.begin();
     // Twice around the ring:
     for(int i = 0; i&lt; rs.size() * 2; i++)
       cout&lt;&lt; *it++&lt;&lt; endl;
   } ///:~

   You can see that most of the coding is in the iterator. TheRing iterator must know how to loop back to the beginning, so it must keep a reference to thelistof its "parent"Ring object in order to know if it’s at the end and how to get back to the beginning.
   You’ll notice that the interface forRing is quite limited; in particular, there is noend( ), since a ring just keeps looping. This means that you won’t be able to use aRing in any STL algorithms that require a past-the-end iterator, which is many of them. (It turns out that adding this feature is a nontrivial exercise.) Although this can seem limiting, considerstack,queue, andpriority_queue, which don’t produce any iterators at all!.
   STL extensions
   Although the STL containers may provide all the functionality you’ll ever need, they are not complete. For example, the standard implementations ofset andmap use trees, and although these are reasonably fast, they may not be fast enough for your needs. In the C++ Standards Committee it was generally agreed that hashed implementations ofset andmap should have been included in Standard C++; however, there was not enough time to add these components, and thus they were left out.[101]
   Fortunately, alternatives are freely available. One of the nice things about the STL is that it establishes a basic model for creating STL-like classes, so anything built using the same model is easy to understand if you are already familiar with the STL.
   The SGI STL from Silicon Graphics[102] is one of the most robust implementations of the STL and can be used to replace your compiler’s STL if that is found wanting. In addition, SGI has added a number of extensions includinghash_set,hash_multiset,hash_map,hash_multimap,slist (a singly linked list), andrope (a variant ofstring optimized for very large strings and fast concatenation and substring operations).
   Let’s consider a performance comparison between a tree-basedmap and the SGIhash_map. To keep things simple, the mappings will be fromint toint:
   //: C07:MapVsHashMap.cpp
   // The hash_map header is not part of the
   // Standard C++ STL. It is an extension that
   // is only available as part of the SGI STL
   // (Included with the g++ distribution)
   //{-bor} You can add the header by hand
   //{-msc} You can add the header by hand
   //{-g++} You can add the header by hand
   #include&lt;hash_map&gt;
   #include&lt;iostream&gt;
   #include&lt;map&gt;
   #include&lt;ctime&gt;
   using namespace std;

   int main(){
     hash_map&lt;int, int&gt; hm;
     map&lt;int, int&gt; m;
     clock_t ticks = clock();
     for(int i = 0; i&lt; 100; i++)
       for(int j = 0; j&lt; 1000; j++)
         m.insert(make_pair(j,j));
     cout&lt;&lt; "map insertions: "
      &lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i = 0; i&lt; 100; i++)
       for(int j = 0; j&lt; 1000; j++)
         hm.insert(make_pair(j,j));
     cout&lt;&lt; "hash_map insertions: "
      &lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i = 0; i&lt; 100; i++)
       for(int j = 0; j&lt; 1000; j++)
         m[j];
     cout&lt;&lt; "map::operator[] lookups: "
      &lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i = 0; i&lt; 100; i++)
       for(int j = 0; j&lt; 1000; j++)
         hm[j];
     cout&lt;&lt; "hash_map::operator[] lookups: "
      &lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i = 0; i&lt; 100; i++)
       for(int j = 0; j&lt; 1000; j++)
         m.find(j);
     cout&lt;&lt; "map::find() lookups: "
      &lt;&lt; clock() - ticks&lt;&lt; endl;
     ticks = clock();
     for(int i = 0; i&lt; 100; i++)
       for(int j = 0; j&lt; 1000; j++)
         hm.find(j);
     cout&lt;&lt; "hash_map::find() lookups: "
      &lt;&lt; clock() - ticks&lt;&lt; endl;
   } ///:~

   The performance test we ran showed a speed improvement of roughly 4:1 for thehash_map over themap in all operations (and as expected,find( ) is slightly faster thanoperator[ ] for lookups for both types of map). If a profiler shows a bottleneck in yourmap, consider ahash_map.
   Non-STL containers
   There are two "non-STL" containers in the standard library:bitset andvalarray.[103] We say "non-STL" because neither of these containers fulfills all the requirements of STL containers. Thebitset container, which we covered earlier in this chapter, packs bits into integers and does not allow direct addressing of its members. Thevalarray template class is a vector-like container that is optimized for efficient numeric computation. Neither container provides iterators. Although you can instantiate avalarray with nonnumeric types, it has mathematical functions that are intended to operate with numeric data, such assin,cos,tan, and so on. Most ofvalarray’s functions and operators operate on avalarray as a whole, as the following example illustrates.
   //: C07:Valarray1.cpp
   //{-bor}
   // Illustrates basic valarray functionality
   #include&lt;iostream&gt;
   #include&lt;valarray&gt;
   using namespace std;

   double f(double x) {
     return 2.0 * x - 1.0;
   }

   template&lt;class T&gt;
   void print(const char* lbl, const valarray&lt;T&gt;& a) {
     cout&lt;&lt; lbl&lt;&lt; ": ";
     for(size_t i = 0; i&lt; a.size(); ++i)
       cout&lt;&lt; a[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
   }

   int main() {
     double n[] = {1.0, 2.0, 3.0, 4.0};
     valarray&lt;double&gt; v(n, sizeof n / sizeof n[0]);
     print("v", v);
     valarray&lt;double&gt; sh(v.shift(1));
     print("shift 1", sh);
     valarray&lt;double&gt; acc(v + sh);
     print("sum", acc);
     valarray&lt;double&gt; trig(sin(v) + cos(acc));
     print("trig", trig);
     valarray&lt;double&gt; p(pow(v, 3.0));
     print("3rd power", p);
     valarray&lt;double&gt; app(v.apply(f));
     print("f(v)", app);
     valarray&lt;bool&gt; eq(v == app);
     print("v == app?", eq);
     double x = v.min();
     double y = v.max();
     double z = v.sum();
     cout&lt;&lt; "x = "&lt;&lt; x&lt;&lt; ", y = "&lt;&lt; y
      &lt;&lt; ", z = "&lt;&lt; z &lt;&lt; endl;
   } ///:~

   Thevalarray class provides a constructor that takes an array of the target type and the count of elements in the array to be used to initialize the newvalarray. Theshift( ) member function shifts eachvalarray element one position to the left (or to the right, if its argument is negative) and fills in holes with the default value for the type (zero in this case). There is also acshift( ) member function that does a circular shift (or "rotate"). All mathematical operators and functions are overloaded to operate onvalarrays, and binary operators requirevalarray arguments of the same type and size. Theapply( ) member function, like thetransform( ) algorithm, applies a function to each element, but the result is collected into a resultvalarray. The relational operators return suitably sized instances ofvalarray&lt;bool&gt; that indicate the result of element-by-element comparisons, such as witheq above. Most operations return a new result array, but a few, such asmin( ),max( ), andsum( ), return a single scalar value for obvious reasons.
   The most interesting thing you can do withvalarrays is reference subsets of their elements, not only for extracting information, but for updating it. A subset of avalarray is called aslice, and certain operators use slices to do their work. The following sample program uses slices.
   //: C07:Valarray2.cpp
   // Illustrates slices and masks
   //{-bor}
   #include&lt;valarray&gt;
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   void print(const char* lbl, const valarray&lt;T&gt;& a) {
     cout&lt;&lt; lbl&lt;&lt; ": ";
     for(size_t i = 0; i&lt; a.size(); ++i)
       cout&lt;&lt; a[i]&lt;&lt; ' ';
     cout&lt;&lt; endl;
   }

   int main() {
     int data[] = {1,2,3,4,5,6,7,8,9,10,11,12};
     valarray&lt;int&gt; v(data, 12);
     valarray&lt;int&gt; r1(v[slice(0, 4, 3)]);
     print("slice(0,4,3)", r1);
     // Extract conditionally
     valarray&lt;int&gt; r2(v[v&gt; 6]);
     print("elements&gt; 6", r2);
     // Square first column
     v[slice(0, 4, 3)] *= valarray&lt;int&gt;(v[slice(0, 4, 3)]);
     print("after squaring first column", v);
     // Restore it
     int idx[] = {1,4,7,10};
     valarray&lt;int&gt; save(idx, 4);
     v[slice(0, 4, 3)] = save;
     print("v restored", v);
     // Extract a 2-d subset: {{1, 3, 5}, {7, 9, 11}}
     valarray&lt;size_t&gt; siz(2);
     siz[0] = 2;
     siz[1] = 3;
     valarray&lt;size_t&gt; gap(2);
     gap[0] = 6;
     gap[1] = 2;
     valarray&lt;int&gt; r3(v[gslice(0, siz, gap)]);
     print("2-d slice", r3);
     // Extract a subset via a boolean mask (bool elements)
     valarray&lt;bool&gt; mask(false, 5);
     mask[1] = mask[2] = mask[4] = true;
     valarray&lt;int&gt; r4(v[mask]);
     print("v[mask]", r4);
     // Extract a subset via an index mask (size_t elements)
     size_t idx2[] = {2,2,3,6};
     valarray&lt;size_t&gt; mask2(idx2, 4);
     valarray&lt;int&gt; r5(v[mask2]);
     print("v[mask2]", r5);
     // Use an index mask in assignment
     valarray&lt;char&gt; text("now is the time", 15);
     valarray&lt;char&gt; caps("NITT", 4);
     valarray&lt;size_t&gt; idx3(4);
     idx3[0] = 0;
     idx3[1] = 4;
     idx3[2] = 7;
     idx3[3] = 11;
     text[idx3] = caps;
     print("capitalized", text);
   } ///:~

   Aslice object takes three arguments: the starting index, the number of elements to extract, and the "stride," which is the gap between elements of interest. Slices can be used as indexes into an existingvalarray, and a newvalarray containing the extracted elements is returned. Avalarray ofbool, such as is returned by the expressionv&gt; 6, can be used as an index into anothervalarray; the elements corresponding to thetrue slots are extracted. As you can see, you can also use slices and masks as indexes on the left side of an assignment. Agslice object (for "generalized slice") is like a slice, except that the counts and strides are themselves arrays, which allows you to interpret avalarray as a multidimensional array. The example above extracts a 2 by 3 array fromv, where the numbers start at zero and the numbers for the first dimension are found six slots apart inv, and the others two apart, which effectively extracts the matrix
   1 3 5
   7 9 11

   Here is the complete output for this program:
   slice(0,4,3): 1 4 7 10
   elements&gt; 6: 7 8 9 10
   after squaring v: 1 2 3 16 5 6 49 8 9 100 11 12
   v restored: 1 2 3 4 5 6 7 8 9 10 11 12
   2-d slice: 1 3 5 7 9 11
   v[mask]: 2 3 5
   v[mask2]: 3 3 4 7
   capitalized: N o w   I s   T h e   T i m e

   A practical example of slices is found in matrix multiplication. Consider how you would write a function to multiply two matrices of integers with arrays.
   void matmult(const int a[][MAXCOLS], size_t m, size_t n,
                const int b[][MAXCOLS], size_t p, size_t q,
                int result[][MAXCOLS);

   This function multiplies them-by-n matrixa by thep-by-q matrixb, wheren andp are equal, of course. As you can see, without something likevalarray, you need to fix the maximum value for the second dimension of each matrix, since locations in arrays are statically determined. It is also difficult to return a result array by value, so the caller usually passes the result array as an argument.
   Usingvalarray not only allows you to pass any size matrix, but you can also easily process matrices of any type, and return the result by value. Here’s how:
   // Multiplies compatible matrices in valarrays
   template&lt;class T&gt;
   valarray&lt;T&gt; matmult(const valarray&lt;T&gt;& a, size_t arows,
        size_t acols, const valarray&lt;T&gt;& b,
        size_t brows, size_t bcols) {
     assert(acols == brows);
     valarray&lt;T&gt; result(arows * bcols);
     for(size_t i = 0; i&lt; arows; ++i)
       for(size_t j = 0; j&lt; bcols; ++j) {
         // Take dot product of row a[i] and col b[j]
         valarray&lt;T&gt; row = a[slice(acols*i, acols, 1)];
         valarray&lt;T&gt; col = b[slice(j, brows, bcols)];
         result[i*bcols + j] = (row * col).sum();
       }
     return result;
   }

   Each entry in the result matrix is the dot product of a row ina with a column inb. By taking slices, you can extract these rows and columns asvalarrays and use the global* operator andsum( ) function provided byvalarray to do the work succinctly. The resultvalarray is computed at runtime; there’s no need to worry about the static limitations of array dimensions. You do have to compute linear offsets of the position[i][j] yourself (see the formulai*bcols + j above), but the size and type freedom is worth it.
   Summary
   The goal of this chapter was not just to introduce the STL containers in some considerable depth. (Of course, not every detail could be covered here, but you have enough now that you can look up further information in the other resources.) Our higher hope is that this chapter has made you grasp the incredible power available in the STL and shown you how much faster and more efficient your programming activities can be by using and understanding the STL.
   Exercises
                1.             Create aset&lt;char&gt;, open a file (whose name is provided on the command line), and read that file in achar at a time, placing eachchar in the set. Print the results, and observe the organization. Are there any letters in the alphabet that are not used in that particular file?
           39.             Create three sequences ofNoisy objects, avector,deque, andlist. Sort them. Now write a function template to receive thevector anddeque sequences as a parameter to sort them and record the sorting time. Write a specialized template function to do the same forlist (ensure to call its membersort( ) instead of the generic algorithm). Compare the performance of the different sequence types.
           40.             Write a program to compare the speed of sorting a list usinglist::sort( ) vs. usingstd::sort( ) (the STL algorithm version ofsort( )).
            41.             Create a generator that produces randomint values between 0 and 20 inclusive, and use it to fill amultiset&lt;int&gt;. Count the occurrences of each value, following the example given inMultiSetWordCount.cpp.
           42.             ChangeStlShape.cpp so that it uses adeque instead of avector.
           43.             ModifyReversible.cpp so it works withdeque andlist instead ofvector.
           44.             Use astack&lt;int&gt; and populate it with a Fibonacci sequence. The program’s command line should take the number of Fibonacci elements desired, and you should have a loop that looks at the last two elements on the stack and pushes a new one for every pass through the loop.
           45.             Using only threestacks (source,sorted, andlosers), sort a random sequence of numbers by placing the numbers initially on thesource stack. Assume the number on the top of thesource is the largest, and push it on thesorted stack. Continue to pop thesource stack comparing it with the top of thesorted stack. Whichever number is the smallest, pop it from its stack and push it onto the on thelosers’ stack. Once thesource stack is empty, repeat the process using theloser’s stack as thesource stack, and use thesource stack as thelosers’ stack. The algorithm completes when all the numbers have been placed into thewinners’ stack.
           46.             Open a text file whose name is provided on the command line. Read the file a word at a time, and use amultiset&lt;string&gt; to create a word count for each word.
            47.             ModifyWordCount.cpp so that it usesinsert( ) instead ofoperator[ ] to insert elements in the map.
           48.             Create a class that has anoperator&lt; and anostream& operator&lt;&lt;. The class should contain a priority number. Create a generator for your class that makes a random priority number. Fill apriority_queue using your generator, and then pull the elements out to show they are in the proper order.
           49.             RewriteRing.cpp so it uses adeque instead of alist for its underlying implementation.
           50.             ModifyRing.cpp so that the underlying implementation can be chosen using a template argument. (Let that template argument default tolist.)
            51.             Create an iterator class calledBitBucket that just absorbs whatever you send to it without writing it anywhere.
           52.             Create a kind of "hangman" game. Create a class that contains achar and abool to indicate whether thatchar has been guessed yet. Randomly select a word from a file, and read it into a vector of your new type. Repeatedly ask the user for a character guess, and after each guess, display the characters in the word that have been guessed, and display underscores for the characters that haven’t. Allow a way for the user to guess the whole word. Decrement a value for each guess, and if the user can get the whole word before the value goes to zero, they win.
           53.             Open a file and read it into a single string. Turn the string into astringstream. Read tokens from thestringstream into alist&lt;string&gt; using aTokenIterator.
           54.             Compare the performance ofstack based on whether it is implemented withvector,deque, orlist.
           55.             Create a template that implements a singly-linked list calledSList. Provide a default constructor andbegin( ) andend( ) functions (via an appropriate nested iterator),insert( ),erase( ) and a destructor.
           56.             Generate a sequence of random integers storing them into an array ofint. Initialize avalarray&lt;int&gt; with its contents. Compute the sum, minimum value, maximum value, average, and median of the integers usingvalarray operations.
            57.             Create avalarray&lt;int&gt; with 12 random values. Create anothervalarray&lt;int&gt; with 20 random values. You will interpret the firstvalarray as a 3 x 4 matrix ofints and the second as a 4 x 5 matrix ofints, and multiply them by the rules of matrix multiplication. Store the result in avalarray&lt;int&gt; of size 15, representing the 3 x 5 result matrix. Use slices to multiply the rows of the first matrix time the columns of the second. Print the result in rectangular matrix form.
   [ ]
   Part 3: Special Topics
   The mark of a professional in any field appears in his or her attention to the finer points of the craft. In this part of the book we discuss advanced features of C++ along with development techniques used by polished C++ professionals.
   Once in a great while you may need to depart from the conventional wisdom of sound object-oriented design by inspecting the runtime type of an object for special processing. Most of the time you should let virtual functions do that job for you, but when writing special-purpose software tools, such as debuggers, database viewers, or class browsers, you’ll need to determine type information at runtime. This is where the runtime type identification (RTTI) mechanism comes into play, which is the topic of Chapter 8. Multiple inheritance has taken a bad rap over the years, and some languages don’t even support it. Nonetheless, when used properly,it can be a powerful tool for crafting elegant, efficient code. A number of standard practices involving multiple inheritance have evolved over the years, which we present in Chapter 9. Perhaps the most notable innovation in software development since object-oriented techniques is the use of designpatterns. A design pattern describes and presents solutions for many of the common problems involved in designing software, and can be applied in many situations and implemented in any language. In chapter 10 we describe a selected number of widely-used design patterns and implement them in C++. Chapter 11 explains in detail the benefits and challenges of multi-threaded programming. The current version of standard C++ does not specify support for threads, even though most operating systems support them. We use a portable, freely-available thread library to illustrate how C++ programmers can take advantage of threads to build more usable and responsive applications.
   8: Runtime type identification
   Runtime type identification (RTTI) lets you find the dynamic type of an object when you have only a pointer or a reference to the base type.
   This can be thought of as a "secondary" feature in C++, pragmatism to help out when you get into rare messy situations. Normally, you’ll want to intentionally ignore the exact type of an object and let the virtual function mechanism implement the correct behavior for that type automatically. On occasion, however, it’s useful to know the exactruntime (that is, most derived) type of an object for which you only have a base pointer. Often this information allows you to perform a special-case operation more efficiently or prevent a base-class interface from becoming ungainly. It happens enough that most class libraries contain virtual functions to produce run-time type information. When exception handling was added to C++, it required information about the runtime type of objects. It became an easy next step to build access to that information into the language. This chapter explains what RTTI is for and how to use it.
   Runtime casts
   One way to determine the runtime type of an object through a pointer is to employ aruntime cast, which verifies that the attempted conversion is valid. This is useful when you need to cast a base-class pointer to a derived type. Since inheritance hierarchies are typically depicted with base classes above derived classes, such a cast is called adowncast.
   Consider the following class hierarchy.
    [Êàðòèíêà: img_6.png] 

   In the code that follows, theInvestment class has an extra operation that the other classes do not, so it is important to be able to know at runtime whether aSecurity pointer refers to aInvestment object or not. To implement checked runtime casts, each class keeps an integral identifier to distinguish it from other classes in the hierarchy.
   //: C08:CheckedCast.cpp
   // Checks casts at runtime
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Security {
   protected:
     enum {BASEID = 0};
   public:
     virtual ~Security() {}
     virtual bool isA(int id) {
        return (id == BASEID);
     }
   };
   class Stock : public Security {
     typedef Security Super;
   protected:
     enum {OFFSET = 1, TYPEID = BASEID + OFFSET};
   public:
     bool isA(int id) {
       return id == TYPEID || Super::isA(id);
     }
     static Stock* dynacast(Security* s) {
       return (s-&gt;isA(TYPEID)) ?
         static_cast&lt;Stock*&gt;(s) : 0;
     }
   };
   class Bond : public Security {
     typedef Security Super;
   protected:
     enum {OFFSET = 2, TYPEID = BASEID + OFFSET};
   public:
     bool isA(int id) {
       return id == TYPEID || Super::isA(id);
     }
     static Bond* dynacast(Security* s) {
       return (s-&gt;isA(TYPEID)) ?
         static_cast&lt;Bond*&gt;(s) : 0;
     }
   };
   class Investment : public Security {
     typedef Security Super;
   protected:
     enum {OFFSET = 3, TYPEID = BASEID + OFFSET};
   public:
     bool isA(int id) {
       return id == BASEID || Super::isA(id);
     }
     static Investment* dynacast(Security* s) {
       return (s-&gt;isA(TYPEID)) ?
         static_cast&lt;Investment*&gt;(s) : 0;
     }
     void special() {
       cout&lt;&lt; "special Investment function\n";
     }
   };

   class Metal : public Investment {
     typedef Investment Super;
   protected:
     enum {OFFSET = 4, TYPEID = BASEID + OFFSET};
   public:
     bool isA(int id) {
       return id == BASEID || Super::isA(id);
     }
     static Metal* dynacast(Security* s) {
       return (s-&gt;isA(TYPEID)) ?
         static_cast&lt;Metal*&gt;(s) : 0;
     }
   };

   int main() {
     vector&lt;Security*&gt; portfolio;
     portfolio.push_back(new Metal);
     portfolio.push_back(new Investment);
     portfolio.push_back(new Bond);
     portfolio.push_back(new Stock);
     for (vector&lt;Security*&gt;::iterator it =
            portfolio.begin();
          it != portfolio.end(); ++it) {
       Investment* cm = Investment::dynacast(*it);
       if(cm)
         cm-&gt;special();
       else
         cout&lt;&lt; "not a Investment"&lt;&lt; endl;
     }
     cout&lt;&lt; "cast from intermediate pointer:\n";
     Security* sp = new Metal;
     Investment* cp = Investment::dynacast(sp);
     if(cp) cout&lt;&lt; "  it's an Investment\n";
     Metal* mp = Metal::dynacast(sp);
     if(mp) cout&lt;&lt; "  it's a Metal too!\n";
     purge(portfolio);
   } ///:~

   The polymorphicisA( ) function checks to see if its argument is compatible with its type argument (id), which means that eitherid matches the object’stypeID exactly or that of one of its ancestors in the hierarchy (hence the call toSuper::isA( ) in that case). Thedynacast( ) function, which is static in each class, callsisA( ) for its pointer argument to check if the cast is valid. IfisA( ) returnstrue, the cast is valid, and a suitably cast pointer is returned. Otherwise, the null pointer is returned, which tells the caller that the cast is not valid, meaning that the original pointer is not pointing to an object compatible with (convertible to) the desired type. All this machinery is necessary to be able to check intermediate casts, such as from aSecurity pointer that refers to aMetal object to aInvestment pointer in the previous example program.[104] 
   Although for most programs downcasting is not needed (and indeed is discouraged, since everyday polymorphism solves most problems in object-oriented application programs), the ability to check a cast to a more derived type is important for utility programs such as debuggers, class browsers, and databases. C++ provides such a checked cast with thedynamic_cast operator. The following program is a rewrite of the previous example usingdynamic_cast.
   //: C08:CheckedCast2.cpp
   // Uses RTTI’s dynamic_cast
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Security {
   public:
     virtual ~Security(){}
   };
   class Stock : public Security {};
   class Bond : public Security {};
   class Investment : public Security {
   public:
     void special() {
       cout&lt;&lt; "special Investment function\n";
     }
   };
   class Metal : public Investment {};

   int main() {
     vector&lt;Security*&gt; portfolio;
     portfolio.push_back(new Metal);
     portfolio.push_back(new Investment);
     portfolio.push_back(new Bond);
     portfolio.push_back(new Stock);
     for (vector&lt;Security*&gt;::iterator it =
                       portfolio.begin();
          it != portfolio.end(); ++it) {
       Investment* cm = dynamic_cast&lt;Investment*&gt;(*it);
       if(cm)
         cm-&gt;special();
       else
         cout&lt;&lt; "not a Investment"&lt;&lt; endl;
     }
     cout&lt;&lt; "cast from intermediate pointer:\n";
     Security* sp = new Metal;
     Investment* cp = dynamic_cast&lt;Investment*&gt;(sp);
     if(cp) cout&lt;&lt; "  it's an Investment\n";
     Metal* mp = dynamic_cast&lt;Metal*&gt;(sp);
     if(mp) cout&lt;&lt; "  it's a Metal too!\n";
     purge(portfolio);
   } ///:~

   This example is much shorter, since most of the code in the original example was just the overhead for checking the casts. The target type of adynamic_cast is placed in angle brackets, like the other new-style C++ casts (static_cast, and so on), and the object to cast appears as the operand.dynamic_cast requires that the types you use it with bepolymorphic if you want safe downcasts.[105] This in turn requires that the class must have at least one virtual function. Fortunately, theSecurity base class has a virtual destructor, so we didn’t have to invent some extraneous function to get the job done.dynamic_cast does its work at runtime, of course, since it has to check the virtual function table of objects according to there dynamic type. This naturally implies thatdynamic_cast tends to be more expensive than the other new-style casts.
   You can also usedynamic_cast with references instead of pointers, but since there is no such thing as a null reference, you need another way to know if the cast fails. That "other way" is to catch abad_cast exception, as follows:
     Metal m;
     Security& s = m;
     try {
       Investment& c = dynamic_cast&lt;Investment&&gt;(s);
       cout&lt;&lt; "  it's an Investment\n";
     }
     catch (bad_cast&) {
       cout&lt;&lt; "s is not an Investment type\n";
     }

   Thebad_cast class is defined in the&lt;typeinfo&gt; header, and, like most of the standard library, is declared in thestd namespace.
   The typeid operator
   The other way to get runtime information for an object is through thetypeid operator. This operator returns an object of classtype_info, which yields information about the type of object to which it was applied. If the type is polymorphic, it gives information about the most derived type that applies (thedynamic type); otherwise it yields static type information. One use of thetypeid operator is to get the name of the dynamic type of an object as aconst char*, as you can see in the following example.
   //: C08:TypeInfo.cpp
   // Illustrates the typeid operator
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   struct PolyBase {virtual ~PolyBase(){}};
   struct PolyDer : PolyBase {};
   struct NonPolyBase {};
   struct NonPolyDer : NonPolyBase {NonPolyDer(int){}};
   int main() {
     // Test polymorphic Types
     const PolyDer pd;
     const PolyBase* ppb =&pd;
     cout&lt;&lt; typeid(ppb).name()&lt;&lt; endl;
     cout&lt;&lt; typeid(*ppb).name()&lt;&lt; endl;
     cout&lt;&lt; boolalpha&lt;&lt; (typeid(*ppb) == typeid(pd))
      &lt;&lt; endl;
     cout&lt;&lt; (typeid(PolyDer) == typeid(const PolyDer))
      &lt;&lt; endl;
     // Test non-polymorphic Types
     const NonPolyDer npd(1);
     const NonPolyBase* nppb =&npd;
     cout&lt;&lt; typeid(nppb).name()&lt;&lt; endl;
     cout&lt;&lt; typeid(*nppb).name()&lt;&lt; endl;
     cout&lt;&lt; (typeid(*nppb) == typeid(npd))
      &lt;&lt; endl;
     // Test a built-in type
     int i;
     cout&lt;&lt; typeid(i).name()&lt;&lt; endl;
   } ///:~

   The output from this program is
   struct PolyBase const *
   struct PolyDer
   true
   true
   struct NonPolyBase const *
   struct NonPolyBase
   false
   int

   The first output line just echoes the static type ofppb because it is a pointer. To get RTTI to kick in, you need to look at the object a pointer or reference is connected to, which is illustrated in the second line. Notice that RTTI ignores top-levelconst andvolatile qualifiers. With non-polymorphic types, you just get the static type (the type of the pointer itself). As you can see, built-in types are also supported.
   It turns out that you can’t store the result of atypeid operation in atype_info object, because there are no accessible constructors and assignment is disallowed; you must use it as we have shown. In addition, the actual string returned bytype_info::name( ) is compiler dependent. Some compilers return "class C" instead of just "C", for instance, for a class namedC. Applyingtypeid to an expression that dereferences a null pointer will cause abad_typeid exception (also defined in&lt;typeinfo&gt;) to be thrown.
   The following example shows that the class name thattype_info::name( ) returns is fully qualified.
   //: C08:RTTIandNesting.cpp
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   class One {
     class Nested {};
     Nested* n;
   public:
     One() : n(new Nested) {}
     ~One() { delete n; }
     Nested* nested() { return n; }
   };

   int main() {
     One o;
     cout&lt;&lt; typeid(*o.nested()).name()&lt;&lt; endl;
   } ///:~

   SinceNested is a member type of theOne class, the result isOne::Nested.
   You can also ask atype_info object if it precedes anothertype_info object in the implementation-defined "collation sequence" (the native ordering rules for text), usingbefore(type_info&), which returnstrue orfalse. When you say,.
   if(typeid(me).before(typeid(you))) // ...

   you’re asking ifme occurs beforeyou in the current collation sequence. This is useful should you usetype_info objects as keys.
   Casting to intermediate levels
   As you saw in the earlier program that used the hierarchy ofSecurity classes,dynamic_cast can detect both exact types and, in an inheritance hierarchy with multiple levels, intermediate types. Here is another example.
   //: C08:IntermediateCast.cpp
   #include&lt;cassert&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   class B1 {
   public:
     virtual ~B1() {}
   };

   class B2 {
   public:
     virtual ~B2() {}
   };

   class MI : public B1, public B2 {};
   class Mi2 : public MI {};

   int main() {
     B2* b2 = new Mi2;
     Mi2* mi2 = dynamic_cast&lt;Mi2*&gt;(b2);
     MI* mi = dynamic_cast&lt;MI*&gt;(b2);
     B1* b1 = dynamic_cast&lt;B1*&gt;(b2);
     assert(typeid(b2) != typeid(Mi2*));
     assert(typeid(b2) == typeid(B2*));
     delete b2;
   } ///:~

   This example has the extra complication of multiple inheritance (more on this later in this chapter). If you create anMi2 and upcast it to the root (in this case, one of the two possible roots is chosen), thedynamic_cast back to either of the derived levelsMI orMi2 is successful.
   You can even cast from one root to the other:
     B1* b1 = dynamic_cast&lt;B1*&gt;(b2);

   This is successful becauseB2 is actually pointing to anMi2 object, which contains a subobject of typeB1.
   Casting to intermediate levels brings up an interesting difference betweendynamic_cast andtypeid. Thetypeid operator always produces a reference to a statictypeinfo object that describes the dynamic type of the object. Thus, it doesn’t give you intermediate-level information. In the following expression (which istrue),typeid doesn’t seeb2 as a pointer to the derived type, likedynamic_cast does:
   typeid(b2) != typeid(Mi2*)

   The type ofb2 is simply the exact type of the pointer:
   typeid(b2) == typeid(B2*)

   void pointers
   RTTI only works for complete types, meaning that all class information must be available whentypeid is used. In particular, it doesn’t work withvoid pointers:
   //: C08:VoidRTTI.cpp
   // RTTI& void pointers
   //!#include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   class Stimpy {
   public:
     virtual void happy() {}
     virtual void joy() {}
     virtual ~Stimpy() {}
   };

   int main() {
     void* v = new Stimpy;
     // Error:
   //!  Stimpy* s = dynamic_cast&lt;Stimpy*&gt;(v);
     // Error:
   //!  cout&lt;&lt; typeid(*v).name()&lt;&lt; endl;
   } ///:~

   Avoid* truly means "no type information at all."[106] 
   Using RTTI with templates
   Class templates work well with RTTI, since all they do is generate classes. As usual, RTTI provides a convenient way to obtain the name of the class you’re in. The following example prints the order of constructor and destructor calls:
   //: C08:ConstructorOrder.cpp
   // Order of constructor calls
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   template&lt;int id&gt; class Announce {
   public:
     Announce() {
       cout&lt;&lt; typeid(*this).name()
           &lt;&lt; " constructor"&lt;&lt; endl;
     }
     ~Announce() {
       cout&lt;&lt; typeid(*this).name()
           &lt;&lt; " destructor"&lt;&lt; endl;
     }
   };

   class X : public Announce&lt;0&gt; {
     Announce&lt;1&gt; m1;
     Announce&lt;2&gt; m2;
   public:
     X() { cout&lt;&lt; "X::X()"&lt;&lt; endl; }
     ~X() { cout&lt;&lt; "X::~X()"&lt;&lt; endl; }
   };

   int main() { X x; } ///:~

   This template uses a constantint to differentiate one class from another, but type arguments would work as well. Inside both the constructor and destructor, RTTI information produces the name of the class to print. The classX uses both inheritance and composition to create a class that has an interesting order of constructor and destructor calls. The output is:
   Announce&lt;0&gt; constructor
   Announce&lt;1&gt; constructor
   Announce&lt;2&gt; constructor
   X::X()
   X::~X()
   Announce&lt;2&gt; destructor
   Announce&lt;1&gt; destructor
   Announce&lt;0&gt; destructor

   Multiple inheritance
   Of course, the RTTI mechanisms must work properly with all the complexities of multiple inheritance, includingvirtual base classes (discussed in depth in the next chapter—you may want to come back to this after reading Chapter 9):
   //: C08:RTTIandMultipleInheritance.cpp
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   using namespace std;

   class BB {
   public:
     virtual void f() {}
     virtual ~BB() {}
   };
   class B1 : virtual public BB {};
   class B2 : virtual public BB {};
   class MI : public B1, public B2 {};

   int main() {
     BB* bbp = new MI; // Upcast
     // Proper name detection:
     cout&lt;&lt; typeid(*bbp).name()&lt;&lt; endl;
     // Dynamic_cast works properly:
     MI* mip = dynamic_cast&lt;MI*&gt;(bbp);
     // Can't force old-style cast:
   //! MI* mip2 = (MI*)bbp; // Compile error
   } ///:~

   Thetypeid( )operation properly detects the name of the actual object, even through thevirtual base class pointer. Thedynamic_cast also works correctly. But the compiler won’t even allow you to try to force a cast the old way:
   MI* mip = (MI*)bbp; // Compile-time error

   The compiler knows this is never the right thing to do, so it requires that you use adynamic_cast.
   Sensible uses for RTTI
   Because it allows you to discover type information from an anonymous polymorphic pointer, RTTI is ripe for misuse by the novice because RTTI may make sense before virtual functions do. For many people coming from a procedural background, it’s difficult not to organize programs into sets ofswitch statements. They could accomplish this with RTTI and thus lose the important value of polymorphism in code development and maintenance. The intent of C++ is that you use virtual functions throughout your code and that you only use RTTI when you must.
   However, using virtual functions as they are intended requires that you have control of the base-class definition because at some point in the extension of your program you may discover the base class doesn’t include the virtual function you need. If the base class comes from a library or is otherwise controlled by someone else, a solution to the problem is RTTI: you can derive a new type and add your extra member function. Elsewhere in the code you can detect your particular type and call that member function. This doesn’t destroy the polymorphism and extensibility of the program, because adding a new type will not require you to hunt for switch statements. However, when you add new code in the main body that requires your new feature, you’ll have to detect your particular type.
   Putting a feature in a base class might mean that, for the benefit of one particular class, all the other classes derived from that base require some meaningless stub for a pure virtual function. This makes the interface less clear and annoys those who must redefine pure virtual functions when they derive from that base class.
   Finally, RTTI will sometimes solve efficiency problems. If your code uses polymorphism in a nice way, but it turns out that one of your objects reacts to this general-purpose code in a horribly inefficient way, you can pick that type out using RTTI and write case-specific code to improve the efficiency.
   A trash recycler
   To further illustrate a practical use of RTTI, the following program simulates a trash recycler. Different kinds of "trash" are inserted into a single container and then later sorted according to their dynamic types.
   //: C08:Recycle.cpp
   // A Trash Recycler
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Trash {
     float _weight;
   public:
     Trash(float wt) : _weight(wt) {}
     virtual float value() const = 0;
     float weight() const { return _weight; }
     virtual ~Trash() { cout&lt;&lt; "~Trash()\n"; }
   };
   class Aluminum : public Trash {
     static float val;
   public:
     Aluminum(float wt) : Trash(wt) {}
     float value() const { return val; }
     static void value(float newval) {
       val = newval;
     }
   };
   float Aluminum::val = 1.67;
   class Paper : public Trash {
     static float val;
   public:
     Paper(float wt) : Trash(wt) {}
     float value() const { return val; }
     static void value(float newval) {
       val = newval;
     }
   };
   float Paper::val = 0.10;
   class Glass : public Trash {
     static float val;
   public:
     Glass(float wt) : Trash(wt) {}
     float value() const { return val; }
     static void value(float newval) {
       val = newval;
     }
   };
   float Glass::val = 0.23;

   // Sums up the value of the Trash in a bin:
   template&lt;class Container&gt;
   void sumValue(Container& bin, ostream& os) {
     typename Container::iterator tally =
       bin.begin();
     float val = 0;
     while(tally != bin.end()) {
       val += (*tally)-&gt;weight() * (*tally)-&gt;value();
       os&lt;&lt; "weight of "
          &lt;&lt; typeid(**tally).name()
          &lt;&lt; " = "&lt;&lt; (*tally)-&gt;weight()&lt;&lt; endl;
       tally++;
     }
     os&lt;&lt; "Total value = "&lt;&lt; val&lt;&lt; endl;
   }

   int main() {
     srand(time(0)); // Seed random number generator
     vector&lt;Trash*&gt; bin;
     // Fill up the Trash bin:
     for(int i = 0; i&lt; 30; i++)
       switch(rand() % 3) {
         case 0 :
           bin.push_back(new Aluminum((rand() % 1000)/10.0));
           break;
         case 1 :
           bin.push_back(new Paper((rand() % 1000)/10.0));
           break;
         case 2 :
           bin.push_back(new Glass((rand() % 1000)/10.0));
           break;
       }
     // Note: bins hold exact type of object, not base type:
     vector&lt;Glass*&gt; glassBin;
     vector&lt;Paper*&gt; paperBin;
     vector&lt;Aluminum*&gt; alumBin;
     vector&lt;Trash*&gt;::iterator sorter = bin.begin();
     // Sort the Trash:
     while(sorter != bin.end()) {
       Aluminum* ap =
         dynamic_cast&lt;Aluminum*&gt;(*sorter);
       Paper* pp =
         dynamic_cast&lt;Paper*&gt;(*sorter);
       Glass* gp =
         dynamic_cast&lt;Glass*&gt;(*sorter);
       if(ap) alumBin.push_back(ap);
       else if(pp) paperBin.push_back(pp);
       else if(gp) glassBin.push_back(gp);
       sorter++;
     }
     sumValue(alumBin, cout);
     sumValue(paperBin, cout);
     sumValue(glassBin, cout);
     sumValue(bin, cout);
     purge(bin);
   } ///:~

   The nature of this problem is that the trash is thrown unclassified into a single bin, so the specific type information is "lost." But later the specific type information must be recovered to properly sort the trash, and so RTTI is used.
   We can do even better by using amap that associates pointers totype_info objects with a vector ofTrash pointers. Since a map requires an ordering predicate, we provide one namedTInfoLess that callstype_info::before( ). As we insertTrash pointers into the map, they are associated automatically with theirtype_info key.
   //: C08:Recycle2.cpp
   // A Trash Recycler
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;map&gt;
   #include&lt;typeinfo&gt;
   #include&lt;utility&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Trash {
     float wt;
   public:
     Trash(float wt) : wt(wt) {}
     virtual float value() const = 0;
     float weight() const { return wt; }
     virtual ~Trash() { cout&lt;&lt; "~Trash()\n"; }
   };
   class Aluminum : public Trash {
     static float val;
   public:
     Aluminum(float wt) : Trash(wt) {}
     float value() const { return val; }
     static void value(float newval) {
       val = newval;
     }
   };
   float Aluminum::val = 1.67;
   class Paper : public Trash {
     static float val;
   public:
     Paper(float wt) : Trash(wt) {}
     float value() const { return val; }
     static void value(float newval) {
       val = newval;
     }
   };
   float Paper::val = 0.10;
   class Glass : public Trash {
     static float val;
   public:
     Glass(float wt) : Trash(wt) {}
     float value() const { return val; }
     static void value(float newval) {
       val = newval;
     }
   };
   float Glass::val = 0.23;

   // Comparator for type_info pointers
   struct TInfoLess {
     bool operator()(const type_info* t1, const type_info* t2)
     const {
       return t1-&gt;before(*t2);
     }
   };
   typedef map&lt;const type_info*, vector&lt;Trash*&gt;, TInfoLess&gt;
     TrashMap;

   // Sums up the value of the Trash in a bin:
   void sumValue(const TrashMap::value_type& p, ostream& os) {
     vector&lt;Trash*&gt;::const_iterator tally = p.second.begin();
     float val = 0;
     while(tally != p.second.end()) {
       val += (*tally)-&gt;weight() * (*tally)-&gt;value();
       os&lt;&lt; "weight of "
         &lt;&lt; p.first-&gt;name()  // type_info::name()
         &lt;&lt; " = "&lt;&lt; (*tally)-&gt;weight()&lt;&lt; endl;
       tally++;
     }
     os&lt;&lt; "Total value = "&lt;&lt; val&lt;&lt; endl;
   }

   int main() {
     srand(time(0)); // Seed random number generator
     TrashMap bin;
     // Fill up the Trash bin:
     for(int i = 0; i&lt; 30; i++) {
       Trash* tp;
       switch(rand() % 3) {
         case 0 :
           tp = new Aluminum((rand() % 1000)/10.0);
           break;
         case 1 :
           tp = new Paper((rand() % 1000)/10.0);
           break;
         case 2 :
           tp = new Glass((rand() % 1000)/10.0);
           break;
       }
       bin[&typeid(*tp)].push_back(tp);
     }
     // Print sorted results
     for(TrashMap::iterator p = bin.begin();
         p != bin.end(); ++p) {
       sumValue(*p, cout);
       purge(p-&gt;second);
     }
   } ///:~

   We’ve modifiedsumValue( ) to calltype_info::name( ) directly, since thetype_info object is now available there as the first member of theTrashMap::value_type pair. This avoids the extra call totypeid to get the name of the type ofTrash being processed that was necessary in the previous version of this program.
   Mechanism and overhead of RTTI
   Typically, RTTI is implemented by placing an additional pointer in a class’s virtual function table. This pointer points to thetype_info structure for that particular type. The effect of atypeid( ) expression is quite simple: the virtual function table pointer fetches thetype_info pointer, and a reference to the resultingtype_info structure is produced. Since this is just a two-pointer dereference operation, it is a constant time operation.
   For adynamic_cast&lt;destination*&gt;(source_pointer), most cases are quite straightforward:source_pointer’s RTTI information is retrieved, and RTTI information for the typedestination* is fetched. A library routine then determines whethersource_pointer’s type is of typedestination* or a base class ofdestination*. The pointer it returns may be adjusted because of multiple inheritance if the base type isn’t the first base of the derived class. The situation is (of course) more complicated with multiple inheritance in which a base type may appear more than once in an inheritance hierarchy and virtual base classes are used.
   Because the library routine used fordynamic_cast must check through a list of base classes, the overhead fordynamic_cast may be higher thantypeid( ) (but of course you get different information, which may be essential to your solution), and it may take more time to discover a base class than a derived class. In addition,dynamic_cast allows you to compare any type to any other type; you aren’t restricted to comparing types within the same hierarchy. This adds extra overhead to the library routine used bydynamic_cast.
   Summary
   Although normally you upcast a pointer to a base class and then use the generic interface of that base class (via virtual functions), occasionally you get into a corner where things can be more effective if you know the dynamic type of the object pointed to by a base pointer, and that’s what RTTI provides. The most common misuse may come from the programmer who doesn’t understand virtual functions and uses RTTI to do type-check coding instead. The philosophy of C++ seems to be to provide you with powerful tools and guard for type violations and integrity, but if you want todeliberately misuse or get around a language feature, there’s nothing to stop you. Sometimes a slight burn is the fastest way to gain experience.
   Exercises
                1.             ModifyC16:AutoCounter.h in Volume 1 of this series so that it becomes a useful debugging tool. It will be used as a nested member of each class that you are interested in tracing. TurnAutoCounter into a template that takes the class name of the surrounding class as the template argument, and in all the error messages use RTTI to print out the name of the class.
           58.             Use RTTI to assist in program debugging by printing out the exact name of a template usingtypeid( ). Instantiate the template for various types and see what the results are.
           59.             Modify theInstrument hierarchy from Chapter 14 of Volume 1 by first copyingWind5.cpp to a new location. Now add a virtualClearSpitValve( ) function to theWind class, and redefine it for all the classes inherited fromWind. Instantiate aTStash to holdInstrument pointers, and fill it with various types ofInstrument objects created using thenew operator. Now use RTTI to move through the container looking for objects in classWind, or derived fromWind. Call theClearSpitValve( ) function for these objects. Notice that it would unpleasantly confuse the Instrument base class if it contained aClearSpitValve( ) function.
   9: Multiple inheritance
   The basic concept of multiple inheritance (MI) sounds simple enough: you create a new type by inheriting from more than one base class. The syntax is exactly what you’d expect, and as long as the inheritance diagrams are simple, MI can be simple as well.
   Or maybe not! MI can introduce a number of ambiguities and strange situations, which are covered in this chapter. But first, it will be helpful to get a little perspective on the subject.
   Perspective
   Before C++, the most successful object-oriented language was Smalltalk. Smalltalk was created from the ground up as an object-oriented language. It is often referred to aspure, whereas C++ is called ahybrid language because it supports multiple programming paradigms, not just the object-oriented paradigm. One of the design decisions made with Smalltalk was that all classes would be derived in a single hierarchy, rooted in a single base class (calledObject—this is the model for theobject-based hierarchy). You cannot create a new class in Smalltalk without deriving it from an existing class, which is why it takes a certain amount of time to become productive in Smalltalk: you must learn the class library before you can start making new classes. The Smalltalk class hierarchy is therefore a single monolithic tree.
   Classes in Smalltalk usually have a number of things in common, and they always havesome things in common (the characteristics and behaviors ofObject), so you almost never run into a situation in which you need to inherit from more than one base class. However, with C++ you can create as many hierarchy trees as you want. Therefore, for logical completeness the language must be able to combine more than one class at a time—thus the need for multiple inheritance.
   It was not a crystal clear, however, that programmers could not get by without multiple inheritance, and there was (and still is) a lot of disagreement about whether it is really essential in C++. MI was added in AT&Tcfront release 2.0 and was the first significant change to the language. Since then, a number of other features have been added (notably templates and exceptions) that change the way we think about programming and place MI in a much less important role. You can think of MI as a "minor" language feature that is seldom involved in your daily design decisions.
   One of the most pressing issues at the time that drove MI involved containers. Suppose you want to create a container that everyone can easily use. One approach is to usevoid* as the type inside the container. The Smalltalk approach, however, is to make a container that holdsObjects. (Remember thatObject is the base type of the entire Smalltalk hierarchy.) Because everything in Smalltalk is ultimately derived fromObject, any container that holdsObjects can hold anything.
   Now consider the situation in C++. Suppose vendorA creates an object-based hierarchy that includes a useful set of containers including one you want to use calledHolder. Now you come across vendorB’s class hierarchy that contains some other class that is important to you, aBitImage class, for example, that holds graphic images. The only way to make aHolder ofBitImages is to derive a new class from bothObject, so it can be held in theHolder, andBitImage:
    [Êàðòèíêà: img_7.png] 
   This was seen as an important reason for MI, and a number of class libraries were built on this model. However, as you saw in Chapter 5, the addition of templates has changed the way containers are created, so this situation isn’t a driving issue for MI.
   The other reason you may need MI is related to design. You can intentionally use MI to make a design more flexible or useful (or at least seemingly so). An example of this is in the originaliostream library design (which still persists in today’s template design, as you saw in Chapter 4):
    [Êàðòèíêà: img_8.png] 
   Bothistream andostream are useful classes by themselves, but they can also be derived from simultaneously by a class that combines both their characteristics and behaviors. The classios provides what is common to all stream classes, and so in this case MI is a code-factoring mechanism.
   Regardless of what motivates you to use MI, it’s harder to use than it might appear.
   Interface inheritance
   One use of multiple inheritance that is not controversial pertains tointerface inheritance. In C++, all inheritance isimplementation inheritance, because everything in a base class, interface and implementation, becomes part of a derived class. It is not possible to inherit only part of a class (the interface alone, say). As Chapter 14 of Volume 1 explains, private and protected inheritance make it possible to restrict access to members inherited from base classes when used by clients of a derived class object, but this doesn’t affect the derived class; it still contains all base class data and can access all non-private base class members.
   Interface inheritance, on the other hand, only adds member function declarations to a derived class interface and is not directly supported in C++. The usual technique to simulate interface inheritance in C++ is to derive from aninterface class, which is a class that contains only declarations (no data or function bodies). These declarations will be pure virtual functions, of course. Here is an example.
   //: C09:Interfaces.cpp
   // Multiple interface inheritance
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   class Printable {
   public:
     virtual ~Printable() {}
     virtual void print(ostream&) const = 0;
   };

   class Intable {
   public:
     virtual ~Intable() {}
     virtual int toInt() const = 0;
   };

   class Stringable {
   public:
     virtual ~Stringable() {}
     virtual string toString() const = 0;
   };

   class Able : public Printable,
                public Intable,
                public Stringable {
     int myData;
   public:
     Able(int x) {
       myData = x;
     }
     void print(ostream& os) const {
       os&lt;&lt; myData;
     }
     int toInt() const {
       return myData;
     }
     string toString() const {
       ostringstream os;
       os&lt;&lt; myData;
       return os.str();
     }
   };

   void testPrintable(const Printable& p) {
     p.print(cout);
     cout&lt;&lt; endl;
   }
   void testIntable(const Intable& n) {
     int i = n.toInt() + 1;
     cout&lt;&lt; i&lt;&lt; endl;
   }
   void testStringable(const Stringable& s) {
     string buf = s.toString() + "th";
     cout&lt;&lt; buf&lt;&lt; endl;
   }

   int main() {
     Able a(7);
     testPrintable(a);
     testIntable(a);
     testStringable(a);
   } ///:~

   Only pure virtual functions are inherited from classesPrintable,Intable, andStringable, which must therefore be implemented in derived class overrides, which theAble class provides. This givesAble objects multiple "is-a" relationships. The objecta can act as aPrintable object because its classAble derives publicly fromPrintable and provides an implementation forprint( ). The test functions have no need to know the most-derived type of their parameter; they just need an object that is substitutable for their parameter’s type.
   As usual, a template solution is more compact:
   //: C09:Interfaces2.cpp
   // Implicit interface inheritance via templates
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;
   using namespace std;

   class Able {
     int myData;
   public:
     Able(int x) {
       myData = x;
     }
     void print(ostream& os) const {
       os&lt;&lt; myData;
     }
     int toInt() const {
       return myData;
     }
     string toString() const {
       ostringstream os;
       os&lt;&lt; myData;
       return os.str();
     }
   };

   template&lt;class Printable&gt;
   void testPrintable(const Printable& p) {
     p.print(cout);
     cout&lt;&lt; endl;
   }
   template&lt;class Intable&gt;
   void testIntable(const Intable& n) {
     int i = n.toInt() + 1;
     cout&lt;&lt; i&lt;&lt; endl;
   }
   template&lt;class Stringable&gt;
   void testStringable(const Stringable& s) {
     string buf = s.toString() + "th";
     cout&lt;&lt; buf&lt;&lt; endl;
   }

   int main() {
     Able a(7);
     testPrintable(a);
     testIntable(a);
     testStringable(a);
   } ///:~

   The namesPrintable,Intable, andStringable are now just template parameters that assume the existence of the operations indicated in their respective contexts. Some people are more comfortable with the first version, because the type names guarantee by inheritance that the expected interfaces are implemented. Others are content with the fact that if the operations required by the test functions are not satisfied by their template type arguments, the error is still caught at compile time. The latter approach is technically a "weaker" form of type checking than the former (inheritance) approach, but the effect on the programmer (and the program) is the same. This is one form of weak typing that is acceptable to many of today’s C++ programmers.
   Implementation inheritance
   As we stated earlier, C++ provides only implementation inheritance, meaning that you inherit everything from all your base classes. This can be a good thing, of course, because it frees you from having to implementeverything in the derived class, as we had to do with the interface inheritance examples earlier. A common use of multiple inheritance involves usingmixin classes, which are classes not intended to be instantiated independently, but exist to add capabilities to other classes through inheritance.
   As an example, suppose we are clients of a class that supports access to a database. We will likely only have a header file available (which is part of the point we are about to make), but for illustration, assume the following, simple implementation of aDatabase class:
   //: C09:Database.h
   // A prototypical resource class
   #ifndef DATABASE_H
   #define DATABASE_H
   #include&lt;iostream&gt;
   #include&lt;stdexcept&gt;
   #include&lt;string&gt;
   using std::cout;
   using std::string;
   using std::runtime_error;

   struct DatabaseError : runtime_error {
     DatabaseError(const string& msg) : runtime_error(msg)
     {}
   };

   class Database {
   public:
     Database(const string& dbStr) : dbid(dbStr) {}
     virtual ~Database(){}
     void open() throw(DatabaseError) {
       cout&lt;&lt; "connected to "&lt;&lt; dbid&lt;&lt; '\n';
     }
     void close() {
       cout&lt;&lt; dbid&lt;&lt; " closed\n";
     }
     //Other database functions...
   private:
     string dbid;
   };
   #endif ///:~

   We’re leaving out actual database functionality (storing, retrieving, and so on), but that’s actually not important here. Using this class requires a database connection string and that you callDatabase::open( ) to connect andDatabase::close( ) to disconnect:
   //: C09:UseDatabase.cpp
   #include "Database.h"
   int main() {
     Database db("MyDatabase");
     db.open();
     // Use other db functions...
     db.close();
   }
   /* Output:
   connected to MyDatabase
   MyDatabase closed
   */ ///:~

   In a typical client-server situation, a client will have multiple objects sharing a connection to a database. It is important that the database eventually be closed, but only after access to it is no longer required. It is common to encapsulate this behavior through a class that tracks the number of client entities using the database connection and to automatically terminate the connection when that count goes to zero. To add reference counting to theDatabase class, we create a mixin class namedCountable and mix it into theDatabase class by creating a new class,DBConnection, through multiple inheritance. Here’s theCountable mixin class:
   //: C09:Countable.h
   // A "mixin" class
   #ifndef COUNTABLE_H
   #define COUNTABLE_H
   #include&lt;cassert&gt;

   class Countable {
   public:
     long attach() { return ++count; }
     long detach() {
       return (--count&gt; 0) ? count : (delete this, 0);
     }
     long refCount() const { return count; }
   protected:
     Countable() { count = 0; }
     virtual ~Countable() { assert(count == 0); }
   private:
     long count;
   };
   #endif ///:~

   It is evident that this is not a standalone class because its constructor isprotected; it therefore requires a friend or a derived class to use it. It is important that the destructor is virtual, of course, because it is called only from thedelete this statement indetach( ), and we of course want derived objects to be completely destroyed.[107] TheDBConnection class derives from bothDatabase andCountable and provides a staticcreate( ) function that initializes itsCountable subobject. (This is an example of the Factory Method design pattern, discussed in the next chapter.)
   //: C09:DBConnection.h
   // Uses a "mixin" class
   #ifndef DBCONNECTION_H
   #define DBCONNECTION_H
   #include "Countable.h"
   #include "Database.h"
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using std::string;

   class DBConnection : public Database, public Countable {
   public:
     static DBConnection* create(const string& dbStr)
     throw(DatabaseError) {
       DBConnection* con = new DBConnection(dbStr);
       con-&gt;attach();
       assert(con-&gt;refCount() == 1);
       return con;
     }
   // Other added functionality as desired...
   protected:
     DBConnection(const string& dbStr) throw(DatabaseError)
     : Database(dbStr) {
       open();
     }
     ~DBConnection() {
       close();
     }
   private:
     // Disallow copy
     DBConnection(const DBConnection&);
     DBConnection& operator=(const DBConnection&);
   };
   #endif ///:~

   We now have a reference-counted database connection without modifying theDatabase class, and we can safely assume that it will not be surreptitiously terminated. The opening and closing is done using the Resource Acquisition Is Initialization idiom (RAII) mentioned in Chapter 1 via theDBConnection constructor and destructor. This makes using aDBConnection easy to use, as the following program shows.
   //: C09:UseDatabase2.cpp
   // Tests the Countable "mixin" class
   #include&lt;cassert&gt;
   #include "DBConnection.h"

   class DBClient {
   public:
     DBClient(DBConnection* dbCon) {
       db = dbCon;
       db-&gt;attach();
     }
     ~DBClient() {
       db-&gt;detach();
     }
     // Other database requests using db…
   private:
     DBConnection* db;
   };

   int main() {
     DBConnection* db = DBConnection::create("MyDatabase");
     assert(db-&gt;refCount() == 1);
     DBClient c1(db);
     assert(db-&gt;refCount() == 2);
     DBClient c2(db);
     assert(db-&gt;refCount() == 3);
     // Use database, then release attach from original create
     db-&gt;detach();
     assert(db-&gt;refCount() == 2);
   } ///:~

   The call toDBConnection::create( ) callsattach( ), so when we’re finished, we must explicitly calldetach( ) to release the original hold on the connection. Note that theDBClient class also uses RAII to manage its use of the connection. When the program terminates, the destructors for the twoDBClient objects will decrement the reference count (by callingdetach( ), whichDBConnection inherited fromCountable), and the database connection will be closed when the count reaches zero after the objectc1 is destroyed. (This is because ofCountable’s virtual destructor, as we explained earlier.)
   A template approach is commonly used for mixin inheritance, allowing the user to specify at compile time which flavor of mixin is desired. This way you can use different reference-counting approaches without explicitly definingDBConnection twice. Here’s how it’s done.
   //: C09:DBConnection2.h
   // A parameterized mixin
   #ifndef DBCONNECTION_H
   #define DBCONNECTION_H
   #include "Database.h"
   #include&lt;cassert&gt;
   #include&lt;string&gt;
   using std::string;

   template&lt;class Counter&gt;
   class DBConnection : public Database, public Counter {
   public:
     static DBConnection* create(const string& dbStr)
     throw(DatabaseError) {
       DBConnection* con = new DBConnection(dbStr);
       con-&gt;attach();
       assert(con-&gt;refCount() == 1);
       return con;
     }
   // Other added functionality as desired...
   protected:
     DBConnection(const string& dbStr) throw(DatabaseError)
     : Database(dbStr) {
       open();
     }
     ~DBConnection() {
       close();
     }
   private:
     // Disallow copy
     DBConnection(const DBConnection&);
     DBConnection& operator=(const DBConnection&);
   };
   #endif ///:~

   The only change here is the template prefix to the class definition (and renamingCountable toCounter for clarity). We could also make the database class a template parameter (had we multiple database access classes to choose from), but it is not a mixin, per se, since it is a standalone class. The following example uses the originalCountable as theCounter mixin type, but we could use any type that implements the appropriate interface (attach( ),detach( ), and so on).
   //: C09:UseDatabase3.cpp
   // Tests a parameterized "mixin" class
   #include&lt;cassert&gt;
   #include "Countable.h"
   #include "DBConnection2.h"

   class DBClient {
   public:
     DBClient(DBConnection&lt;Countable&gt;* dbCon) {
       db = dbCon;
       db-&gt;attach();
     }
     ~DBClient() {
       db-&gt;detach();
     }
   private:
     DBConnection&lt;Countable&gt;* db;
   };

   int main() {
     DBConnection&lt;Countable&gt;* db =
       DBConnection&lt;Countable&gt;::create("MyDatabase");
     assert(db-&gt;refCount() == 1);
     DBClient c1(db);
     assert(db-&gt;refCount() == 2);
     DBClient c2(db);
     assert(db-&gt;refCount() == 3);
     db-&gt;detach();
     assert(db-&gt;refCount() == 2);
   } ///:~

   The general pattern for multiple parameterized mixins is simply:
   template&lt;class Mixin1, class Mixin2,… , class MixinK&gt;
   class Subject : public Mixin1,
    public Mixin2,
    …
                   public MixinK {..};

   Duplicate subobjects
   When you inherit from a base class, you get a copy of all the data members of that base class in your derived class. The following program shows how multiple base subobjects might be laid out in memory.[108] 
   //: C09:Offset.cpp
   // Illustrates layout of subobjects with MI
   #include&lt;iostream&gt;
   using namespace std;

   class A {
     int x;
   };

   class B {
     int y;
   };

   class C : public A, public B {
     int z;
   };

   int main() {
     cout&lt;&lt; "sizeof(A) == "&lt;&lt; sizeof(A)&lt;&lt; endl;
     cout&lt;&lt; "sizeof(B) == "&lt;&lt; sizeof(B)&lt;&lt; endl;
     cout&lt;&lt; "sizeof(C) == "&lt;&lt; sizeof(C)&lt;&lt; endl;
     C c;
     cout&lt;&lt; "&c == "&lt;&lt;&c&lt;&lt; endl;
     A* ap =&c;
     B* bp =&c;
     cout&lt;&lt; "ap == "&lt;&lt; static_cast&lt;void*&gt;(ap)&lt;&lt; endl;
     cout&lt;&lt; "bp == "&lt;&lt; static_cast&lt;void*&gt;(bp)&lt;&lt; endl;
     C* cp = static_cast&lt;C*&gt;(bp);
     cout&lt;&lt; "cp == "&lt;&lt; static_cast&lt;void*&gt;(cp)&lt;&lt; endl;
     cout&lt;&lt; "bp == cp? "&lt;&lt; boolalpha&lt;&lt; (bp == cp)&lt;&lt; endl;
     cp = 0;
     bp = cp;
     cout&lt;&lt; bp&lt;&lt; endl;
   }
   /* Output:
   sizeof(A) == 4
   sizeof(B) == 4
   sizeof(C) == 12
   &c == 1245052
   ap == 1245052
   bp == 1245056
   cp == 1245052
   bp == cp? true
   0
   */ ///:~

   As you can see, theB portion of the objectc is offset 4 bytes from the beginning of the entire object, suggesting the following layout:
    [Êàðòèíêà: img_9.png] 
   The objectc begins with it’sA subobject, then theB portion, and finally the data from the complete typeC itself. Since aC is-anA and is-aB, it is possible to upcast to either base type. When upcasting to an A, the resulting pointer points to the A portion, which happens to be at the beginning of the C object, so the addressap is the same as the expression&c. When upcasting to aB, however, the resulting pointer must point to where theB subobject actually resides, because class B knows nothing about classC (or classA, for that matter). In other words, the object pointed to bybp must be able to behave as a standaloneB object (except for any required polymorphic behavior, of course).
   When castingbp back to aC*, since the original object was aC in the first place, the location where theB subobject resides is known, so the pointer is adjusted back to the original address of the complete object. Ifbp had been pointing to a standaloneB object instead of aC object in the first place, the cast would be illegal.[109] Furthermore, in the comparisonbp == cp,cp is implicitly converted to aB*, since that is the only way to make the comparison meaningful in general (that is, upcasting is always allowed), hence thetrue result. So when converting back and forth between subobjects and complete types, the appropriate offset is applied.
   The null pointer requires special handling, obviously, since blindly subtracting an offset when converting to or from aB subobject will result in an invalid address if the pointer was zero to start with. For this reason, when casting to or from aB*, the compiler generates logic to check first to see if the pointer is zero. If it isn’t, it applies the offset; otherwise, it leaves it as zero.
   With the syntax we’ve seen so far, if you have multiple base classes, and if those base classes in turn have a common base class, you will have two copies of the top-level base, as you can see in the following example.
   //: C09:Duplicate.cpp
   // Shows duplicate subobjects
   #include&lt;iostream&gt;
   using namespace std;

   class Top {
     int x;
   public:
     Top(int n) { x = n; }
   };

   class Left : public Top {
     int y;
   public:
     Left(int m, int n) : Top(m) { y = n; }
   };

   class Right : public Top {
     int z;
   public:
     Right(int m, int n) : Top(m) { z = n; }
   };

   class Bottom : public Left, public Right {
     int w;
   public:
     Bottom(int i, int j, int k, int m)
     : Left(i, k), Right(j, k) { w = m; }
   };

   int main() {
     Bottom b(1, 2, 3, 4);
     cout&lt;&lt; sizeof b&lt;&lt; endl; // 20
   } ///:~

   Since the size ofb is 20 bytes,[110] there are five integers altogether in a completeBottom object. A typical class diagram for this scenario usually appears as:
    [Êàðòèíêà: img_10.png] 
   This is the so-called "diamond inheritance", but in this case it would be better rendered as:
    [Êàðòèíêà: img_11.png] 
   The awkwardness of this design surfaces in the constructor for theBottom class in the previous code. The user thinks that only four integers are required, but which arguments should be passed to the two parameters thatLeft andRight require? Although this design is not inherently "wrong," it is usually not what an application calls for. It also presents a problem when trying to convert a pointer to aBottom object to a pointer toTop. As we showed earlier, the address may need to be adjusted, depending on where the subobject resides within the complete object, but in this case there aretwoTop subobjects to choose from. The compiler doesn’t know which to choose, so such an upcast is ambiguous and therefore not allowed. The same reasoning explains why aBottom object would not be able to call a function that is only defined inTop. If such a functionTop::f( ) existed, callingb.f( ) above would need to refer to aTop subobject as a context in which to execute, and there are two to choose between.
   Virtual base classes
   What we usually want in such cases istrue diamond inheritance, in which a singleTop object is shared by bothLeft andRight subobjects within a completeBottom object, which is what the first class diagram depicts. This is achieved by makingTop avirtual base class ofLeft andRight:
   //: C09:VirtualBase.cpp
   // Shows a shared subobject via a virtual base
   #include&lt;iostream&gt;
   using namespace std;

   class Top {
   protected:
     int x;
   public:
     Top(int n) { x = n; }
     virtual ~Top(){}
     friend ostream&
     operator&lt;&lt;(ostream& os, const Top& t) {
       return os&lt;&lt; t.x;
     }
   };

   class Left : virtual public Top {
   protected:
     int y;
   public:
     Left(int m, int n) : Top(m) { y = n; }
   };

   class Right : virtual public Top {
   protected:
     int z;
   public:
     Right(int m, int n) : Top(m) { z = n; }
   };

   class Bottom : public Left, public Right {
     int w;
   public:
     Bottom(int i, int j, int k, int m)
     : Top(i), Left(0, j), Right(0, k) { w = m; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Bottom& b) {
       return os&lt;&lt; b.x&lt;&lt; ','&lt;&lt; b.y&lt;&lt; ','&lt;&lt; b.z
        &lt;&lt; ','&lt;&lt; b.w;
     }
   };

   int main() {
     Bottom b(1, 2, 3, 4);
     cout&lt;&lt; sizeof b&lt;&lt; endl;
     cout&lt;&lt; b&lt;&lt; endl;
     cout&lt;&lt; static_cast&lt;void*&gt;(&b)&lt;&lt; endl;
     Top* p = static_cast&lt;Top*&gt;(&b);
     cout&lt;&lt; *p&lt;&lt; endl;
     cout&lt;&lt; static_cast&lt;void*&gt;(p)&lt;&lt; endl;
     cout&lt;&lt; dynamic_cast&lt;void*&gt;(p)&lt;&lt; endl;
   } ///:~

   Each virtual base of a given type refers to the same object, no matter where it appears in the hierarchy.[111] This means that when aBottom object is instantiated, the object layout may look something like this:
    [Êàðòèíêà: img_12.png] 

   TheLeft andRight subobjects each have a pointer (or some conceptual equivalent) to the sharedTop subobject, and all references to that subobject inLeft andRight member functions will go through those these pointers.[112] In this case, there is no ambiguity when upcasting from aBottom to aTop object, since there is only oneTop object to convert to.
   The output of the previous program is as follows:
   36
   1,2,3,4
   1245032
   1
   1245060
   1245032

   The addresses printed suggest that this particular implementation does indeed store theTop subobject at the end of the complete object (although it’s not really important where it goes). The result of adynamic_cast tovoid* always resolves to the address of the complete object.
   We made theTop destructor virtual so we could apply thedynamic_cast operator. If you remove that virtual destructor (and thedynamic_cast statement so the program will compile), the size ofBottom decreases to 24 bytes. That seems to be a decrease equivalent to the size of three pointers. What gives?
   It’s important not to take these numbers too literally. Other compilers we use manage only to increase the size by four bytes when the virtual constructor is added. Not being compiler writers, we can’t tell you their secrets. We can tell you, however, that with multiple inheritance, a derived object must behave as if it has multiple VPTRs, one for each of its direct base classes that also have virtual functions. It’s as simple as that. Compilers can make whatever optimizations its authors can invent, but the behavior must be the same.
   Certainly the strangest thing in the previous code is the initializer forTop in theBottom constructor. Normally one doesn’t worry about initializing subobjects beyond direct base classes, since all classes take care of initializing their own bases. There are, however, multiple paths fromBottom toTop, so relying on the intermediate classesLeft andRight to pass along the necessary initialization data results in an ambiguity (whose responsibility is it?)! For this reason, it is always the responsibility of themost derived class to initialize a virtual base. But what about the expressions in theLeft andRight constructors that also initializeTop? They are certainly necessary when creating standaloneLeft orRight objects, but must beignored when aBottom object is created (hence the zeros in their initializers in theBottom constructor—any values in those slots are ignored when theLeft andRight constructors execute in the context of aBottom object). The compiler takes care of all this for you, but it’s important to understand where the responsibility lies. Always make sure thatall concrete (nonabstract) classes in a multiple inheritance hierarchy are aware of any virtual bases and initialize them appropriately.
   These rules of responsibility apply not only to initialization but to all operations that span the class hierarchy. Consider the stream inserter in the previous code. We made the data protected so we could "cheat" and access inherited data inoperator&lt;&lt;(ostream&, const Bottom&). It usually makes more sense to assign the work of printing each subobject to its corresponding class and have the derived class call its base class functions as needed. What would happen if we tried that withoperator&lt;&lt;( ), as the following code illustrates?
   //: C09:VirtualBase2.cpp
   // Shows how not to implement operator&lt;&lt;
   #include&lt;iostream&gt;
   using namespace std;

   class Top {
     int x;
   public:
     Top(int n) { x = n; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Top& t) {
       return os&lt;&lt; t.x;
     }
   };

   class Left : virtual public Top {
     int y;
   public:
     Left(int m, int n) : Top(m) { y = n; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Left& l) {
       return os&lt;&lt; static_cast&lt;const Top&&gt;(l)&lt;&lt; ','&lt;&lt; l.y;
     }
   };

   class Right : virtual public Top {
     int z;
   public:
     Right(int m, int n) : Top(m) { z = n; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Right& r) {
       return os&lt;&lt; static_cast&lt;const Top&&gt;(r)&lt;&lt; ','&lt;&lt; r.z;
     }
   };

   class Bottom : public Left, public Right {
     int w;
   public:
     Bottom(int i, int j, int k, int m)
     : Top(i), Left(0, j), Right(0, k) { w = m; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Bottom& b) {
       return os&lt;&lt; static_cast&lt;const Left&&gt;(b)
        &lt;&lt; ','&lt;&lt; static_cast&lt;const Right&&gt;(b)
        &lt;&lt; ','&lt;&lt; b.w;
     }
   };

   int main() {
     Bottom b(1, 2, 3, 4);
     cout&lt;&lt; b&lt;&lt; endl;  // 1,2,1,3,4
   } ///:~

   You can’t just blindly share the responsibility upward in the usual fashion because theLeft andRight stream inserters each call theTop inserter, and again there will be duplication of data. Instead you need to mimic what the compiler automatically does with initialization. One solution is to provide special functions in the classes that know about the virtual base class, which ignore the virtual base when printing (leaving the job to the most derived class):
   //: C09:VirtualBase3.cpp
   // A correct stream inserter
   #include&lt;iostream&gt;
   using namespace std;

   class Top {
     int x;
   public:
     Top(int n) { x = n; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Top& t) {
       return os&lt;&lt; t.x;
     }
   };

   class Left : virtual public Top {
     int y;
   protected:
     void specialPrint(ostream& os) const {
       // Only print Left's part
       os&lt;&lt; ','&lt;&lt; y;
     }
   public:
     Left(int m, int n) : Top(m) { y = n; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Left& l) {
       return os&lt;&lt; static_cast&lt;const Top&&gt;(l)&lt;&lt; ','&lt;&lt; l.y;
     }
   };

   class Right : virtual public Top {
     int z;
   protected:
     void specialPrint(ostream& os) const {
       // Only print Right's part
       os&lt;&lt; ','&lt;&lt; z;
     }
   public:
     Right(int m, int n) : Top(m) { z = n; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Right& r) {
       return os&lt;&lt; static_cast&lt;const Top&&gt;(r)&lt;&lt; ','&lt;&lt; r.z;
     }
   };

   class Bottom : public Left, public Right {
     int w;
   public:
     Bottom(int i, int j, int k, int m)
     : Top(i), Left(0, j), Right(0, k) { w = m; }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Bottom& b) {
       os&lt;&lt; static_cast&lt;const Top&&gt;(b);
       b.Left::specialPrint(os);
       b.Right::specialPrint(os);
       return os&lt;&lt; ','&lt;&lt; b.w;
     }
   };

   int main() {
     Bottom b(1, 2, 3, 4);
     cout&lt;&lt; b&lt;&lt; endl;  // 1,2,3,4
   } ///:~

   ThespecialPrint( ) functions areprotected since they will be called only byBottom. They print only their own data and ignore theirTop subobject, because theBottom inserter is in control when these functions are called. TheBottom inserter must know about the virtual base, just as aBottom constructor needs to. This same reasoning applies to assignment operators in a hierarchy with a virtual base, as well as to any function, member or not, that wants to share the work throughout all classes in the hierarchy.
   Having discussed virtual base classes, we can now illustrate the "full story" of object initialization. Since virtual bases give rise to shared subobjects, it makes sense that they should be available before the sharing takes place. Therefore, the order of initialization of subobjects follows these rules (recursively, as needed, of course):
   3.All virtual base class subobjects are initialized, in top-down, left-to-right order according to where they appear in class definitions.
   4.Non-virtual base classes are then initialized in the usual order.
   5.All member objects are initialized in declaration order.
   6.The complete object’s constructor executes.
   The following program illustrates this behavior.
   //: C09:VirtInit.cpp
   // Illustrates initialization order with virtual bases
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   class M {
   public:
     M(const string& s) {
       cout&lt;&lt; "M "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class A{
     M m;
   public:
     A(const string& s) : m("in A") {
        cout&lt;&lt; "A "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class B
   {
     M m;
   public:
     B(const string& s) : m("in B")  {
       cout&lt;&lt; "B "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class C
   {
     M m;
   public:
     C(const string& s) : m("in C")  {
       cout&lt;&lt; "C "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class D
   {
     M m;
   public:
     D(const string& s) : m("in D") {
       cout&lt;&lt; "D "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class E : public A, virtual public B, virtual public C
   {
     M m;
   public:
     E(const string& s)
     : A("from E"), B("from E"), C("from E"), m("in E") {
       cout&lt;&lt; "E "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class F : virtual public B, virtual public C, public D
   {
     M m;
   public:
     F(const string& s)
     : B("from F"), C("from F"), D("from F"), m("in F") {
       cout&lt;&lt; "F "&lt;&lt; s&lt;&lt; endl;
     }
   };

   class G : public E, public F
   {
     M m;
   public:
     G(const string& s)
     : B("from G"), C("from G"), E("from G"),
       F("from G"), m("in G") {
       cout&lt;&lt; "G "&lt;&lt; s&lt;&lt; endl;
     }
   };

   int main() {
     G g("from main");
   } ///:~

   The classes in this code can be represented by the following diagram:
    [Êàðòèíêà: img_13.png] 

   Each class has an embedded member of typeM. Note that only four derivations are virtual:E fromB andC, andF fromB andC. The output of this program is
   M in B
   B from G
   M in C
   C from G
   M in A
   A from E
   M in E
   E from G
   M in D
   D from F
   M in F
   F from G
   M in G
   G from main

   The initialization ofg requires itsE andF part to first be initialized, but theB andC subobjects are initialized first, because they are virtual bases, and are initialized fromG’s initializer,G being the most-derived class. The classB has no base classes, so according to rule 3, its member objectm is initialized, then its constructor prints "B fromG", and similarly for theC subject ofE. TheE subobject requiresA,B, andC subobjects. SinceB andC have already been initialized, theA subobject of theE subobject is initialized next, and then theE subobject itself. The same scenario repeats forg’sF subobject, but without duplicating the initialization of the virtual bases.
   Name lookup issues
   The ambiguities we have illustrated with subobjects apply, of course, to any names, including function names. If a class has multiple direct base classes that share member functions of the same name, and you call one of those member functions, the compiler doesn’t know which one to choose. The following sample program would report such an error.
   // C09:AmbiguousName.cpp
   class Top {};

   class Left : virtual public Top {
   public:
      void f(){}
   };

   class Right : virtual public Top {
   public:
      void f(){}
   };

   class Bottom : public Left, public Right {};

   int main() {
      Bottom b;
      b.f();     // error here
   }

   The classBottom has inherited two functions of the same name (the signature is irrelevant, since name lookup occurs before overload resolution), and there is no way to choose between them. The usual technique to disambiguate the call is to qualify the function call with the base class name:
   //: C09:BreakTie.cpp
   class Top {};

   class Left : virtual public Top {
   public:
      void f(){}
   };

   class Right : virtual public Top {
   public:
      void f(){}
   };

   class Bottom : public Left, public Right {
   public:
     using Left::f;
   };

   int main() {
      Bottom b;
      b.f();     // calls Left::f()
   } ///:~

   The nameLeft::f is now found in the scope ofBottom, so the nameRight::f is not even considered. Of course, if you want to introduce extra functionality beyond whatLeft::f( ) provides, you would implement aBottom::f( ) function that callsLeft::f( ), in addition to other things.
   Functions with the same name occurring in different branches of a hierarchy often conflict. The following hierarchy has no such problem:
   //: C09:Dominance.cpp
   class Top {
   public:
     virtual void f() {}
   };

   class Left : virtual public Top {
   public:
      void f(){}
   };

   class Right : virtual public Top {
   };

   class Bottom : public Left, public Right {};

   int main() {
      Bottom b;
      b.f(); // calls Left::f()
   } ///:~

   In this case, there is no explicitRight::f( ), soLeft::f( ), being the most derived, is chosen. Why? Well, pretend thatRight did not exist, giving the single-inheritance hierarchyTop&lt;= Left&lt;= Bottom. You would certainly expectLeft::f( ) to be the function called by the expressionb.f( ), because of normal scope rules (a derived class is considered a nested scope of a base class). In general, a nameA::f is said todominate the nameB::f ifA derives fromB, directly or indirectly, or in other words, ifA is "more derived" in the hierarchy thanB.[113] To summarize: in choosing between two functions with the same name, one of which dominates the other, the compiler chooses the one that dominates. If there is no dominant function, there is an ambiguity.
    The following program further illustrates the dominance principle.
   //: C09:Dominance2.cpp
   #include&lt;iostream&gt;
   using namespace std;

   class A {
   public:
      virtual void f() {cout&lt;&lt; "A::f\n";}
   };

   class B : virtual public A {
   public:
      void f() {cout&lt;&lt; "B::f\n";}
   };

   class C : public B {};
   class D : public C, virtual public A {};

   int main()
   {
      B* p = new D;
      p-&gt;f();  // calls B::f()
   } ///:~

   The class diagram for this hierarchy is as follows.
    [Êàðòèíêà: img_14.png] 

   The classA is a (direct, in this case) base class forB, and so the nameB::f dominatesA::f.
   Avoiding MI
   When the question of whether to use multiple inheritance comes up, ask at least two questions:
   1.Do you need to show the public interfaces of both these classes through your new type, or could one class be contained within the other, with only some of its interface exposed in the new class?
   2.Do you need to upcast to both of the base classes? (This applies when you have more than two base classes, of course.)
   If you can answer "yes" to either question, you can avoid using MI and should probably do so.
   One situation to watch for is when one class needs to be upcast only as a function argument. In that case, the class can be embedded and an automatic type conversion operator provided in your new class to produce a reference to the embedded object. Any time you use an object of your new class as an argument to a function that expects the embedded object, the type conversion operator is used.[114] However, type conversion can’t be used for normal member selection; that requires inheritance.
   Extending an interface
   One of the best uses for multiple inheritance involves code that’s out of your control. Suppose you’ve acquired a library that consists of a header file and compiled member functions, but no source code for member functions. This library is a class hierarchy with virtual functions, and it contains some global functions that take pointers to the base class of the library; that is, it uses the library objects polymorphically. Now suppose you build an application around this library and write your own code that uses the base class polymorphically.
   Later in the development of the project or sometime during its maintenance, you discover that the base-class interface provided by the vendor doesn’t provide what you need: a function may be non-virtual and you need it to be virtual, or a virtual function is completely missing in the interface, but essential to the solution of your problem. Multiple inheritance is the perfect solution.
   For example, here’s the header file for a library you acquire:
   //: C09:Vendor.h
   // Vendor-supplied class header
   // You only get this& the compiled Vendor.obj
   #ifndef VENDOR_H
   #define VENDOR_H

   class Vendor {
   public:
     virtual void v() const;
     void f() const;
     ~Vendor();
   };

   class Vendor1 : public Vendor {
   public:
     void v() const;
     void f() const;
     ~Vendor1();
   };

   void A(const Vendor&);
   void B(const Vendor&);
   // Etc.
   #endif // VENDOR_H ///:~

   Assume the library is much bigger, with more derived classes and a larger interface. Notice that it also includes the functionsA( ) andB( ), which take a base reference and treat it polymorphically. Here’s the implementation file for the library:
   //: C09:Vendor.cpp {O}
   // Implementation of VENDOR.H
   // This is compiled and unavailable to you
   #include&lt;iostream&gt;
   #include "Vendor.h"
   using namespace std;

   void Vendor::v() const {
     cout&lt;&lt; "Vendor::v()\n";
   }
   void Vendor::f() const {
     cout&lt;&lt; "Vendor::f()\n";
   }
   Vendor::~Vendor() {
     cout&lt;&lt; "~Vendor()\n";
   }
   void Vendor1::v() const {
     cout&lt;&lt; "Vendor1::v()\n";
   }
   void Vendor1::f() const {
     cout&lt;&lt; "Vendor1::f()\n";
   }
   Vendor1::~Vendor1() {
     cout&lt;&lt; "~Vendor1()\n";
   }
   void A(const Vendor& V) {
     // ...
     V.v();
     V.f();
     //..
   }
   void B(const Vendor& V) {
     // ...
     V.v();
     V.f();
     //..
   } ///:~

   In your project, this source code is unavailable to you. Instead, you get a compiled file asVendor.obj orVendor.lib (or with the equivalent file suffixes for your system).
   The problem occurs in the use of this library. First, the destructor isn’t virtual. In addition,f( ) was not made virtual; we assume the library creator decided it wouldn’t need to be. And you discover that the interface to the base class is missing a function essential to the solution of your problem. Also suppose you’ve already written a fair amount of code using the existing interface (not to mention the functionsA( ) andB( ), which are out of your control), and you don’t want to change it.
   To repair the problem, create your own class interface and multiply inherit a new set of derived classes from your interface and from the existing classes:
   //: C09:Paste.cpp
   //{L} Vendor
   // Fixing a mess with MI
   #include&lt;iostream&gt;
   #include "Vendor.h"
   using namespace std;

   class MyBase { // Repair Vendor interface
   public:
     virtual void v() const = 0;
     virtual void f() const = 0;
     // New interface function:
     virtual void g() const = 0;
     virtual ~MyBase() { cout&lt;&lt; "~MyBase()\n"; }
   };

   class Paste1 : public MyBase, public Vendor1 {
   public:
     void v() const {
       cout&lt;&lt; "Paste1::v()\n";
       Vendor1::v();
     }
     void f() const {
       cout&lt;&lt; "Paste1::f()\n";
       Vendor1::f();
     }
     void g() const {
       cout&lt;&lt; "Paste1::g()\n";
     }
     ~Paste1() { cout&lt;&lt; "~Paste1()\n"; }
   };

   int main() {
     Paste1& p1p = *new Paste1;
     MyBase& mp = p1p; // Upcast
     cout&lt;&lt; "calling f()\n";
     mp.f();  // Right behavior
     cout&lt;&lt; "calling g()\n";
     mp.g(); // New behavior
     cout&lt;&lt; "calling A(p1p)\n";
     A(p1p); // Same old behavior
     cout&lt;&lt; "calling B(p1p)\n";
     B(p1p);  // Same old behavior
     cout&lt;&lt; "delete mp\n";
     // Deleting a reference to a heap object:
     delete&mp; // Right behavior
   } ///:~

   InMyBase (which doesnot use MI), bothf( ) and the destructor are now virtual, and a new virtual functiong( ) is added to the interface. Now each of the derived classes in the original library must be re-created, mixing in the new interface with MI. The functionsPaste1::v( ) andPaste1::f( )need to call only the original base-class versions of their functions. But now, if you upcast toMyBase as inmain( )
   MyBase* mp = p1p; // Upcast
   any function calls made throughmp will be polymorphic, includingdelete. Also, the new interface functiong( ) can be called throughmp. Here’s the output of the program:
   calling f()
   Paste1::f()
   Vendor1::f()
   calling g()
   Paste1::g()
   calling A(p1p)
   Paste1::v()
   Vendor1::v()
   Vendor::f()
   calling B(p1p)
   Paste1::v()
   Vendor1::v()
   Vendor::f()
   delete mp
   ~Paste1()
   ~Vendor1()
   ~Vendor()
   ~MyBase()

   The original library functionsA( ) andB( ) still work the same (assuming the newv( ) calls its base-class version). The destructor is now virtual and exhibits the correct behavior.
   Although this is a messy example, it does occur in practice, and it’s a good demonstration of where multiple inheritance is clearly necessary: You must be able to upcast to both base classes.
   Summary
   One reason MI exists in C++ is that it is a hybrid language and couldn’t enforce a single monolithic class hierarchy the way Smalltalk and Java do. Instead, C++ allows many inheritance trees to be formed, so sometimes you may need to combine the interfaces from two or more trees into a new class.
   If no "diamonds" appear in your class hierarchy, MI is fairly simple (although identical function signatures in base classes must still be resolved). If a diamond appears, you may want to eliminate duplicate subobjects by introducing virtual base classes. This not only adds confusion, but the underlying representation becomes more complex and less efficient.
   Multiple inheritance has been called the "goto of the’90s."[115] This seems appropriate because, like a goto, MI is best avoided in normal programming, but can occasionally be very useful. It’s a "minor" but more advanced feature of C++, designed to solve problems that arise in special situations. If you find yourself using it often, you might want to take alook at your reasoning. A good Occam’s Razor is to ask, "Must I upcast to all the base classes?" If not, your life will be easier if you embed instances of all the classes youdon’t need to upcast to.
   Exercises
   These exercises will take you step by step through the complexities of MI.
                1.             Create a base classX with a single constructor that takes anint argument and a member functionf( ), which takes no arguments and returnsvoid. Now deriveY andZ fromX, creating constructors for each of them that take a singleint argument. Now deriveA fromY andZ. Create an object of classA, and callf( ) for that object. Fix the problem with explicit disambiguation.
           60.             Starting with the results of exercise 1, create a pointer to anX calledpx, and assign to it the address of the object of typeA you created before. Fix the problem using a virtual base class. Now fixX so you no longer have to call the constructor forX insideA.
            61.             Starting with the results of exercise 2, remove the explicit disambiguation forf( ), and see if you can callf( ) throughpx. Trace it to see which function gets called. Fix the problem so the correct function will be called in a class hierarchy.

   10: Design patterns
   "… describe a problem which occurs over and over again in our environment, and then describe the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice" —Christopher Alexander
   This chapter introduces the important and yet nontraditional "patterns" approach to program design.
   In recent times, the most important step forward in object-oriented design is probably the "design patterns" movement, chronicled inDesign Patterns, by Gamma, Helm, Johnson& Vlissides (Addison-Wesley, 1995).[116] That book shows 23 solutions to particular classes of problems. In this chapter, we discuss the basic concepts of design patterns and provide code examples that illustrate selected patterns. This should whet your appetite for readingDesign Patterns (a source of what has now become an essential, almost mandatory vocabulary for object-oriented programming).
   The pattern concept
   Initially, you can think of a pattern as an especially clever and insightful way to solve a particular class of problems. That is, it looks like a lot of people have worked out all the angles of a problem and have come up with the most general, flexible solution for that type of problem. The problem could be one you have seen and solved before, but your solution probably didn’t have the kind of completeness you’ll see embodied in a pattern. Furthermore, the pattern exists independently of any particular implementation and, indeed, can be implemented in a number of ways.
   Although they’re called "design patterns," they really aren’t tied to the realm of design. A pattern seems to stand apart from the traditional way of thinking about analysis, design, and implementation. Instead, a pattern embodies a complete idea within a program, and thus it can sometimes also span the analysis phase and high-level design phase. Because a pattern has a direct implementation in code, you might not expect it to show up before low-level design or implementation (and in fact you might not realize that you need a particular pattern until you get to those phases).
   The basic concept of a pattern can also be seen as the basic concept of program design in general: adding layers of abstraction. Whenever you abstract something, you’re isolating particular details, and one of the most compelling motivations for this is toseparate things that change from things that stay the same. Another way to put this is that once you find some part of your program that’s likely to change for one reason or another, you’ll want to keep those changes from propagating other modifications throughout your code. Not only does this make the code easier to maintain, but it also renders code easier to read and understand (which invariably results in lowered costs overtime).
   The most difficult part of developing an elegant and maintainable design is often discovering what we call "the vector of change." (Here, "vector" refers to the maximum gradient as understood in the sciences, and not a container class.) This means finding the most important thing that changes in your system or, put another way, discovering where your greatest cost is. Once you discover the vector of change, you have the focal point around which to structure your design.
   So the goal of design patterns is to isolate changes in your code; to put it another way:discover what changes and encapsulate it. If you look at it this way, you’ve been seeing some design patterns already in this book. For example, inheritance could be thought of as a design pattern (albeit one implemented by the compiler). It allows you to express differences in behavior (that’s the thing that changes) in objects that all have the same interface (that’s what stays the same). Composition could also be considered a pattern, since it allows you to change—dynamically or statically—the objects that implement your class, and thus the way that class works. Normally, however, features that are directly supported by a programming language have notbeen classified as design patterns.
   You’ve also already seen another pattern that appears inDesign Patterns: theiterator. This is the fundamental tool used in the design of the STL, described earlier in this book. The iterator hides the particular implementation of the container as you’re stepping through and selecting the elements one by one. Iterators allow you to write generic code that performs an operation on all the elements in a range without regard to the container that holds the range. Thus, your generic code can be used with any container that can produce iterators.
   The Singleton
   Possibly the simplest design pattern is theSingleton, which is a way to provide one and only one instance of a class. For example, if a class controls a Singleton resource, you only want to allow one instance of that class. The following program shows how to implement a Singleton object in C++:
   //: C10:SingletonPattern.cpp
   #include&lt;iostream&gt;
   using namespace std;

   class Singleton {
     static Singleton s;
     int i;
     Singleton(int x) : i(x) { }
     Singleton& operator=(Singleton&);  // Disallowed
     Singleton(const Singleton&);       // Disallowed
   public:
     static Singleton& instance() {
       return s;
     }
     int getValue() { return i; }
     void setValue(int x) { i = x; }
   };

   Singleton Singleton::s(47);

   int main() {
     Singleton& s = Singleton::instance();
     cout&lt;&lt; s.getValue()&lt;&lt; endl;
     Singleton& s2 = Singleton::instance();
     s2.setValue(9);
     cout&lt;&lt; s.getValue()&lt;&lt; endl;
   } ///:~

   The key to creating a Singleton is to prevent the client programmer from having any control over the lifetime of the object. To do this, declare all constructorsprivate, and prevent the compiler from implicitly generating any constructors. Note that the copy constructor and assignment operator are declared private to prevent any sort of copies being made.
   You must also decide how you’re going to create the object. Here, it’s created statically, but you can also wait until the client programmer asks for one and create it on demand. This is calledlazy initialization, and it only makes sense if your object is expensive to create and if it might not always be needed.
   If you return a pointer instead of a reference, the user could inadvertently delete the pointer, so the implementation above is considered safest. In any case, the object should be stored privately.
   You provide access through public member functions. Here,instance( ) produces a reference to theSingleton object. The rest of the interface (getValue( ) andsetValue( )) is the regular class interface.
   Note that you aren’t restricted to creating only one object. This technique easily supports the creation of a limited pool of objects. In that situation, however, you can be confronted with the problem of sharing objects in the pool. If this is an issue, you can create a solution involving a check-out and check-inof the shared objects.
   Variations on Singleton
   Anystatic member object inside a class is an expression of Singleton: one and only one will be made. So in a sense, the language has direct support for the idea; we certainly use it on a regular basis. However, a problem is associated withstatic objects (member or not), and that’s the order of initialization, as described in Volume 1 of this book. If onestatic object depends on another, it’s important that the objects are initialized in the correct order.
   In Volume 1, you were shown how to control initialization order by defining a static object inside a function. This delays the initialization of the object until the first time the function is called. If the function returns a reference to the static object, it gives you the effect of a Singleton while removing much of the worry of static initialization. For example, suppose you want to create a log file upon the first call to a function that returns a reference to that log file. This header file will do the trick:
   //: C10:LogFile.h
   #ifndef LOGFILE_H
   #define LOGFILE_H
   #include&lt;fstream&gt;

   std::ofstream& logfile();

   #endif // LOGFILE_H ///:~

   The implementationmust not be inlined, because that would mean that the whole function, including the static object definition within, could be duplicated in any translation unit where it’s included, which violates C++’s one-definition rule.[117] This would most certainly foil the attempts to control the order of initialization (but potentially in a subtle and hard-to-detect fashion). So the implementation must be separate:
   //: C10:LogFile.cpp {O}
   #include "LogFile.h"
   std::ofstream& logfile() {
     static std::ofstream log("Logfile.log");
     return log;
   } ///:~

   Now thelog object will not be initialized until the first timelogfile( ) is called. So if you create a function:
   //: C10:UseLog1.h
   #ifndef USELOG1_H
   #define USELOG1_H
   void f();
   #endif // USELOG1_H ///:~

   that useslogfile() in its implementation:
   //: C10:UseLog1.cpp {O}
   #include "UseLog1.h"
   #include "LogFile.h"
   void f() {
     logfile()&lt;&lt; __FILE__&lt;&lt; std::endl;
   } ///:~

   And you uselogfile()again in another file:
   //: C10:UseLog2.cpp
   //{L} LogFile UseLog1
   #include "UseLog1.h"
   #include "LogFile.h"
   using namespace std;
   void g() {
     logfile()&lt;&lt; __FILE__&lt;&lt; endl;
   }

   int main() {
     f();
     g();
   } ///:~

   thelogobject doesn’t get created until the first call tof( ).
   You can easily combine the creation of the static object inside a member function with the Singleton class.SingletonPattern.cpp can be modified to use this approach:[118] 
   //: C10:SingletonPattern2.cpp
   // Meyers’ Singleton
   #include&lt;iostream&gt;
   using namespace std;

   class Singleton {
     int i;
     Singleton(int x) : i(x) { }
     void operator=(Singleton&);
     Singleton(const Singleton&);
   public:
     static Singleton& instance() {
       static Singleton s(47);
       return s;
     }
     int getValue() { return i; }
     void setValue(int x) { i = x; }
   };

   int main() {
     Singleton& s = Singleton::instance();
     cout&lt;&lt; s.getValue()&lt;&lt; endl;
     Singleton& s2 = Singleton::instance();
     s2.setValue(9);
     cout&lt;&lt; s.getValue()&lt;&lt; endl;
   } ///:~

   An especially interesting case occurs if two Singletons depend on each other, like this:
   //: C10:FunctionStaticSingleton.cpp
   class Singleton1 {
     Singleton1() {}
   public:
     static Singleton1& ref() {
       static Singleton1 single;
       return single;
     }
   };

   class Singleton2 {
     Singleton1& s1;
     Singleton2(Singleton1& s) : s1(s) {}
   public:
     static Singleton2& ref() {
       static Singleton2 single(Singleton1::ref());
       return single;
     }
     Singleton1& f() { return s1; }
   };

   int main() {
     Singleton1& s1 = Singleton2::ref().f();
   } ///:~

   WhenSingleton2::ref( ) is called, it causes its soleSingleton2 object to be created. In the process of this creation,Singleton1::ref( ) is called, and that causes the soleSingleton1 object to be created. Because this technique doesn’t rely on the order of linking or loading, the programmer has much better control over initialization, leading to fewer problems.
   Yet another variation on Singleton allows you to separate the "Singleton-ness" of an object from its implementation. This is achieved through templates, using the Curiously Recurring Template Pattern mentioned in Chapter 5.
   //: C10:CuriousSingleton.cpp
   // Separates a class from its Singleton-ness (almost)
   #include&lt;iostream&gt;
   using namespace std;

   template&lt;class T&gt;
   class Singleton {
   public:
     static T& instance() {
       static T theInstance;
       return theInstance;
     }
   protected:
     Singleton() {}
     virtual ~Singleton() {}
   private:
     Singleton(const Singleton&);
     Singleton& operator=(const Singleton&);
   };

   // A sample class to be made into a Singleton
   class MyClass : public Singleton&lt;MyClass&gt; {
     int x;
   protected:
     friend class Singleton&lt;MyClass&gt;;
     MyClass(){x = 0;}
   public:
     void setValue(int n) { x = n; }
     int getValue() const { return x; }
   };

   int main() {
     MyClass& m = MyClass::instance();
     cout&lt;&lt; m.getValue()&lt;&lt; endl;
     m.setValue(1);
     cout&lt;&lt; m.getValue()&lt;&lt; endl;
   } ///:~

   MyClass is made a Singleton by:
   1.       Making its constructor private or protected.
   2.      MakingSingleton&lt;MyClass&gt; a friend.
   3.      DerivingMyClass fromSingleton&lt;MyClass&gt;.
   The self-referencing in step 3 may sound implausible, but as we explained in Chapter 5, it works because there is only a static data dependency on the template argument in theSingleton template. In other words, the code for the classSingleton&lt;MyClass&gt; can be instantiated by the compiler because it is not dependent on the size ofMyClass. It’s only later, whenSingleton&lt;MyClass&gt;::instance( ) is first called, that the size ofMyClass is needed, and of course by then compilation ofMyClass is complete and its size is known.[119] 
   It’s interesting how intricate implementing such a simple pattern as Singleton can be. We haven’t even addressed issues of thread safety, and yet many pages have elapsed since the beginning of this section. The last thing we wish to say about Singleton is that it should be used sparingly. True Singleton objects arise rarely, and the last thing a Singleton should be used for is to replace a global variable.[120] 
   Classifying patterns
   Design Patterns discusses 23 patterns, classified under three purposes (all of which revolve around the particular aspect that can vary):
   1.Creational: how an object can be created. This often involves isolating the details of object creation so your code isn’t dependent on what types of objects there are and thus doesn’t have to be changed when you add a new type of object. The aforementioned Singleton is classified as a creational pattern, and later in this chapter you’ll see examples of Factory Method.
   2.Structural: designing objects to satisfy particular project constraints. These affect the way objects are connected with other objects to ensure that changes in the system don’t require changes to those connections.
   3.Behavioral: objects that handle particular types of actions within a program. These encapsulate processes that you want to perform, such as interpreting a language, fulfilling a request, moving through a sequence (as in an iterator), or implementing an algorithm. This chapter contains examples of the Observer and the Visitor patterns.
   Design Patterns includes a section on each of its 23 patterns along with one or more examples for each, typically in C++ but sometimes in Smalltalk. This book will not repeat all the details of the patterns shown inDesign Patterns since that book stands on its own and should be studied separately. The catalog and examples provided here are intended to rapidly give you a grasp of the patterns, so you can get a decent feel for what patterns are about and why they are so important.
   Features, idioms, patterns
   Work is continuing beyond what is in the GoF book, of course; hence, there are more patterns and a more refined process on defining design patterns in general.[121] This is important because it is not easy to identify new patterns or to properly describe them. There is some confusion in the popular literature on what a design pattern is, for example. Patterns are not trivial nor are they typically represented by features that are built into a programming language. Constructors and destructors, for example, could be called the "guaranteed initialization and cleanup design pattern." These are important and essential constructs, but they’re routine language constructs and are not rich enough to be considered a design pattern.
   Another non-example comes from various forms of aggregation. Aggregation is a completely fundamental principle in object-oriented programming: you make objects out of other objects. Yet sometimes this idea is erroneously classified as a pattern. This is unfortunate because it pollutes the idea of the design pattern and suggests that anything that surprises you the first time you see it should be made into a design pattern.
   Yet another misguided example is found in the Java language; the designers of the JavaBeans specification decided to refer to the simple "get/set" naming convention as a design pattern (for example,getInfo( ) returns anInfo property andsetInfo( ) changes it). This is just a commonplace naming convention and in no way constitutes a design pattern.
   Building complex objects
   The class that will be created in the next example models a bicycle that can have a choice of parts, according to its type (mountain bike, touring bike, or racing bike). This is called theBuilder design pattern. A builder class is associated with each flavor of bicycle, each of which implements the interface specified in the abstract classBicycleBuilder. A separate class,BicycleTechnician, uses a concreteBicycleBuilder object to construct aBicycle object.
   //: C10:Bicycle.h
   // Defines classes to build bicycles
   // Illustrates the Builder Design Pattern
   #ifndef BICYCLE_H
   #define BICYCLE_H

   #include&lt;iosfwd&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;

   class BicyclePart {
   public:
     enum BPart {FRAME, WHEEL, SEAT, DERAILLEUR,
       HANDLEBAR, SPROCKET, RACK, SHOCK, NPARTS};
     BicyclePart(BPart);
     friend std::ostream&
     operator&lt;&lt;(std::ostream&, const BicyclePart&);
   private:
     BPart id;
     static std::string names[NPARTS];
   };

   class Bicycle {
   public:
     ~Bicycle();
     void addPart(BicyclePart*);
     friend std::ostream&
     operator&lt;&lt;(std::ostream&, const Bicycle&);
   private:
     std::vector&lt;BicyclePart*&gt; parts;
   };

   class BicycleBuilder {
   public:
     BicycleBuilder() {
       product = 0;
     }
     void createProduct() {
       product = new Bicycle;
     }
     virtual void buildFrame() = 0;
     virtual void buildWheel() = 0;
     virtual void buildSeat() = 0;
     virtual void buildDerailleur() = 0;
     virtual void buildHandlebar() = 0;
     virtual void buildSprocket() = 0;
     virtual void buildRack() = 0;
     virtual void buildShock() = 0;
     virtual std::string getBikeName() const = 0;
     Bicycle* getProduct() {
       Bicycle* temp = product;
       product = 0;  // relinquish product
       return temp;
     }
   protected:
     Bicycle* product;
   };

   class MountainBikeBuilder : public BicycleBuilder {
   public:
     void buildFrame();
     void buildWheel();
     void buildSeat();
     void buildDerailleur();
     void buildHandlebar();
     void buildSprocket();
     void buildRack();
     void buildShock();
     std::string getBikeName() const {
       return "MountainBike";
     }
   };

   class TouringBikeBuilder : public BicycleBuilder {
   public:
     void buildFrame();
     void buildWheel();
     void buildSeat();
     void buildDerailleur();
     void buildHandlebar();
     void buildSprocket();
     void buildRack();
     void buildShock();
     std::string getBikeName() const {
       return "TouringBike";
     }
   };

   class RacingBikeBuilder : public BicycleBuilder {
   public:
     void buildFrame();
     void buildWheel();
     void buildSeat();
     void buildDerailleur();
     void buildHandlebar();
     void buildSprocket();
     void buildRack();
     void buildShock();
     std::string getBikeName() const {
       return "RacingBike";
     }
   };

   class BicycleTechnician {
   public:
     BicycleTechnician() {
       builder = 0;
     }
     void setBuilder(BicycleBuilder* b) {
       builder = b;
     }
     void construct();
   private:
     BicycleBuilder* builder;
   };

   #endif ///:~

   ABicycle holds a vector of pointers toBicyclePart representing the parts used to construct the bicycle. To initiate the construction of a bicycle, a technician callsBicycleBuilder::createproduct( ) on a derivedBicycleBuilder object. TheBicycleTechnician::construct( ) function calls all the functions in theBicycleBuilder interface (since it doesn’t know what type of concrete builder it has). The concrete builder classes omit (via empty function bodies) those actions that do not apply to the type of bicycle they build, as you can see in the following implementation file.
   //: C10:Bicycle.cpp {O}
   // Defines classes to build bicycles
   // Illustrates the Builder Design Pattern
   #include&lt;cassert&gt;
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include "Bicycle.h"
   #include "../purge.h"
   using namespace std;

   // BicyclePart implementation
   BicyclePart::BicyclePart(BPart bp) {
     id = bp;
   }
   ostream&
   operator&lt;&lt;(ostream& os, const BicyclePart& bp) {
     return os&lt;&lt; bp.names[bp.id];
   }
   std::string BicyclePart::names[NPARTS] = {
     "Frame", "Wheel", "Seat", "Derailleur",
     "Handlebar", "Sprocket", "Rack", "Shock"};

   // Bicycle implementation
   Bicycle::~Bicycle() {
     purge(parts);
   }
   void Bicycle::addPart(BicyclePart* bp) {
     parts.push_back(bp);
   }
   ostream&
   operator&lt;&lt;(ostream& os, const Bicycle& b) {
     os&lt;&lt; "{ ";
     for (size_t i = 0; i&lt; b.parts.size(); ++i)
       os&lt;&lt; *b.parts[i]&lt;&lt; ' ';
     return os&lt;&lt; '}';
   }

   // MountainBikeBuilder implementation
   void MountainBikeBuilder::buildFrame() {
     product-&gt;addPart(new BicyclePart(BicyclePart::FRAME));
   }
   void MountainBikeBuilder::buildWheel() {
     product-&gt;addPart(new BicyclePart(BicyclePart::WHEEL));
   }
   void MountainBikeBuilder::buildSeat() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SEAT));
   }
   void MountainBikeBuilder::buildDerailleur() {
     product-&gt;addPart(
       new BicyclePart(BicyclePart::DERAILLEUR));
   }
   void MountainBikeBuilder::buildHandlebar() {
     product-&gt;addPart(
       new BicyclePart(BicyclePart::HANDLEBAR));
   }
   void MountainBikeBuilder::buildSprocket() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SPROCKET));
   }
   void MountainBikeBuilder::buildRack() {}
   void MountainBikeBuilder::buildShock() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SHOCK));
   }

   // TouringBikeBuilder implementation
   void TouringBikeBuilder::buildFrame() {
     product-&gt;addPart(new BicyclePart(BicyclePart::FRAME));
   }
   void TouringBikeBuilder::buildWheel() {
     product-&gt;addPart(new BicyclePart(BicyclePart::WHEEL));
   }
   void TouringBikeBuilder::buildSeat() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SEAT));
   }
   void TouringBikeBuilder::buildDerailleur() {
     product-&gt;addPart(new BicyclePart(BicyclePart::DERAILLEUR));
   }
   void TouringBikeBuilder::buildHandlebar() {
     product-&gt;addPart(
       new BicyclePart(BicyclePart::HANDLEBAR));
   }
   void TouringBikeBuilder::buildSprocket() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SPROCKET));
   }
   void TouringBikeBuilder::buildRack() {
     product-&gt;addPart(new BicyclePart(BicyclePart::RACK));
   }
   void TouringBikeBuilder::buildShock() {}

   // RacingBikeBuilder implementation
   void RacingBikeBuilder::buildFrame() {
     product-&gt;addPart(new BicyclePart(BicyclePart::FRAME));
   }
   void RacingBikeBuilder::buildWheel() {
     product-&gt;addPart(new BicyclePart(BicyclePart::WHEEL));
   }
   void RacingBikeBuilder::buildSeat() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SEAT));
   }
   void RacingBikeBuilder::buildDerailleur() {}
   void RacingBikeBuilder::buildHandlebar() {
     product-&gt;addPart(
       new BicyclePart(BicyclePart::HANDLEBAR));
   }
   void RacingBikeBuilder::buildSprocket() {
     product-&gt;addPart(new BicyclePart(BicyclePart::SPROCKET));
   }
   void RacingBikeBuilder::buildRack() {}
   void RacingBikeBuilder::buildShock() {}

   // BicycleTechnician implementation
   void BicycleTechnician::construct()
   {
     assert(builder);
     builder-&gt;createProduct();
     builder-&gt;buildFrame();
     builder-&gt;buildWheel();
     builder-&gt;buildSeat();
     builder-&gt;buildDerailleur();
     builder-&gt;buildHandlebar();
     builder-&gt;buildSprocket();
     builder-&gt;buildRack();
     builder-&gt;buildShock();
   }; ///:~

   TheBicycle stream inserter calls the corresponding inserter for eachBicyclePart, and that prints its type name so that you can see what aBicycle contains. The power of this pattern is that it separates the algorithm for assembling parts into a complete product from the parts themselves and allows different algorithms for different products via different implementations of a common interface. Here is a sample program, along with the resulting output, that uses these classes.
   //: C10:BuildBicycles.cpp
   //{L} Bicycle
   #include&lt;cstddef&gt;
   #include&lt;iostream&gt;
   #include&lt;map&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   #include "Bicycle.h"
   using namespace std;

   // Constructs a bike via a concrete builder
   Bicycle*
   buildMeABike(BicycleTechnician& t, BicycleBuilder* builder) {
     t.setBuilder(builder);
     t.construct();
     Bicycle* b = builder-&gt;getProduct();
     cout&lt;&lt; "Built a "&lt;&lt; builder-&gt;getBikeName()&lt;&lt; endl;
     return b;
   }

   int main() {
     // Create an order for some bicycles
     map&lt;string, size_t&gt; order;
     order["mountain"] = 2;
     order["touring"] = 1;
     order["racing"] = 3;

     // Build bikes
     vector&lt;Bicycle*&gt; bikes;
     BicycleBuilder* m = new MountainBikeBuilder;
     BicycleBuilder* t = new TouringBikeBuilder;
     BicycleBuilder* r = new RacingBikeBuilder;
     BicycleTechnician tech;
     map&lt;string, size_t&gt;::iterator it = order.begin();
     while (it != order.end()) {
       BicycleBuilder* builder;
       if (it-&gt;first == "mountain")
         builder = m;
       else if (it-&gt;first == "touring")
         builder = t;
       else if (it-&gt;first == "racing")
         builder = r;
       for (size_t i = 0; i&lt; it-&gt;second; ++i)
         bikes.push_back(buildMeABike(tech, builder));
       ++it;
     }
     delete m;
     delete t;
     delete r;

     // Display inventory
     for (size_t i = 0; i&lt; bikes.size(); ++i)
       cout&lt;&lt; "Bicycle: "&lt;&lt; *bikes[i]&lt;&lt; endl;
     purge(bikes);
   }

   /* Output:
   Built a MountainBike
   Built a MountainBike
   Built a RacingBike
   Built a RacingBike
   Built a RacingBike
   Built a TouringBike
   Bicycle: { Frame Wheel Seat Derailleur Handlebar Sprocket Shock }
   Bicycle: { Frame Wheel Seat Derailleur Handlebar Sprocket Shock }
   Bicycle: { Frame Wheel Seat Handlebar Sprocket }
   Bicycle: { Frame Wheel Seat Handlebar Sprocket }
   Bicycle: { Frame Wheel Seat Handlebar Sprocket }
   Bicycle: { Frame Wheel Seat Derailleur Handlebar Sprocket Rack } */ ///:~

   Factories: encapsulating object creation
   When you discover that you need to add new types to a system, the most sensible first step is to use polymorphism to create a common interface to those new types. This separates the rest of the code in your system from the knowledge of the specific types that you are adding. New types can be added without disturbing existing code… or so it seems. At first it would appear that you need to change the code in such a design only in the place where you inherit a new type, but this is not quite true. You must still create an object of your new type, and at the point of creation you must specify the exact constructor to use. Thus, if the code that creates objects is distributed throughout your application, you have the same problem when adding new types—you must still chase down all the points of your code where type matters. It happens to be thecreation of the type that matters in this case rather than theuse of the type (which is taken care of by polymorphism), but the effect is the same: adding a new type can cause problems.
   The solution is to force the creation of objects to occur through a commonfactory rather than to allow the creational code to be spread throughout your system. If all the code in your program must go through this factory whenever it needs to create one of your objects, all you must do when you add a new object is modify the factory. This design is a variation of the pattern commonly known asFactory Method. Since every object-oriented program creates objects, and since it’s likely you will extend your program by adding new types, factories may be the most useful of all design patterns.
   As an example, let’s revisit theShape system. One approach to implementing a factory is to define astatic member function in the base class:
   //: C10:ShapeFactory1.cpp
   #include&lt;iostream&gt;
   #include&lt;stdexcept&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Shape {
   public:
     virtual void draw() = 0;
     virtual void erase() = 0;
     virtual ~Shape() {}
     class BadShapeCreation : public logic_error {
     public:
       BadShapeCreation(string type)
         : logic_error("Cannot create type " + type)
       {}
     };
     static Shape* factory(const string& type)
       throw(BadShapeCreation);
   };

   class Circle : public Shape {
     Circle() {} // Private constructor
     friend class Shape;
   public:
     void draw() { cout&lt;&lt; "Circle::draw\n"; }
     void erase() { cout&lt;&lt; "Circle::erase\n"; }
     ~Circle() { cout&lt;&lt; "Circle::~Circle\n"; }
   };

   class Square : public Shape {
     Square() {}
     friend class Shape;
   public:
     void draw() { cout&lt;&lt; "Square::draw\n"; }
     void erase() { cout&lt;&lt; "Square::erase\n"; }
     ~Square() { cout&lt;&lt; "Square::~Square\n"; }
   };

   Shape* Shape::factory(const string& type)
     throw(Shape::BadShapeCreation) {
     if(type == "Circle") return new Circle;
     if(type == "Square") return new Square;
     throw BadShapeCreation(type);
   }

   char* shlist[] = { "Circle", "Square", "Square",
     "Circle", "Circle", "Circle", "Square", "" };

   int main() {
     vector&lt;Shape*&gt; shapes;
     try {
       for(char** cp = shlist; **cp; cp++)
         shapes.push_back(Shape::factory(*cp));
     } catch(Shape::BadShapeCreation e) {
       cout&lt;&lt; e.what()&lt;&lt; endl;
       purge(shapes);
       return 1;
     }
     for(size_t i = 0; i&lt; shapes.size(); i++) {
       shapes[i]-&gt;draw();
       shapes[i]-&gt;erase();
     }
     purge(shapes);
   } ///:~

   Thefactory( ) function takes an argument that allows it to determine what type ofShape to create; it happens to be astring in this case, but it could be any set of data. Thefactory( ) is now the only other code in the system that needs to be changed when a new type ofShapeis added. (The initialization data for the objects will presumably come from somewhere outside the system and will not be a hard-coded array as in the previous example.)
   To ensure that the creation can only happen in thefactory( ), the constructors for the specific types ofShape are madeprivate, andShape is declared afriend so thatfactory( ) has access to the constructors. (You could also declare onlyShape::factory( ) to be afriend, but it seems reasonably harmless to declare the entire base class as afriend.)
   Polymorphic factories
   Thestatic factory( ) member function in the previous example forces all the creation operations to be focused in one spot, so that’s the only place you need to change the code. This is certainly a reasonable solution, as it nicely encapsulates the process of creating objects. However,Design Patterns emphasizes that the reason for the Factory Method pattern is so that different types of factories can be derived from the basic factory. Factory Method is in fact a special type of polymorphic factory. However,Design Patterns does not provide an example, but instead just repeats the example used for theAbstract Factory. Here isShapeFactory1.cpp modified so the Factory Methods are in a separate class as virtual functions:
   //: C10:ShapeFactory2.cpp
   // Polymorphic Factory Methods
   #include&lt;iostream&gt;
   #include&lt;map&gt;
   #include&lt;stdexcept&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Shape {
   public:
     virtual void draw() = 0;
     virtual void erase() = 0;
     virtual ~Shape() {}
   };

   class ShapeFactory {
     virtual Shape* create() = 0;
     static map&lt;string, ShapeFactory*&gt; factories;
   public:
     virtual ~ShapeFactory() {}
     friend class ShapeFactoryInitializer;
     class BadShapeCreation : public logic_error {
     public:
       BadShapeCreation(string type)
         : logic_error("Cannot create type " + type)
       {}
     };
     static Shape*
     createShape(const string& id) throw(BadShapeCreation){
       if(factories.find(id) != factories.end())
         return factories[id]-&gt;create();
       else
         throw BadShapeCreation(id);
     }
   };

   // Define the static object:
   map&lt;string, ShapeFactory*&gt;
     ShapeFactory::factories;

   class Circle : public Shape {
     Circle() {} // Private constructor
   public:
     void draw() { cout&lt;&lt; "Circle::draw\n"; }
     void erase() { cout&lt;&lt; "Circle::erase\n"; }
     ~Circle() { cout&lt;&lt; "Circle::~Circle\n"; }
   private:
     friend class ShapeFactoryInitializer;
     class Factory;
     friend class Factory;
     class Factory : public ShapeFactory {
     public:
       Shape* create() { return new Circle; }
       friend class ShapeFactoryInitializer;
     };
   };

   class Square : public Shape {
     Square() {}
   public:
     void draw() { cout&lt;&lt; "Square::draw\n"; }
     void erase() { cout&lt;&lt; "Square::erase\n"; }
     ~Square() { cout&lt;&lt; "Square::~Square\n"; }
   private:
     friend class ShapeFactoryInitializer;
     class Factory;
     friend class Factory;
     class Factory : public ShapeFactory {
     public:
       Shape* create() { return new Square; }
       friend class ShapeFactoryInitializer;
     };
   };

   // Singleton to initialize the ShapeFactory:
   class ShapeFactoryInitializer {
     static ShapeFactoryInitializer si;
     ShapeFactoryInitializer() {
       ShapeFactory::factories["Circle"] =
         new Circle::Factory;
       ShapeFactory::factories["Square"] =
         new Square::Factory;
     }
     ~ShapeFactoryInitializer() {
       delete ShapeFactory::factories["Circle"];
       delete ShapeFactory::factories["Square"];
     }
   };

   // Static member definition:
   ShapeFactoryInitializer
     ShapeFactoryInitializer::si;

   char* shlist[] = { "Circle", "Square", "Square",
     "Circle", "Circle", "Circle", "Square", "" };

   int main() {
     vector&lt;Shape*&gt; shapes;
     try {
       for(char** cp = shlist; **cp; cp++)
         shapes.push_back(
           ShapeFactory::createShape(*cp));
     } catch(ShapeFactory::BadShapeCreation e) {
       cout&lt;&lt; e.what()&lt;&lt; endl;
       return 1;
     }
     for(size_t i = 0; i&lt; shapes.size(); i++) {
       shapes[i]-&gt;draw();
       shapes[i]-&gt;erase();
     }
     purge(shapes);
   } ///:~

   Now the Factory Method appears in its own class,ShapeFactory, as thevirtual create( ). This is a private member function, which means it cannot be called directly but can be overridden. The subclasses ofShape must each create their own subclasses ofShapeFactory and override thecreate( ) member function to create an object of their own type. These factories are private, so that they are only accessible from the main Factory Method. This way, all client code must go through the Factory Method in order to create objects.
   The actual creation of shapes is performed by callingShapeFactory::createShape( ), which is a static member function that uses themap inShapeFactory to find the appropriate factory object based on an identifier that you pass it. The factory is immediately used to create the shape object, but you could imagine a more complex problem in which the appropriate factory object is returned and then used by the caller to create an object in a more sophisticated way. However, it seems that much of the time you don’t need the intricacies of the polymorphic Factory Method, and a single static member function in the base class (as shown inShapeFactory1.cpp) will work fine.
   Notice that theShapeFactory must be initialized by loading itsmap with factory objects, which takes place in the SingletonShapeFactoryInitializer. So to add a new type to this design you must define the type, create a factory, and modifyShapeFactoryInitializer so that an instance of your factory is inserted in the map. This extra complexity again suggests the use of astatic Factory Method if you don’t need to create individual factory objects.
   Abstract factories
   The Abstract Factory pattern looks like the factory objects we’ve seen previously, with not one but several Factory Methods. Each of the Factory Methods creates a different kind of object. The idea is that when you create the factory object, you decide how all the objects created by that factory will be used. The example inDesign Patterns implements portability across various graphical user interfaces (GUIs): you create a factory object appropriate to the GUI that you’re working with, and from then on when you ask it for a menu, a button, a slider, and so on, it will automatically create the appropriate version of that item for the GUI. Thus, you’re able to isolate, in one place, the effect of changing from one GUI to another.
   As another example, suppose you are creating a general-purpose gaming environment and you want to be able to support different types of games. Here’s how it might look using an Abstract Factory:
   //: C10:AbstractFactory.cpp
   // A gaming environment
   #include&lt;iostream&gt;
   using namespace std;

   class Obstacle {
   public:
     virtual void action() = 0;
   };

   class Player {
   public:
     virtual void interactWith(Obstacle*) = 0;
   };

   class Kitty: public Player {
     virtual void interactWith(Obstacle* ob) {
       cout&lt;&lt; "Kitty has encountered a ";
       ob-&gt;action();
     }
   };

   class KungFuGuy: public Player {
     virtual void interactWith(Obstacle* ob) {
       cout&lt;&lt; "KungFuGuy now battles against a ";
       ob-&gt;action();
     }
   };

   class Puzzle: public Obstacle {
   public:
     void action() { cout&lt;&lt; "Puzzle\n"; }
   };

   class NastyWeapon: public Obstacle {
   public:
     void action() { cout&lt;&lt; "NastyWeapon\n"; }
   };

   // The abstract factory:
   class GameElementFactory {
   public:
     virtual Player* makePlayer() = 0;
     virtual Obstacle* makeObstacle() = 0;
   };

   // Concrete factories:
   class KittiesAndPuzzles :
     public GameElementFactory {
   public:
     virtual Player* makePlayer() {
       return new Kitty;
     }
     virtual Obstacle* makeObstacle() {
       return new Puzzle;
     }
   };

   class KillAndDismember :
     public GameElementFactory {
   public:
     virtual Player* makePlayer() {
       return new KungFuGuy;
     }
     virtual Obstacle* makeObstacle() {
       return new NastyWeapon;
     }
   };

   class GameEnvironment {
     GameElementFactory* gef;
     Player* p;
     Obstacle* ob;
   public:
     GameEnvironment(GameElementFactory* factory) :
       gef(factory), p(factory-&gt;makePlayer()),
       ob(factory-&gt;makeObstacle()) {}
     void play() {
       p-&gt;interactWith(ob);
     }
     ~GameEnvironment() {
       delete p;
       delete ob;
       delete gef;
     }
   };

   int main() {
     GameEnvironment
       g1(new KittiesAndPuzzles),
       g2(new KillAndDismember);
     g1.play();
     g2.play();
   }
   /* Output:
   Kitty has encountered a Puzzle
   KungFuGuy now battles against a NastyWeapon */ ///:~

   In this environment,Player objects interact withObstacle objects, but the types of players and obstacles depend on the game. You determine the kind of game by choosing a particularGameElementFactory, and then theGameEnvironment controls the setup and play of the game. In this example, the setup and play are simple, but those activities (theinitial conditions and thestate change) can determine much of the game’s outcome. Here,GameEnvironment is not designed to be inherited, although it could possibly make sense to do that.
   This example also illustratesdouble dispatching, which will be explained later.
   Virtual constructors
   One of the primary goals of using a factory is to organize your code so you don’t have to select an exact type of constructor when creating an object. That is, you can say, "I don’t know precisely what type of object you are, but here’s the information. Create yourself."
   In addition, during a constructor call the virtual mechanism does not operate (early binding occurs). Sometimes this is awkward. For example, in theShapeprogram it seems logical that inside the constructor for aShape object, you would want to set everything up and thendraw( ) theShape. Thedraw( ) function should be a virtual function, a message to theShape that it should draw itself appropriately, depending on whether it is a circle, a square, a line, and so on. However, this doesn’t work inside the constructor, virtual functions resolve to the "local" function bodies when called in constructors.
   If you want to be able to call a virtual function inside the constructor and have it do the right thing, you must use a technique tosimulate a virtual constructor (which is a variation of the Factory Method). This is a conundrum. Remember, the idea of a virtual function is that you send a message to an object and let the object figure out the right thing to do. But a constructor builds an object. So a virtual constructor would be like saying, "I don’t know exactly what type of object you are, but build yourself anyway." In an ordinary constructor, the compiler must know which VTABLE address to bind to the VPTR, and if it existed, a virtual constructor couldn’t do this because it doesn’t know all the type information at compile time. It makes sense that a constructor can’t be virtual because it is the one function that absolutely must know everything about the type of the object
   And yet there are times when you want something approximating the behavior of a virtual constructor.
   In theShape example, it would be nice to hand theShape constructor some specific information in the argument list and let the constructor create a specific type ofShape (aCircle,Square) with no further intervention. Ordinarily, you’d have to make an explicit call to theCircle,Square constructor yourself.
   Coplien[122] calls his solution to this problem "envelope and letter classes." The "envelope" class is the base class, a shell that contains a pointer to an object of the base class. The constructor for the "envelope" determines (at runtime, when the constructor is called, not at compile time, when the type checking is normally done) what specific type to make, creates an object of that specific type (on the heap), and then assigns the object to its pointer. All the function calls are then handled by the base class through its pointer. So the base class is acting as a proxy for the derived class:
   //: C10:VirtualConstructor.cpp
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;exception&gt;
   #include&lt;vector&gt;
   using namespace std;

   class Shape {
     Shape* s;
     // Prevent copy-construction& operator=
     Shape(Shape&);
     Shape operator=(Shape&);
   protected:
     Shape() { s = 0; };
   public:
     virtual void draw() { s-&gt;draw(); }
     virtual void erase() { s-&gt;erase(); }
     virtual void test() { s-&gt;test(); };
     virtual ~Shape() {
       cout&lt;&lt; "~Shape\n";
       if(s) {
         cout&lt;&lt; "Making virtual call: ";
         s-&gt;erase(); // Virtual call
       }
       cout&lt;&lt; "delete s: ";
       delete s; // The polymorphic deletion
     }
     class BadShapeCreation : public exception {
       string reason;
     public:
       BadShapeCreation(string type) {
         reason = "Cannot create type " + type;
       }
       ~BadShapeCreation() throw() {}
       const char *what() const throw() {
         return reason.c_str();
       }
     };
     Shape(string type) throw(BadShapeCreation);
   };

   class Circle : public Shape {
     Circle(Circle&);
     Circle operator=(Circle&);
     Circle() {} // Private constructor
     friend class Shape;
   public:
     void draw() { cout&lt;&lt; "Circle::draw\n"; }
     void erase() { cout&lt;&lt; "Circle::erase\n"; }
     void test() { draw(); }
     ~Circle() { cout&lt;&lt; "Circle::~Circle\n"; }
   };

   class Square : public Shape {
     Square(Square&);
     Square operator=(Square&);
     Square() {}
     friend class Shape;
   public:
     void draw() { cout&lt;&lt; "Square::draw\n"; }
     void erase() { cout&lt;&lt; "Square::erase\n"; }
     void test() { draw(); }
     ~Square() { cout&lt;&lt; "Square::~Square\n"; }
   };

   Shape::Shape(string type)
     throw(Shape::BadShapeCreation) {
     if(type == "Circle")
       s = new Circle;
     else if(type == "Square")
       s = new Square;
     else throw BadShapeCreation(type);
     draw();  // Virtual call in the constructor
   }

   char* shlist[] = { "Circle", "Square", "Square",
     "Circle", "Circle", "Circle", "Square", "" };

   int main() {
     vector&lt;Shape*&gt; shapes;
     cout&lt;&lt; "virtual constructor calls:"&lt;&lt; endl;
     try {
       for(char** cp = shlist; **cp; cp++)
         shapes.push_back(new Shape(*cp));
     } catch(Shape::BadShapeCreation e) {
       cout&lt;&lt; e.what()&lt;&lt; endl;
       for(int j = 0; j&lt; shapes.size(); j++)
         delete shapes[j];
       return 1;
     }
     for(int i = 0; i&lt; shapes.size(); i++) {
       shapes[i]-&gt;draw();
       cout&lt;&lt; "test\n";
       shapes[i]-&gt;test();
       cout&lt;&lt; "end test\n";
       shapes[i]-&gt;erase();
     }
     Shape c("Circle"); // Create on the stack
     cout&lt;&lt; "destructor calls:"&lt;&lt; endl;
     for(int j = 0; j&lt; shapes.size(); j++) {
       delete shapes[j];
       cout&lt;&lt; "\n------------\n";
     }
   } ///:~

   The base classShape contains a pointer to an object of typeShape as its only data member. When you build a "virtual constructor" scheme, exercise special care to ensure this pointer is always initialized to a live object.
   Each time you derive a new subtype fromShape, you must go back and add the creation for that type in one place, inside the "virtual constructor" in theShape base class. This is not too onerous a task, but the disadvantage is you now have a dependency between theShape class and all classes derived from it (a reasonable trade-off, it seems). Also, because it is a proxy, the base-class interface is truly the only thing the user sees.
   In this example, the information you must hand the virtual constructor about what type to create is explicit: it’s astring that names the type. However, your scheme can use other information—for example, in a parser the output of the scanner can be handed to the virtual constructor, which then uses that information to determine which token to create.
   The virtual constructorShape(type) can only be declared inside the class; it cannot be defined until after all the derived classes have been declared. However, the default constructor can be defined insideclass Shape, but it should be madeprotected so temporaryShape objects cannot be created. This default constructor is only called by the constructors of derived-class objects. You are forced to explicitly create a default constructor because the compiler will create one for you automatically only if there areno constructors defined. Because you must defineShape(type), you must also defineShape( ).
   The default constructor in this scheme has at least one important chore—it must set the value of thes pointer to zero. This may sound strange at first, but remember that the default constructor will be called as part of the construction of theactual object—in Coplien’s terms, the "letter," not the "envelope." However, the "letter" is derived from the "envelope," so it also inherits the data members. In the "envelope,"s is important because it points to the actual object, but in the "letter,"s is simply excess baggage. Even excess baggage should be initialized, however, and ifs is not set to zero by the default constructor called for the "letter," bad things happen (as you’ll see later).
   The virtual constructor takes as its argument information that completely determines the type of the object. Notice, though, that this type information isn’t read and acted upon until runtime, whereas normally the compiler must know the exact type at compile time (one other reason this system effectively imitates virtual constructors).
   The virtual constructor uses its argument to select the actual ("letter") object to construct, which is then assigned to the pointer inside the "envelope." At that point, the construction of the "letter" has been completed, so any virtual calls will be properly directed.
   As an example, consider the call todraw( ) inside the virtual constructor. If you trace this call (either by hand or with a debugger), you can see that it starts in thedraw( ) function in the base class,Shape. This function callsdraw( ) for the "envelope"s pointer to its "letter." All types derived fromShape share the same interface, so this virtual call is properly executed, even though it seems to be in the constructor. (Actually, the constructor for the "letter" has already completed.) As long as all virtual calls in the base class simply make calls to identical virtual functions through the pointer to the "letter," the system operates properly.
   To understand how it works, consider the code inmain( ). To fill thevector shapes, "virtual constructor" calls are made toShape. Ordinarily in a situation like this, you would call the constructor for the actual type, and the VPTR for that type would be installed in the object. Here, however, the VPTR used in each case is the one forShape, not the one for the specificCircle,Square, orTriangle.
   In thefor loop where thedraw( ) anderase( )functions are called for eachShape, the virtual function call resolves, through the VPTR, to the corresponding type. However, this isShape in each case. In fact, you might wonder whydraw( ) anderase( )were madevirtual at all. The reason shows up in the next step: the base-class version ofdraw( ) makes a call, through the "letter" pointers, to thevirtual functiondraw( ) for the "letter." This time the call resolves to the actual type of the object, not just the base classShape. Thus, the runtime cost of using virtual constructors is one more virtual call every time you make a virtual function call.
   To create any function that is overridden, such asdraw( ),erase( ), ortest( ), you must proxy all calls to thes pointer in the base class implementation, as shown earlier. This is because, when the call is made, the call to the envelope’s member function will resolve as being toShape, and not to a derived type ofShape. Only when you make the proxy call tos will the virtual behavior take place. Inmain( ), you can see that everything works correctly, even when calls are made inside constructors and destructors.
   Destructor operation
   The activities of destruction in this scheme are also tricky. To understand, let’s verbally walk through what happens when you calldelete for a pointer to aShape object—specifically, aSquare—created on the heap. (This is more complicated than an object created on the stack.) This will be adelete through the polymorphic interface, as in the statementdelete shapes[i] inmain( ).
   The type of the pointershapes[i] is of the base classShape, so the compiler makes the call throughShape. Normally, you might say that it’s a virtual call, soSquare’s destructor will be called. But with the virtual constructor scheme, the compiler is creating actualShape objects, even though the constructor initializes the letter pointer to a specific type ofShape. The virtual mechanismis used, but the VPTR inside theShape object isShape’s VPTR, notSquare’s. This resolves toShape’s destructor, which callsdelete for the letter pointers, which actually points to aSquare object. This is again a virtual call, but this time it resolves toSquare’s destructor.
   With a destructor, however, C++ guarantees, via the compiler, that all destructors in the hierarchy are called.Square’s destructor is called first, followed by any intermediate destructors, in order, until finally the base-class destructor is called. This base-class destructor has code that saysdelete s. When this destructor was called originally, it was for the "envelope"s, but now it’s for the "letter"s, which is there because the "letter" was inherited from the "envelope," and not because it contains anything. Sothis call todelete should do nothing.
   The solution to the problem is to make the "letter"s pointer zero. Then when the "letter" base-class destructor is called, you getdelete 0, which by definition does nothing. Because the default constructor is protected, it will be calledonly during the construction of a "letter," so that’s the only situation in whichs is set to zero.
   Your most common tool for hiding construction will probably be ordinary Factory Methods rather than the more complex approaches. The idea of adding new types with minimal effect on the rest of the system will be further explored later in this chapter.
   Observer
   The Observer pattern solves a fairly common problem: what if a group of objects needs to update themselves when some other object changes state? This can be seen in the "model-view" aspect of Smalltalk’s MVC (model-view-controller) or the almost-equivalent "Document-View Architecture." Suppose that you have some data (the "document") and more than one view, say a plot and a textual view. When you change the data, the two views must know to update themselves, and that’s what the observer facilitates.
   Two types of objects are used to implement the observer pattern in the following code. TheObservable class keeps track of everybody who wants to be informed when a change happens. TheObservable class calls thenotifyObservers( ) member function for each observer on the list. ThenotifyObservers( ) member function is part of the base classObservable.
   There are actually two "things that change" in the observer pattern: the quantity of observing objects and the way an update occurs. That is, the observer pattern allows you to modify both of these without affecting the surrounding code.
   You can implement the observer pattern in a number of ways, but the code shown here will create a framework from which you can build your own observer code, following the example. First, this interface describes what an observer looks like:
   //: C10:Observer.h
   // The Observer interface
   #ifndef OBSERVER_H
   #define OBSERVER_H

   class Observable;
   class Argument {};

   class Observer {
   public:
     // Called by the observed object, whenever
     // the observed object is changed:
     virtual void
     update(Observable* o, Argument * arg) = 0;
   };
   #endif // OBSERVER_H ///:~

   SinceObserver interacts withObservable in this approach,Observable must be declared first. In addition, theArgument class is empty and only acts as a base class for any type of argument you want to pass during an update. If you want, you can simply pass the extra argument as avoid*. You’ll have to downcast in either case.
   TheObserver type is an "interface" class that only has one member function,update( ). This function is called by the object that’s being observed, when that object decides it’s time to update all its observers. The arguments are optional; you could have anupdate( ) with no arguments, and that would still fit the observer pattern. However this is more general—it allows the observed object to pass the object that caused the update (since anObservermay be registered with more than one observed object) and any extra information if that’s helpful, rather than forcing theObserver object to hunt around to see who is updating and to fetch any other information it needs.
   The "observed object" will be of typeObservable:
   //: C10:Observable.h
   // The Observable class
   #ifndef OBSERVABLE_H
   #define OBSERVABLE_H
   #include "Observer.h"
   #include&lt;set&gt;

   class Observable {
     bool changed;
     std::set&lt;Observer*&gt; observers;
   protected:
     virtual void setChanged() { changed = true; }
     virtual void clearChanged(){ changed = false; }
   public:
     virtual void addObserver(Observer& o) {
       observers.insert(&o);
     }
     virtual void deleteObserver(Observer& o) {
       observers.erase(&o);
     }
     virtual void deleteObservers() {
       observers.clear();
     }
     virtual int countObservers() {
       return observers.size();
     }
     virtual bool hasChanged() { return changed; }
     // If this object has changed, notify all
     // of its observers:
     virtual void notifyObservers(Argument* arg = 0) {
       if(!hasChanged()) return;
       clearChanged(); // Not "changed" anymore
       std::set&lt;Observer*&gt;::iterator it;
       for(it = observers.begin();
         it != observers.end(); it++)
         (*it)-&gt;update(this, arg);
     }
   };
   #endif // OBSERVABLE_H ///:~

   Again, the design here is more elaborate than is necessary; as long as there’s a way to register anObserver with anObservable and a way for theObservable to update itsObservers, the set of member functions doesn’t matter. However, this design is intended to be reusable. (It was lifted from the design used in the Java standard library.)[123] 
   TheObservable object has a flag to indicate whether it’s been changed. In a simpler design, there would be no flag; if something happened, everyone would be notified. Notice, however, that the control of the flag’s state isprotected so that only an inheritor can decide what constitutes a change, and not the end user of the resulting derivedObserver class.
   The collection ofObserver objects is kept in aset&lt;Observer*&gt; to prevent duplicates; theset insert( ),erase( ),clear( ), andsize( ) functions are exposed to allowObservers to be added and removed at any time, thus providing runtime flexibility.
   Most of the work is done innotifyObservers( ). If thechanged flag has not been set, this does nothing. Otherwise, it first clears thechanged flag so that repeated calls tonotifyObservers( ) won’t waste time. This is done before notifying the observers in case the calls toupdate( ) do anything that causes a change back to thisObservable object. It then moves through theset and calls back to theupdate( ) member function of eachObserver.
   At first it may appear that you can use an ordinaryObservable object to manage the updates. But this doesn’t work; to get an effect, youmust derive fromObservable and somewhere in your derived-class code callsetChanged( ). This is the member function that sets the "changed" flag, which means that when you callnotifyObservers( ) all the observers will, in fact, get notified.Where you callsetChanged( ) depends on the logic of your program.
   Now we encounter a dilemma. Objects that are being observed may have more than one such item of interest. For example, if you’re dealing with a GUI item—a button, say—the items of interest might be the mouse clicked the button, the mouse moved over the button, and (for some reason) the button changed its color. So we’d like to be able to report all these events to different observers, each of which is interested in a different type of event.
   The problem is that we would normally reach for multiple inheritance in such a situation: "I’ll inherit fromObservable to deal with mouse clicks, and I’ll … er … inherit fromObservable to deal with mouse-overs, and, well,… hmm, that doesn’t work."
   The "inner class" idiom
   Here’s a situation in which we do actually need to (in effect) upcast to more than one type, but in this case we need to provide severaldifferent implementations of the same base type. The solution is something we’ve lifted from Java, which takes C++’s nested class one step further. Java has a built-in feature called aninner class, which is like a nested class in C++, but it has access to the nonstatic data of its containing class by implicitly using the "this" pointer of the class object it was created within.[124] 
   To implement the inner class idiom in C++, we must obtain and use a pointer to the containing object explicitly. Here’s an example:
   //: C10:InnerClassIdiom.cpp
   // Example of the "inner class" idiom
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace std;

   class Poingable {
   public:
     virtual void poing() = 0;
   };

   void callPoing(Poingable& p) {
     p.poing();
   }

   class Bingable {
   public:
     virtual void bing() = 0;
   };

   void callBing(Bingable& b) {
     b.bing();
   }

   class Outer {
     string name;
     // Define one inner class:
     class Inner1;
     friend class Outer::Inner1;
     class Inner1 : public Poingable {
       Outer* parent;
     public:
       Inner1(Outer* p) : parent(p) {}
       void poing() {
         cout&lt;&lt; "poing called for "
          &lt;&lt; parent-&gt;name&lt;&lt; endl;
         // Accesses data in the outer class object
       }
     } inner1;
     // Define a second inner class:
     class Inner2;
     friend class Outer::Inner2;
     class Inner2 : public Bingable {
       Outer* parent;
     public:
       Inner2(Outer* p) : parent(p) {}
       void bing() {
         cout&lt;&lt; "bing called for "
          &lt;&lt; parent-&gt;name&lt;&lt; endl;
       }
     } inner2;
   public:
     Outer(const string& nm) : name(nm),
       inner1(this), inner2(this) {}
     // Return reference to interfaces
     //  implemented by the inner classes:
     operator Poingable&() { return inner1; }
     operator Bingable&() { return inner2; }
   };

   int main() {
     Outer x("Ping Pong");
     // Like upcasting to multiple base types!:
     callPoing(x);
     callBing(x);
   } ///:~

   The example begins with thePoingable andBingableinterfaces, each of which contain a single member function. The services provided bycallPoing( ) andcallBing( )require that the object they receive implement thePoingable andBingableinterfaces, respectively, but they put no other requirements on that object so as to maximize the flexibility of usingcallPoing( ) andcallBing( ). Note the lack ofvirtual destructors in either interface—the intent is that you never perform object destruction via the interface.
   TheOuter constructor contains some private data (name), and it wants to provide both aPoingable interface and aBingableinterface so it can be used withcallPoing( )andcallBing( ). Of course, in this situation wecould simply use multiple inheritance. This example is just intended to show the simplest syntax for the idiom; you’ll see a real use shortly. To provide aPoingable object without derivingOuter fromPoingable, the inner class idiom is used. First, the declarationclass Inner says that, somewhere, there is a nested class of this name. This allows thefriend declaration for the class, which follows. Finally, now that the nested class has been granted access to all the private elements ofOuter, the class can be defined. Notice that it keeps a pointer to theOuter which created it, and this pointer must be initialized in the constructor. Finally, thepoing( ) function fromPoingable is implemented. The same process occurs for the second inner class which implementsBingable. Each inner class has a singleprivate instance created, which is initialized in theOuter constructor. By creating the member objects and returning references to them, issues of object lifetime are eliminated.
   Notice that both inner class definitions areprivate, and in fact the client code doesn’t have any access to details of the implementation, since the two access functionsoperator Poingable&( ) andoperator Bingable&( ) only return a reference to the upcast interface, not to the object that implements it. In fact, since the two inner classes areprivate, the client code cannot even downcast to the implementation classes, thus providing complete isolation between interface and implementation.
   Just to push a point, we’ve taken the extra liberty here of defining the automatic type conversion operatorsoperator Poingable&( ) andoperator Bingable&( ). Inmain( ), you can see that these actually allow a syntax that looks likeOuter multiply inherits fromPoingable andBingable. The difference is that the casts in this case are one way. You can get the effect of an upcast toPoingable orBingable, but you cannot downcast back to anOuter. In the following example ofobserver, you’ll see the more typical approach: you provide access to the inner class objects using ordinary member functions, not automatic type conversion operations.
   The observer example
   Armed with theObserver andObservableheader files and the inner class idiom, we can look at an example of the Observer pattern:
   //: C10:ObservedFlower.cpp
   // Demonstration of "observer" pattern
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "Observable.h"
   using namespace std;

   class Flower {
     bool isOpen;
   public:
     Flower() : isOpen(false),
       openNotifier(this), closeNotifier(this) {}
     void open() { // Opens its petals
       isOpen = true;
       openNotifier.notifyObservers();
       closeNotifier.open();
     }
     void close() { // Closes its petals
       isOpen = false;
       closeNotifier.notifyObservers();
       openNotifier.close();
     }
     // Using the "inner class" idiom:
     class OpenNotifier;
     friend class Flower::OpenNotifier;
     class OpenNotifier : public Observable {
       Flower* parent;
       bool alreadyOpen;
     public:
       OpenNotifier(Flower* f) : parent(f),
         alreadyOpen(false) {}
       void notifyObservers(Argument* arg = 0) {
         if(parent-&gt;isOpen&& !alreadyOpen) {
           setChanged();
           Observable::notifyObservers();
           alreadyOpen = true;
         }
       }
       void close() { alreadyOpen = false; }
     } openNotifier;
     class CloseNotifier;
     friend class Flower::CloseNotifier;
     class CloseNotifier : public Observable {
       Flower* parent;
       bool alreadyClosed;
     public:
       CloseNotifier(Flower* f) : parent(f),
         alreadyClosed(false) {}
       void notifyObservers(Argument* arg = 0) {
         if(!parent-&gt;isOpen&& !alreadyClosed) {
           setChanged();
           Observable::notifyObservers();
           alreadyClosed = true;
         }
       }
       void open() { alreadyClosed = false; }
     } closeNotifier;
   };

   class Bee {
     string name;
     // An "inner class" for observing openings:
     class OpenObserver;
     friend class Bee::OpenObserver;
     class OpenObserver : public Observer {
       Bee* parent;
     public:
       OpenObserver(Bee* b) : parent(b) {}
       void update(Observable*, Argument *) {
         cout&lt;&lt; "Bee "&lt;&lt; parent-&gt;name
          &lt;&lt; "'s breakfast time!\n";
       }
     } openObsrv;
     // Another "inner class" for closings:
     class CloseObserver;
     friend class Bee::CloseObserver;
     class CloseObserver : public Observer {
       Bee* parent;
     public:
       CloseObserver(Bee* b) : parent(b) {}
       void update(Observable*, Argument *) {
         cout&lt;&lt; "Bee "&lt;&lt; parent-&gt;name
          &lt;&lt; "'s bed time!\n";
       }
     } closeObsrv;
   public:
     Bee(string nm) : name(nm),
       openObsrv(this), closeObsrv(this) {}
     Observer& openObserver() { return openObsrv; }
     Observer& closeObserver() { return closeObsrv;}
   };

   class Hummingbird {
     string name;
     class OpenObserver;
     friend class Hummingbird::OpenObserver;
     class OpenObserver : public Observer {
       Hummingbird* parent;
     public:
       OpenObserver(Hummingbird* h) : parent(h) {}
       void update(Observable*, Argument *) {
         cout&lt;&lt; "Hummingbird "&lt;&lt; parent-&gt;name
          &lt;&lt; "'s breakfast time!\n";
       }
     } openObsrv;
     class CloseObserver;
     friend class Hummingbird::CloseObserver;
     class CloseObserver : public Observer {
       Hummingbird* parent;
     public:
       CloseObserver(Hummingbird* h) : parent(h) {}
       void update(Observable*, Argument *) {
         cout&lt;&lt; "Hummingbird "&lt;&lt; parent-&gt;name
          &lt;&lt; "'s bed time!\n";
       }
     } closeObsrv;
   public:
     Hummingbird(string nm) : name(nm),
       openObsrv(this), closeObsrv(this) {}
     Observer& openObserver() { return openObsrv; }
     Observer& closeObserver() { return closeObsrv;}
   };

   int main() {
     Flower f;
     Bee ba("A"), bb("B");
     Hummingbird ha("A"), hb("B");
     f.openNotifier.addObserver(ha.openObserver());
     f.openNotifier.addObserver(hb.openObserver());
     f.openNotifier.addObserver(ba.openObserver());
     f.openNotifier.addObserver(bb.openObserver());
     f.closeNotifier.addObserver(ha.closeObserver());
     f.closeNotifier.addObserver(hb.closeObserver());
     f.closeNotifier.addObserver(ba.closeObserver());
     f.closeNotifier.addObserver(bb.closeObserver());
     // Hummingbird B decides to sleep in:
     f.openNotifier.deleteObserver(hb.openObserver());
     // Something changes that interests observers:
     f.open();
     f.open(); // It's already open, no change.
     // Bee A doesn't want to go to bed:
     f.closeNotifier.deleteObserver(
       ba.closeObserver());
     f.close();
     f.close(); // It's already closed; no change
     f.openNotifier.deleteObservers();
     f.open();
     f.close();
   } ///:~

   The events of interest are that aFlower can open or close. Because of the use of the inner class idiom, both these events can be separately observable phenomena. TheOpenNotifier andCloseNotifier classes both derive fromObservable, so they have access tosetChanged( ) and can be handed to anything that needs anObservable. You’ll notice that, contrary toInnerClassIdiom.cpp, theObservable descendants arepublic. This is because some of their member functions must be available to the client programmer. There’s nothing that says that an inner class must beprivate; inInnerClassIdiom.cpp we were simply following the design guideline "make things as private as possible." You could make the classesprivate and expose the appropriate member functions by proxy inFlower, but it wouldn’t gain much.
   The inner class idiom also comes in handy to define more than one kind ofObserver, inBee andHummingbird, since both those classes may want to independently observeFlower openings and closings. Notice how the inner class idiom provides something that has most of the benefits of inheritance (the ability to access the private data in the outer class, for example).
   Inmain( ), you can see one of the primary benefits of the Observer pattern: the ability to change behavior at runtime by dynamically registering and unregisteringObservers withObservables.
   If you study the previous code, you’ll see thatOpenNotifierandCloseNotifier use the basicObservable interface. This means that you could derive from other completely differentObserver classes; the only connection theObservers have withFlowers is theObserver interface.
   Multiple dispatching
   When dealing with multiple types that are interacting, a program can get particularly messy. For example, consider a system that parses and executes mathematical expressions. You want to be able to sayNumber + Number,Number * Number, and so on, whereNumber is the base class for a family of numerical objects. But when you saya + b, and you don’t know the exact type of eithera orb, how can you get them to interact properly?
   The answer starts with something you probably don’t think about: C++ performs only single dispatching. That is, if you are performing an operation on more than one object whose type is unknown, C++ can invoke the dynamic binding mechanism on only one of those types. This doesn’t solve the problem, so you end up detecting some types manually and effectively producing your own dynamic binding behavior.
   The solution is calledmultiple dispatching. Remember that polymorphism can occur only via member function calls, so if you want double dispatching to occur, there must be two member function calls: the first to determine the first unknown type, and the second to determine the second unknown type. With multiple dispatching, you must have a virtual call for each of the types. Generally, you’ll set up a configuration such that a single member function call produces more than one dynamic member function call and thus services more than one type in the process. To get this effect, you need to work with more than one virtual function: you’ll need a virtual function call for each dispatch. The virtual functions in the following example are calledcompete( )andeval( ) and are both members of the same type. (In this case, there will be only two dispatches, which is referred to asdouble dispatching.) If you are working with two different type hierarchies that are interacting, you’ll need a virtual call in each hierarchy.
   Here’s an example of multiple dispatching:
   //: C10:PaperScissorsRock.cpp
   // Demonstration of multiple dispatching
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Paper;
   class Scissors;
   class Rock;

   enum Outcome { win, lose, draw };

   ostream&
   operator&lt;&lt;(ostream& os, const Outcome out) {
     switch(out) {
       default:
       case win: return os&lt;&lt; "win";
       case lose: return os&lt;&lt; "lose";
       case draw: return os&lt;&lt; "draw";
     }
   }

   class Item {
   public:
     virtual Outcome compete(const Item*) = 0;
     virtual Outcome eval(const Paper*) const = 0;
     virtual Outcome eval(const Scissors*) const= 0;
     virtual Outcome eval(const Rock*) const = 0;
     virtual ostream& print(ostream& os) const = 0;
     virtual ~Item() {}
     friend ostream&
     operator&lt;&lt;(ostream& os, const Item* it) {
       return it-&gt;print(os);
     }
   };

   class Paper : public Item {
   public:
     Outcome compete(const Item* it) {
       return it-&gt;eval(this);
     }
     Outcome eval(const Paper*) const {
       return draw;
     }
     Outcome eval(const Scissors*) const {
       return win;
     }
     Outcome eval(const Rock*) const {
       return lose;
     }
     ostream& print(ostream& os) const {
       return os&lt;&lt; "Paper   ";
     }
   };

   class Scissors : public Item {
   public:
     Outcome compete(const Item* it) {
       return it-&gt;eval(this);
     }
     Outcome eval(const Paper*) const {
       return lose;
     }
     Outcome eval(const Scissors*) const {
       return draw;
     }
     Outcome eval(const Rock*) const {
       return win;
     }
     ostream& print(ostream& os) const {
       return os&lt;&lt; "Scissors";
     }
   };

   class Rock : public Item {
   public:
     Outcome compete(const Item* it) {
       return it-&gt;eval(this);
     }
     Outcome eval(const Paper*) const {
       return win;
     }
     Outcome eval(const Scissors*) const {
       return lose;
     }
     Outcome eval(const Rock*) const {
       return draw;
     }
     ostream& print(ostream& os) const {
       return os&lt;&lt; "Rock    ";
     }
   };

   struct ItemGen {
     ItemGen() { srand(time(0)); }
     Item* operator()() {
       switch(rand() % 3) {
         default:
         case 0:
           return new Scissors;
         case 1:
           return new Paper;
         case 2:
           return new Rock;
       }
     }
   };

   struct Compete {
     Outcome operator()(Item* a, Item* b) {
       cout&lt;&lt; a&lt;&lt; "\t"&lt;&lt; b&lt;&lt; "\t";
       return a-&gt;compete(b);
     }
   };

   int main() {
     const int sz = 20;
     vector&lt;Item*&gt; v(sz*2);
     generate(v.begin(), v.end(), ItemGen());
     transform(v.begin(), v.begin() + sz,
       v.begin() + sz,
       ostream_iterator&lt;Outcome&gt;(cout, "\n"),
       Compete());
     purge(v);
   } ///:~

   Multiple dispatching with Visitor
   The assumption is that you have a primary class hierarchy that is fixed; perhaps it’s from another vendor and you can’t make changes to that hierarchy. However, you’d like to add new polymorphic member functions to that hierarchy, which means that normally you’d have to add something to the base class interface. So the dilemma is that you need to add member functions to the base class, but you can’t touch the base class. How do you get around this?
   The design pattern that solves this kind of problem is called a "visitor" (the final one inDesign Patterns), and it builds on the double-dispatching scheme shown in the previous section.
   The Visitor pattern allows you to extend the interface of the primary type by creating a separate class hierarchy of typeVisitorto "virtualize" the operations performed on the primary type. The objects of the primary type simply "accept" the visitor and then call the visitor’s dynamically-bound member function.
   //: C10:BeeAndFlowers.cpp
   // Demonstration of "visitor" pattern
   #include&lt;algorithm&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include "../purge.h"
   using namespace std;

   class Gladiolus;
   class Renuculus;
   class Chrysanthemum;

   class Visitor {
   public:
     virtual void visit(Gladiolus* f) = 0;
     virtual void visit(Renuculus* f) = 0;
     virtual void visit(Chrysanthemum* f) = 0;
     virtual ~Visitor() {}
   };

   class Flower {
   public:
     virtual void accept(Visitor&) = 0;
     virtual ~Flower() {}
   };

   class Gladiolus : public Flower {
   public:
     virtual void accept(Visitor& v) {
       v.visit(this);
     }
   };

   class Renuculus : public Flower {
   public:
     virtual void accept(Visitor& v) {
       v.visit(this);
     }
   };

   class Chrysanthemum : public Flower {
   public:
     virtual void accept(Visitor& v) {
       v.visit(this);
     }
   };

   // Add the ability to produce a string:
   class StringVal : public Visitor {
     string s;
   public:
     operator const string&() { return s; }
     virtual void visit(Gladiolus*) {
       s = "Gladiolus";
     }
     virtual void visit(Renuculus*) {
       s = "Renuculus";
     }
     virtual void visit(Chrysanthemum*) {
       s = "Chrysanthemum";
     }
   };

   // Add the ability to do "Bee" activities:
   class Bee : public Visitor {
   public:
     virtual void visit(Gladiolus*) {
       cout&lt;&lt; "Bee and Gladiolus\n";
     }
     virtual void visit(Renuculus*) {
       cout&lt;&lt; "Bee and Renuculus\n";
     }
     virtual void visit(Chrysanthemum*) {
       cout&lt;&lt; "Bee and Chrysanthemum\n";
     }
   };

   struct FlowerGen {
     FlowerGen() { srand(time(0)); }
     Flower* operator()() {
       switch(rand() % 3) {
         default:
         case 0: return new Gladiolus;
         case 1: return new Renuculus;
         case 2: return new Chrysanthemum;
       }
     }
   };

   int main() {
     vector&lt;Flower*&gt; v(10);
     generate(v.begin(), v.end(), FlowerGen());
     vector&lt;Flower*&gt;::iterator it;
     // It's almost as if I added a virtual function
     // to produce a Flower string representation:
     StringVal sval;
     for(it = v.begin(); it != v.end(); it++) {
       (*it)-&gt;accept(sval);
       cout&lt;&lt; string(sval)&lt;&lt; endl;
     }
     // Perform "Bee" operation on all Flowers:
     Bee bee;
     for(it = v.begin(); it != v.end(); it++)
       (*it)-&gt;accept(bee);
     purge(v);
   } ///:~

   Exercises
   1.Starting withSingletonPattern.cpp, create a class that provides a connection to a service that stores and retrieves data from a configuration file.
   2.UsingSingletonPattern.cpp as a starting point, create a class that manages a fixed number of its own objects. Assume the objects are database connections and you only have a license to use a fixed quantity of these at any one time.
   3.Create a minimal Observer-Observable design in two classes, without base classes and without the extra arguments inObserver.h and the member functions inObservable.h. Just create the bare minimum in the two classes, and then demonstrate your design by creating oneObservable and manyObservers and cause theObservable to update theObservers.
   4.             ChangeInnerClassIdiom.cpp so thatOuter uses multiple inheritance instead of the inner class idiom.
   5.Explain howAbstractFactory.cpp demonstratesDouble Dispatching and theFactory Method.
   6.ModifyShapeFactory2.cpp so that it uses anAbstract Factory to create different sets of shapes (for example, one particular type of factory object creates "thick shapes," another creates "thin shapes," but each factory object can create all the shapes: circles, squares, triangles, and so on).
   7.Create a business-modeling environment with three types ofInhabitant:Dwarf (for engineers),Elf (for marketers), andTroll (for managers). Now create a class calledProject that creates the different inhabitants and causes them tointeract( ) with each other using multiple dispatching.
   8.Modify the example in exercise 7 to make the interactions more detailed. EachInhabitant can randomly produce aWeapon usinggetWeapon( ): aDwarf usesJargon orPlay, anElf usesInventFeature orSellImaginaryProduct, and aTroll usesEdict andSchedule. You decide which weapons "win" and "lose" in each interaction (as inPaperScissorsRock.cpp). Add abattle( ) member function toProject that takes twoInhabitants and matches them against each other. Now create ameeting( ) member function forProject that creates groups ofDwarf,Elf, andManager and battles the groups against each other until only members of one group are left standing. These are the "winners."
   11: Concurrency
   Objects provide a way to divide a program into independent sections. Often, you also need to partition a program into separate, independently running subtasks.
   Usingmultithreading, each of these independent subtasks is driven by athread of execution, and you program as if each thread runs by itself and has the CPU to itself. An underlying mechanism is actually dividing up the CPU time for you, but in general, you don’t have to think about it, which helps to simplify programming with multiple threads.
   Aprocess is a self-contained program running with its own address space. Amultitasking operating system can run more than one process (program) at a time, while making it look as if each one is chugging along on its own, by periodically switching the CPU from one task to another. Athread is a single sequential flow of controlwithin a process. A single process can thus have multiple concurrently executing threads.
   There are many possible uses for multithreading, but you’ll most often want to use it when you have some part of your program tied to a particular event or resource. To keep from holding up the rest of your program, you create a thread associated with that event or resource and let it run independently of the main program.
   Concurrent programming is like stepping into an entirely new world and learning a new programming language, or at least a new set of language concepts. With the appearance of thread support in most microcomputer operating systems, extensions for threads have also been appearing in programming languages or libraries. In all cases, thread programming:
   1.       Seems mysterious and requires a shift in the way you think about programming.
   2.      Looks similar to thread support in other languages. When you understand threads, you understand a common tongue.
   Understanding concurrent programming is on the same order of difficulty as understanding polymorphism. If you apply some effort, you can fathom the basic mechanism, but it generally takes deep study and understanding to develop a true grasp of the subject. The goal of this chapter is to give you a solid foundation in the basics of concurrency so that you can understand the concepts and write reasonable multithreaded programs. Be aware that you can easily become overconfident. If you are writing anything complex, you will need to study dedicated books on the topic.
   Motivation
   One of the most compelling reasons for using concurrency is to produce a responsive user interface. Consider a program that performs some CPU-intensive operation and thus ends up ignoring user input and being unresponsive. The program needs to continue performing its operations, and at the same time it needs to return control to the user interface so that the program can respond to the user. If you have a "quit" button, you don’t want to be forced to poll it in every piece of code you write in your program. (This would couple your quit button across the program and be a maintenance headache.) Yet you want the quit button to be responsive, as if youwere checking it regularly.
   A conventional function cannot continue performing its operations and at the same time return control to the rest of the program. In fact, this sounds like an impossibility, as if the CPU must be in two places at once, but this is precisely the illusion that concurrency provides.
   You can also use concurrency to optimize throughput. For example, you might be able to do important work while you’re stuck waiting for input to arrive on an I/O port. Without threading, the only reasonable solution is to poll the I/O port, which is awkward and can be difficult.
   If you have a multiprocessor machine, multiple threads can be distributed across multiple processors, which can dramatically improve throughput. This is often the case with powerful multiprocessor web servers, which can distribute large numbers of user requests across CPUs in a program that allocates one thread per request.
   One thing to keep in mind is that a program that has many threads must be able to run on a single-CPU machine. Therefore, it must also be possible to write the same program without using any threads. However, multithreading provides an important organizational benefit: The design of your program can be greatly simplified. Some types of problems, such as simulation—a video game, for example—are difficult to solve without support for concurrency.
   The threading model is a programming convenience to simplify juggling several operations at the same time within a single program: The CPU will pop around and give each thread some of its time. Each thread has the consciousness of constantly having the CPU to itself, but the CPU’s time is actually sliced among all the threads. The exception is a program that is running on multiple CPU. But one of the great things about threading is that you are abstracted away from this layer, so your code does not need to know whether it is actually running on a single CPU or many. Thus, using threads is a way to create transparently scalable programs—if a program is running too slowly, you can easily speed it up by adding CPUs to your computer. Multitasking and multithreading tend to be the most reasonable ways to utilize multiprocessor systems.
   Threading can reduce computing efficiency somewhat in single-CPU machines, but the net improvement in program design, resource balancing, and user convenience is often quite valuable. In general, threads enable you to create a more loosely coupled design; otherwise, parts of your code would be forced to pay explicit attention to tasks that would normally be handled by threads.
   Concurrency in C++
   When the C++ standards committee was creating the initial C++ standard, a concurrency mechanism was explicitly excluded, because C didn’t have one and also because there were a number of competing approaches to implementing concurrency. It seemed too much of a constraint to force programmers to use only one of these.
   The alternative turned out to be worse, however. To use concurrency, you had to find and learn a library and deal with its idiosyncrasies and the uncertainties of working with a particular vendor. In addition, there was no guarantee that such a library would work on different compilers or across different platforms. Also, since concurrency was not part of the standard language, it was more difficult to find C++ programmers that also understood concurrent programming.
   Another influence may have been the Java language, which included concurrency in the core language. Although multithreading is still complicated, Java programmers tend to start learning and using it from the beginning.
   The C++ standards committee is seriously considering the addition of concurrency support to the next iteration of C++, but at the time of this writing it is unclear what the library will look like. Therefore, we decided to use the ZThread library as the basis for this chapter. We preferred the design, and it is open-source and freely available athttp://zthread.sourceforge.net. Eric Crahen of IBM, the author of the ZThread library, was instrumental in creating this chapter.[125]
   This chapter uses only a subset of the ZThread library, in order to convey the fundamental ideas of threading. The ZThread library contains significantly more sophisticated thread support than is shown here, and you should study that library further in order to fully understand its capabilities.
   Installing ZThreads
   Please note that the ZThread library is an independent project and is not supported by the authors of this book; we are simply using the library in this chapter and cannot provide technical support for installation issues. See the ZThread web site for installation support and error reports.
   The ZThread library is distributed as source code. After downloading it from the ZThread web site, you must first compile the library, and then configure your project to use the library.
   The preferred method for compiling ZThreads for most flavors of UNIX (Linux, SunOS, Cygwin, etc.) is to use the configure script. After unpacking the files (usingtar), simply execute:
   ./configure&& make install

   from the main directory of the ZThreads archive to compile and install a copy of the library in the/usr/local directory. You can customize a number of options when using this script, including the locations of files. For details, use this command:
   ./configure–help

   The ZThreads code is structured to simplify compilation for other platforms and compilers (such as Borland, Microsoft, and Metrowerks). To do this, create a new project and add all the.cxxfiles in thesrc directory of the ZThreads archive to the list of files to be compiled. Also, be sure to include theinclude directory of the archive in the header search path for your project. The exact details will vary from compiler to compiler so you’ll need to be somewhat familiar with your toolset to be able to use this option.
   Once the compilation has succeeded, the next step is to create a project that uses the newly compiled library. First, let the compiler know where the headers are located so that your#include statements will work properly. Typically, you will add an option such as the following to your project:
   -I/path/to/installation/include

   If you used theconfigure script, the installation path will be whatever you selected for the prefix (which defaults to/usr/local). If you used one of the project files in thebuild directory, the installation path would simply be the path to the main directory of the ZThreads archive.
   Next, you’ll need to add an option to your project that will let the linker know where to find the library. If you used the configure script, this will look like:
   -L/path/to/installation/lib–lZThread

   If you used one of the project files provided, this will look like:
   -L/path/to/installation/Debug ZThread.lib

   Again, if you used theconfigure script, the installation path will be whatever you selected for the prefix. If you used a provided project file, the path will be the path to the main directory of the ZThreads archive.
   Note that if you’re using Linux, or if you are using Cygwin (www.cygwin.com) under Windows, you may not need to modify your include or library path; the installation process and defaults will often take care of everything for you.
   Under Linux, you will probably need to add the following to your.bashrc so that the runtime system can find the shared library fileLibZThread-x.x.so.Owhen it executes the programs in this chapter:
   export LD_LIBRARY_PATH=/usr/local/lib:${LD_LIBRARY_PATH}
   (Assuming you used the default installation process and the shared library ended up in /user/local/lib; otherwise, change the path to your location).
   Defining Tasks
   A thread carries out a task, so you need a way to describe that task. TheRunnable class provides a common interface to execute any arbitrary task. Here is the core of the ZThreadRunnable class, which you will find inRunnable.h in theinclude directory, after installing the ZThread library:
   class Runnable {
   public:
     virtual void run() = 0;
     virtual ~Runnable() {}
   };

   By making this a pure abstract base class (or as pure as possible, given the constraints on virtual destructors),Runnable allows an easy mixin combination with a base class and other classes.
   To define a task, simply inherit from theRunnable class and overriderun( ) to make the task do your bidding.
   For example, the followingLiftOff task displays the countdown before liftoff:
   //: C11:LiftOff.h
   // Demonstration of the Runnable interface.
   #ifndef LIFTOFF_H
   #define LIFTOFF_H
   #include "zthread/Runnable.h"
   #include&lt;iostream&gt;

   class LiftOff : public ZThread::Runnable {
     int countDown;
     int id;
   public:
     LiftOff(int count, int ident = 0) :
       countDown(count), id(ident) {}
     ~LiftOff() {
       std::cout&lt;&lt; id&lt;&lt; " completed"&lt;&lt; std::endl;
     }
     void run() {
       while(countDown--)
         std::cout&lt;&lt; id&lt;&lt; ":"&lt;&lt; countDown&lt;&lt; std::endl;
       std::cout&lt;&lt; "Liftoff!"&lt;&lt; std::endl;
     }
   };
   #endif // LIFTOFF_H ///:~

   As usual, we are careful not to use anyusing namespace directives in a header file. The identifieridallows you to distinguish between multiple instances of the task. If you only make a single instance, you can use the default value forident. The destructor will allow you to see that a task is properly destroyed.
   In the following example, the task’srun( ) is not driven by a separate thread; it is simply called directly inmain( ):
   //: C11:NoThread.cpp
   #include "LiftOff.h"

   int main() {
     LiftOff launch(10);
     launch.run();
   } ///:~

   When a class inheritsRunnable, it must have arun( ) function, but that’s nothing special—it doesn’t produce any innate threading abilities.
   To achieve threading behavior, you must use theThread class.
   Using Threads
   To drive aRunnable object with a thread, you create a separateThread object and hand aRunnable pointer to theThread’s constructor. This performs the thread initialization and then calls theRunnable’srun( ) as an interruptible thread. By drivingLiftOff with aThread, the example below shows how any task can be run in the context of another thread:
   //: C11:BasicThreads.cpp
   // The most basic use of the Thread class.
   //{L} ZThread
   #include "LiftOff.h"
   #include "zthread/Thread.h"
   using namespace ZThread;
   using namespace std;

   int main() {
     try {
       Thread t(new LiftOff(10));
       cout&lt;&lt; "Waiting for LiftOff"&lt;&lt; endl;
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Synchronization_Exception is part of the ZThread library and is the base class for all ZThread exceptions. It will be thrown if there is an error starting or using a thread.
   AThread constructor only needs a pointer to aRunnable object. It will perform the necessary initialization, call thatRunnable’srun( ) member function to start the task, and thenreturn to the calling thread, which in this case is the thread formain( ). In effect, you have made a member function call toLiftOff::run( ), and that function has not yet finished, but you can still perform other operations in themain( ) thread. (This ability is not restricted to themain( ) thread—any thread can start another thread.) You can see this by running the program. Even thoughLiftOff::run( ) has been called, the "Waiting for LiftOff" message will appear before the countdown has completed. Thus, the program is running two functions at once—LiftOff::run( ) andmain( ).
   You can easily add more threads to drive more tasks. Here, you can see how all the threads run in concert with one another:
   //: C11:MoreBasicThreads.cpp
   // Adding more threads.
   //{L} ZThread
   #include "LiftOff.h"
   #include "zthread/Thread.h"
   using namespace ZThread;
   using namespace std;

   int main() {
     const int sz = 5;
     try {
       for(int i = 0; i&lt; sz; i++)
         Thread t(new LiftOff(10, i));
       cout&lt;&lt; "Waiting for LiftOff"&lt;&lt; endl;
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   The second argument for theLiftOff constructor identifies each task. When you run the program, you’ll see that the execution of the different tasks is mixed together as the threads are swapped in and out. This swapping is automatically controlled by the thread scheduler. If you have multiple processors on your machine, the thread scheduler will quietly distribute the threads among the processors.
   Thefor loop can seem a little strange at first, becauset is being created locally inside thefor loop and then immediately goes out of scope and is therefore destroyed. This makes it appear that the thread itself might be immediately lost, but you can see from the output that the threads are indeed running to conclusion. When you create aThread object, the associated thread is registered with the threading system, which keeps it alive. Even though the stack-basedThread object is lost, the thread itself lives on until its associated task completes. Although this may be counterintuitive from a C++ standpoint, the concept of threads is a departure from the norm: a thread creates a separate thread of execution that persists after the function call ends. This departure is reflected in the persistence of the underlying thread after the object vanishes.
   Creating responsive user interfaces
   As stated earlier, one of the motivations for using threading is to create a responsive user interface. Although we don’t covergraphicaluser interfaces in this book, you can still see a simple example of a console-based user interface.
   The following example reads lines from a file and prints them to the console,sleeping (suspending the current thread) for a second after each line is displayed. (You’ll learn more about sleeping later in the chapter). During this process, the program doesn’t look for user input, so the UI is unresponsive:
   //: C11:UnresponsiveUI.cpp
   // Lack of threading produces an unresponsive UI.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   using namespace std;
   using namespace ZThread;

   int main() {
     const int sz = 100; // Buffer size;
     char buf[sz];
     cout&lt;&lt; "Press&lt;Enter&gt; to quit:"&lt;&lt; endl;
     ifstream file("UnresponsiveUI.cpp");
     while(file.getline(buf, sz)) {
       cout&lt;&lt; buf&lt;&lt; endl;
       Thread::sleep(1000); // Time in milliseconds
     }
     // Read input from the console
     cin.get();
     cout&lt;&lt; "Shutting down..."&lt;&lt; endl;
   } ///:~

   To make the program responsive, you can execute a task that displays the file in a separate thread. The main thread can then watch for user input so the program becomes responsive:
   //: C11:ResponsiveUI.cpp
   // Threading for a responsive user interface.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   using namespace ZThread;
   using namespace std;

   class DisplayTask : public Runnable {
     ifstream in;
     static const int sz = 100;
     char buf[sz];
     bool quitFlag;
   public:
     DisplayTask(const string& file) : quitFlag(false) {
       in.open(file.c_str());
     }
     ~DisplayTask() { in.close(); }
     void run() {
       while(in.getline(buf, sz)&& !quitFlag) {
         cout&lt;&lt; buf&lt;&lt; endl;
         Thread::sleep(1000);
       }
     }
     void stop() { quitFlag = true; }
   };

   int main() {
     try {
       cout&lt;&lt; "Press&lt;Enter&gt; to quit:"&lt;&lt; endl;
       DisplayTask* dt = new DisplayTask("ResponsiveUI.cpp");
       Thread t(dt);
       cin.get();
       dt-&gt;stop();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
     cout&lt;&lt; "Shutting down..."&lt;&lt; endl;
   } ///:~

   Now the main thread can respond immediately when you press&lt;Return&gt; and callstop( ) on theDisplayTask.
   This example also shows the need for communication between tasks—the task in the main thread needs to tell theDisplayTask to shut down. Of course, since we have a pointer to theDisplayTask, you might think of just callingdelete on that pointer to kill the task, but this produces unreliable programs. The problem is that the task could be in the middle of something important when you destroy it, and so you are likely to put the program in an unstable state. Here, the task itself decides when it’s safe to shut down. The easiest way to do this is by simply notifying the task that you’d like it to stop by setting a Boolean flag. When the task gets to a stable point it can check that flag and do whatever is necessary to clean up before returning fromrun( ). When the task returns fromrun( ), theThread knows that the task has completed.
   Although this program is simple enough that it should not have any problems, there are some small flaws regarding inter-task communication. This is an important topic that will be covered later in this chapter.
   Simplifying with Executors
   You can simplify your coding overhead by using ZThreadExecutors. Executors provide a layer of indirection between a client and the execution of a task; instead of a client executing a task directly, an intermediate object executes the task.
   We can show this by using anExecutor instead of explicitly creatingThread objects inMoreBasicThreads.cpp. ALiftOff object knows how to run a specific task; like theCommand Pattern, it exposes a single function to be executed. AnExecutor object knows how build the appropriate context to executeRunnable objects. In the following example, theThreadedExecutor creates one thread per task:
   //: c11:ThreadedExecutor.cpp
   //{L} ZThread
   #include "zthread/ThreadedExecutor.h"
   #include "LiftOff.h"
   using namespace ZThread;
   using namespace std;

   int main() {
     try {
       ThreadedExecutor executor;
       for(int i = 0; i&lt; 5; i++)
         executor.execute(new LiftOff(10, i));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Note that in some cases a singleExecutor can be used to create and manage all the threads in your system. You must still place the threading code inside atry block because anExecutor’sexecute( ) function may throwSynchronization_Exceptions if something goes wrong. This is true for any function that involves changing the state of a synchronization object (starting threads, acquiring mutexes, waiting on conditions, etc.), as you will learn later in this chapter.
   The program will exit as soon as all the tasks in theExecutor complete.
   In the previous example, theThreadedExecutor creates a thread for each task that you want to run, but you can easily change the way these tasks are executed by replacing theThreadedExecutor with a different type ofExecutor. In this chapter, using aThreadedExecutor is fine, but in production code it might result in excessive costs from the creation of too many threads. In that case, you can replace it with aPoolExecutor, which will use a limited set of threads to execute the submitted tasks in parallel:
   //: C11:PoolExecutor.cpp
   //{L} ZThread
   #include "zthread/PoolExecutor.h"
   #include "LiftOff.h"
   using namespace ZThread;
   using namespace std;

   int main() {
     try {
       // Constructor argument is minimum number of threads:
       PoolExecutor executor(5);
       for(int i = 0; i&lt; 5; i++)
         executor.execute(new LiftOff(10, i));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   With thePoolExecutor, you do expensive thread allocation once, up front, and the threads are reused when possible. This saves time because you aren’t constantly paying for thread creation overhead for every single task. Also, in an event-driven system, events that require threads to handle them can be generated as quickly as you want by simply fetching them from the pool. You don’t overrun the available resources because thePoolExecutor uses a bounded number ofThread objects. Thus, although this book will useThreadedExecutors, consider usingPoolExecutors in production code.
   AConcurrentExecutor is like aPoolExecutor with a fixed size of one thread. This is useful for anything you want to run in another thread continually (a long-lived task), such as a task that listens to incoming socket connections. It is also handy for short tasks that you want to run in a thread, for example, small tasks that update a local or remote log, or for an event-dispatching thread.
   If more than one task is submitted to aConcurrentExecutor, each task will run to completion before the next task is begun, all using the same thread. In the following example, you’ll see each task completed, in the order that it was submitted, before the next one is begun. Thus, aConcurrentExecutor serializes the tasks that are submitted to it.
   //: C11:ConcurrentExecutor.cpp
   //{L} ZThread
   #include "zthread/ConcurrentExecutor.h"
   #include "LiftOff.h"
   using namespace ZThread;
   using namespace std;

   int main() {
     try {
       ConcurrentExecutor executor;
       for(int i = 0; i&lt; 5; i++)
         executor.execute(new LiftOff(10, i));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Like aConcurrentExecutor, aSynchronousExecutor is used when you want only one task at a time to run, serially instead of concurrently. UnlikeConcurrentExecutor, aSynchronousExecutor doesn’t create or manage threads on it own. It uses the thread that submits the task and thus only acts as a focal point for synchronization. If you haven threads submitting tasks to aSynchronousExecutor, those threads are all blocked onexecute( ). One by one they will be allowed to continue as the previous tasks in the queue complete, but no two tasks are ever run at once.
   For example, suppose you have a number of threads running tasks that use the file system, but you are writing portable code so you don’t want to useflock( ) or another OS-specific call to lock a file. You can run these tasks with aSynchronousExecutor to ensure that only one task at a time is running from any thread. This way, you don’t have to deal with synchronizing on the shared resource (and you won’t clobber the file system in the meantime). A better solution is to actually synchronize on the resource (which you’ll learn about later in this chapter), but aSynchronousExecutor lets you skip the trouble of getting coordinated properly just to prototype something.
   //: C11:SynchronousExecutor.cpp
   //{L} ZThread
   #include "zthread/SynchronousExecutor.h"
   #include "LiftOff.h"
   using namespace ZThread;
   using namespace std;

   int main() {
     try {
       SynchronousExecutor executor;
       for(int i = 0; i&lt; 5; i++)
         executor.execute(new LiftOff(10, i));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   When you run the program, you’ll see that the tasks are executed in the order they are submitted, and each task runs to completion before the next one starts. What you don’t see is that no new threads are created—themain( )thread is used for each task, since in this example, that’s the thread that submits all the tasks. BecauseSynchronousExecutor is primarily for prototyping, you may not use it much in production code.
   Yielding
   If you know that you’ve accomplished what you need to during one pass through a loop in yourrun( ) function (mostrun( ) functions involve a long-running loop), you can give a hint to the thread scheduling mechanism that you’ve done enough and that some other thread might as well have the CPU. This hint (and itis a hint—there’s no guarantee your implementation will listen to it) takes the form of theyield( ) function.
   We can make a modified version of theLiftOff examples by yielding after each loop:
   //: C11:YieldingTask.cpp
   // Suggesting when to switch threads with yield().
   //{L} ZThread
   #include&lt;iostream&gt;
   #include "zthread/Thread.h"
   #include "zthread/ThreadedExecutor.h"
   using namespace ZThread;
   using namespace std;

   class YieldingTask : public Runnable {
     int countDown;
     int id;
   public:
     YieldingTask(int ident = 0) : countDown(5), id(ident) {}
     ~YieldingTask() {
       cout&lt;&lt; id&lt;&lt; " completed"&lt;&lt; endl;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const YieldingTask& yt) {
       return os&lt;&lt; "#"&lt;&lt; yt.id&lt;&lt; ": "&lt;&lt; yt.countDown;
     }
     void run() {
       while(true) {
         cout&lt;&lt; *this&lt;&lt; endl;
         if(--countDown == 0) return;
         Thread::yield();
       }
     }
   };

   int main() {
     try {
       ThreadedExecutor executor;
       for(int i = 0; i&lt; 5; i++)
         executor.execute(new YieldingTask(i));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   You can see that the task’srun( )member function consists entirely of an infinite loop. By usingyield( ), the output is evened up quite a bit over that without yielding. Try commenting out the call toThread::yield( ) to see the difference. In general, however,yield( )is useful only in rare situations, and you can’t rely on it to do any serious tuning of your application.
   Sleeping
   Another way you can control the behavior of your threads is by callingsleep( ) to cease execution of that thread for a given number of milliseconds. In the preceding example, if you replace the call toyield( ) with a call tosleep( ), you get the following:
   //: C11:SleepingTask.cpp
   // Calling sleep() to pause for awhile.
   //{L} ZThread
   #include&lt;iostream&gt;
   #include "zthread/Thread.h"
   #include "zthread/ThreadedExecutor.h"
   using namespace ZThread;
   using namespace std;

   class SleepingTask : public Runnable {
     int countDown;
     int id;
   public:
     SleepingTask(int ident = 0) : countDown(5), id(ident) {}
     ~SleepingTask() {
       cout&lt;&lt; id&lt;&lt; " completed"&lt;&lt; endl;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const SleepingTask& st) {
       return os&lt;&lt; "#"&lt;&lt; st.id&lt;&lt; ": "&lt;&lt; st.countDown;
     }
     void run() {
       while(true) {
         try {
           cout&lt;&lt; *this&lt;&lt; endl;
           if(--countDown == 0) return;
           Thread::sleep(100);
         } catch(Interrupted_Exception& e) {
           cerr&lt;&lt; e.what()&lt;&lt; endl;
         }
       }
     }
   };

   int main() {
     try {
       ThreadedExecutor executor;
       for(int i = 0; i&lt; 5; i++)
         executor.execute(new SleepingTask(i));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Thread::sleep( ) can throw anInterrupted_Exception (you’ll learn about interrupts later), and you can see that this is caught inrun( ). But the task is created and executed inside atry block inmain( ) that catchesSynchronization_Exception (the base class for all ZThread exceptions), so wouldn’t it be possible to just ignore the exception inrun( ) and assume that it will propagate to the handler inmain( )? This won’t work because exceptions won’t propagate across threads back tomain( ). Thus, you must handle any exceptions locally that may arise within a task.
   You’ll notice that the threads tend to run in any order, which means thatsleep( ) is also not a way for you to control the order of thread execution. It just stops the execution of the thread for awhile. The only guarantee that you have is that the thread will sleep at least 100 milliseconds (in this example), but it may take longer before the thread resumes execution, because the thread scheduler still has to get back to it after the sleep interval expires.
   If you must control the order of execution of threads, your best bet is to use synchronization controls (described later) or, in some cases, not to use threads at all, but instead to write your own cooperative routines that hand control to each other in a specified order.
   Priority
   Thepriority of a thread tells the scheduler how important this thread is. Although the order that the CPU runs a set of threads is indeterminate, the scheduler willlean toward running the waiting thread with the highest priority first. However, this doesn’t mean that threads with lower priority aren’t run (that is, you can’t get deadlocked because of priorities). Lower priority threads just tend to run less often.
   Here’sMoreBasicThreads.cpp modified so that the priority levels are demonstrated. The priorities are adjusting by usingThread’ssetPriority( ) function.
   //: C11:SimplePriorities.cpp
   // Shows the use of thread priorities.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include&lt;iostream&gt;
   #include&lt;cmath&gt;
   using namespace ZThread;
   using namespace std;

   class SimplePriorities : public Runnable {
     int countDown;
     volatile double d; // No optimization
     int id;
   public:
     SimplePriorities(int ident = 0): countDown(5),id(ident){}
     ~SimplePriorities() throw() {
       cout&lt;&lt; id&lt;&lt; " completed"&lt;&lt; endl;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const SimplePriorities& sp) {
       return os&lt;&lt; "#"&lt;&lt; sp.id&lt;&lt; " priority: "
        &lt;&lt; Thread().getPriority()
        &lt;&lt; " count: "&lt;&lt; sp.countDown;
     }
     void run() {
       while(true) {
         // An expensive, interruptable operation:
         for(int i = 1; i&lt; 100000; i++)
           d = d + (M_PI + M_E) / (double)i;
         cout&lt;&lt; *this&lt;&lt; endl;
         if(--countDown == 0) return;
       }
     }
   };

   int main() {
     try {
       Thread high(new SimplePriorities);
       high.setPriority(High);
       for(int i = 0; i&lt; 5; i++) {
         Thread low(new SimplePriorities(i));
         low.setPriority(Low);
       }
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Here,operator&lt;&lt;( ) is overridden to display the identifier, priority, andcountDown value of the task.
   You can see that the priority level of threadhigh is at the highest level, and all the rest of the threads are at the lowest level. We are not using anExecutor in this example because we need direct access to the threads in order to set their priorities.
   InsideSimplePriorities::run( ), 100,000 repetitions of a rather expensive floating-point calculation are performed, involvingdouble addition and division. The variabled isvolatile to ensure that no optimization is performed. Without this calculation, you don’t see the effect of setting the priority levels. (Try it: comment out thefor loop containing thedouble calculations.) With the calculation, you see that threadhigh is given a higher preference by the thread scheduler. (At least, this was the behavior on a Windows machine.) The calculation takes long enough that the thread scheduling mechanism jumps in, changes threads, and pays attention to the priorities so that threadh gets preference.
   You can also read the priority of an existing thread withgetPriority( )and change it at any time (not just before the thread is run, as inSimplePriorities.cpp) withsetPriority( ).
   Mapping priorities to operating systems is problematic. For example, Windows 2000 has seven priority levels that are not fixed, so the mapping is indeterminate; Sun’s Solaris has 231levels. The only portable approach is to stick to very large priority granulations, such as theLow,Medium, andHigh used in the ZThread library.
   Sharing limited resources
   You can think of a single-threaded program as one lonely entity moving around through your problem space and doing one thing at a time. Because there’s only one entity, you never have to think about the problem of two entities trying to use the same resource at the same time: problems such as two people trying to park in the same space, walk through a door at the same time, or even talk at the same time.
   With multithreading, things aren’t lonely anymore, but you now have the possibility of two or more threads trying to use the same resource at once. This can cause two different kinds of problems. The first is that the necessary resources may not exist. In C++, the programmer has complete control over the lifetime of objects, and it’s easy to create threads that try to use objects that get destroyed before those threads complete.
   The second problem is that two or more threads may collide when they try to access the same resource at the same time. If you don’t prevent such a collision, you’ll have two threads trying to access the same bank account at the same time, print to the same printer, adjust the same valve, and so on.
   This section introduces the problem of objects that vanish while tasks are still using them and the problem of tasks colliding over shared resources. You’ll learn about the tools that are used to solve these problems.
   Ensuring the existence of objects
   Memory and resource management are major concerns in C++. When you create any C++ program, you have the option of creating objects on the stack or on the heap (usingnew). In a single-threaded program, it’s usually easy to keep track of object lifetimes so that you don’t try to use objects that are already destroyed.
   The examples shown in this chapter createRunnable objects on the heap usingnew, but you’ll notice that these objects are neverexplicitly deleted. However, you can see from the output when you run the programs that the thread library keeps track of each task and eventually deletes it, because the destructors for the tasks are called. This happens when theRunnable::run( )member function completes—returning fromrun( ) tells the thread that the task is finished.
   Burdening the thread with deleting a task is a problem. That thread doesn’t necessarily know if another thread still needs to make a reference to thatRunnable, and so theRunnable may be prematurely destroyed. To deal with this problem, tasks in ZThreads are automatically reference-counted by the ZThread library mechanism. A task is maintained until the reference count for that task goes to zero, at which point the task is deleted. This means that tasks must always be deleted dynamically, and so they cannot be created on the stack. Instead, tasks must always be created usingnew, as you see in all the examples in this chapter.
   Often you must also ensure that non-task objects stay alive as long as tasks need them. Otherwise, it’s easy for objects that are used by tasks to go out of scope before those tasks are completed. If this happens, the tasks will try to access illegal storage and will cause program faults. Here’s a simple example:
   //: C11:Incrementer.cpp
   // Destroying objects while threads are still
   // running will cause serious problems.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class Count {
     static const int sz = 100;
     int n[sz];
   public:
     void increment() {
       for(int i = 0; i&lt; sz; i++)
         n[i]++;
     }
   };

   class Incrementer : public Runnable {
     Count* count;
   public:
     Incrementer(Count* c) : count(c) {}
     void run() {
       for(int n = 100; n&gt; 0; n--) {
         Thread::sleep(250);
         count-&gt;increment();
       }
     }
   };

   int main() {
     cout&lt;&lt; "This will cause a segmentation fault!"&lt;&lt; endl;
     Count count;
     try {
       Thread t0(new Incrementer(&count));
       Thread t1(new Incrementer(&count));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   TheCount class may seem like overkill at first, but ifn is only a singleint (rather than an array), the compiler can put it into a register and that storage will still be available (albeit technically illegal) after theCount object goes out of scope. It’s difficult to detect the memory violation in that case. Your results may vary depending on your compiler and operating system, but try making itn singleint and see what happens. In any event, ifCount contains an array ofints as above, the compiler is forced to put it on the stack and not in a register.
   Incrementer is a simple task that uses aCount object. Inmain( ), you can see that theIncrementer tasks are running for long enough that theCount object will go out of scope, and so the tasks try to access an object that no longer exists. This produces a program fault.
   To fix the problem, we must guarantee that any objects shared between tasks will be around as long as those tasks need them. (If the objects were not shared, they could be composed directly into the task’s class and thus tie their lifetime to that task.) Since we don’t want the static program scope to control the lifetime of the object, we put the object on the heap. And to make sure that the object is not destroyed until there are no other objects (tasks, in this case) using it, we use reference counting.
   Reference counting was explained thoroughly in volume one of this book and further revisited in this volume. The ZThread library includes a template calledCountedPtr that automatically performs reference counting anddeletes an object when the reference count goes to zero. Here’s the above program modified to useCountedPtr to prevent the fault:
   //: C11:ReferenceCounting.cpp
   // A CountedPtr prevents too-early destruction.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/CountedPtr.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class Count {
     static const int sz = 100;
     int n[sz];
   public:
     void increment() {
       for(int i = 0; i&lt; sz; i++)
         n[i]++;
     }
   };

   class Incrementer : public Runnable {
     CountedPtr&lt;Count&gt; count;
   public:
     Incrementer(const CountedPtr&lt;Count&gt;& c ) : count(c) {}
     void run() {
       for(int n = 100; n&gt; 0; n--) {
         Thread::sleep(250);
         count-&gt;increment();
       }
     }
   };

   int main() {
     CountedPtr&lt;Count&gt; count(new Count);
     try {
       Thread t0(new Incrementer(count));
       Thread t1(new Incrementer(count));
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Incrementer now contains aCountedPtr object, which manages aCount. Inmain( ), theCountedPtr objects are passed into the twoIncrementer objects by value, so the copy-constructor is called, increasing the reference count. As long as the tasks are still running, the reference count will be nonzero, and so theCount object managed by theCountedPtr will not be destroyed. Only when all the tasks using theCount are completed willdelete be called (automatically) on theCount object by theCountedPtr.
   Whenever you have objects that are used by more than one task, you’ll almost always need to manage those objects using theCountedPtr template in order to prevent problems arising from object lifetime issues.
   Improperly accessing resources
   Consider the following example in which one task generates even numbers and other tasks consume those numbers. In this case, the only job of the consumer threads is to check the validity of the even numbers.
   We’ll first defineEvenChecker, the consumer thread, since it will be reused in all the subsequent examples. To decoupleEvenChecker from the various types of generators that we will experiment with, we’ll create an interface calledGenerator, which contains the minimum necessary functions thatEvenChecker must know about: that it has anextValue( ) function and that it can be canceled.
   //: C11:EvenChecker.h
   #ifndef EVENCHECKER_H
   #define EVENCHECKER_H
   #include "zthread/CountedPtr.h"
   #include "zthread/Thread.h"
   #include "zthread/Cancelable.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;iostream&gt;

   class Generator : public ZThread::Cancelable {
     bool canceled;
   public:
     Generator() : canceled(false) {}
     virtual int nextValue() = 0;
     void cancel() { canceled = true; }
     bool isCanceled() { return canceled; }
   };

   class EvenChecker : public ZThread::Runnable {
     ZThread::CountedPtr&lt;Generator&gt; generator;
     int id;
   public:
     EvenChecker(ZThread::CountedPtr&lt;Generator&gt;& g, int ident)
     : generator(g), id(ident) {}
     ~EvenChecker() {
       std::cout&lt;&lt; "~EvenChecker "&lt;&lt; id&lt;&lt; std::endl;
     }
     void run() {
       while(!generator-&gt;isCanceled()) {
         int val = generator-&gt;nextValue();
         if(val % 2 != 0) {
           std::cout&lt;&lt; val&lt;&lt; " not even!"&lt;&lt; std::endl;
           generator-&gt;cancel(); // Cancels all EvenCheckers
         }
       }
     }
     // Test any type of generator:
     template&lt;typename GenType&gt; static void test(int n = 10) {
       std::cout&lt;&lt; "Press Control-C to exit"&lt;&lt; std::endl;
       try {
         ZThread::ThreadedExecutor executor;
         ZThread::CountedPtr&lt;Generator&gt; gp(new GenType);
         for(int i = 0; i&lt; n; i++)
           executor.execute(new EvenChecker(gp, i));
       } catch(ZThread::Synchronization_Exception& e) {
         std::cerr&lt;&lt; e.what()&lt;&lt; std::endl;
       }
     }
   };
   #endif // EVENCHECKER_H ///:~

   TheGenerator class introduces the pure abstractCancelable class, which is part of the ZThread library. The goal ofCancelableis to provide a consistent interface to change the state of an object via thecancel( ) function and to see whether the object has been canceled with theisCanceled( ) function. Here, the simple approach of aboolcanceled flag is used, similar to thequitFlag previously seen inResponsiveUI.cpp. Note that in this example the class that isCancelable is notRunnable. Instead, all theEvenChecker tasks that depend on theCancelable object (theGenerator) test it to see if it’s been canceled, as you can see inrun( ). This way, the tasks that share the common resource (theCancelable Generator) watch that resource for the signal to terminate. This eliminates the so-calledrace condition, in which two or more tasks race to respond to a condition and thus collide or otherwise produce inconsistent results. You must be careful to think about and protect against all the possible ways a concurrent system can fail. For example, a task cannot depend on another task, because there’s no guarantee of the order in which tasks will be shut down. Here, by making tasks depend on non-task objects, we eliminate the potential race condition.
   In later sections, you’ll see that the ZThread library contains more general mechanisms for termination of threads.
   Since multipleEvenCheckerobjects may end up sharing aGenerator, theCountedPtrtemplate is used to reference count theGeneratorobjects.
   The last member function inEvenChecker is astaticmember template that sets up and performs a test of any type ofGenerator by creating one inside aCountedPtr and then starting a number ofEvenCheckers that use thatGenerator. If theGenerator causes a failure,test( ) will report it and return; otherwise, you must press Control-C to terminate it.
   EvenChecker tasks constantly read and test the values from their associatedGenerator. Note that ifgenerator-&gt;isCanceled( ) is true,run( ) returns, which tells theExecutor inEvenChecker::test( )that the task is complete. AnyEvenChecker task can callcancel( )on its associatedGenerator, which will cause all otherEvenCheckers using thatGeneratorto gracefully shut down.
   TheEvenGenerator is simple–nextValue( ) produces the next even value:
   //: C11:EvenGenerator.cpp
   // When threads collide.
   //{L} ZThread
   #include "EvenChecker.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class EvenGenerator : public Generator {
     int currentEvenValue;
   public:
     EvenGenerator() { currentEvenValue = 0; }
     ~EvenGenerator() { cout&lt;&lt; "~EvenGenerator"&lt;&lt; endl; }
     int nextValue() {
       currentEvenValue++; // Danger point here!
       currentEvenValue++;
       return currentEvenValue;
     }
   };

   int main() {
     EvenChecker::test&lt;EvenGenerator&gt;();
   } ///:~

   It’s possible for one thread to callnextValue( ) after the first increment ofcurrentEvenValue and before the second (at the place in the code commented "Danger point here!"), in which case the value would be in an "incorrect" state. To prove that this can happen,EvenChecker::test( ) creates a group ofEvenChecker objects to continually read the output of anEvenGenerator and test to see if each one is even. If not, the error is reported and the program is shut down.
   This program may not detect the problem until theEvenGenerator has completed many cycles, depending on the particulars of your operating system and other implementation details. If you want to see it fail much faster, try putting a call toyield( ) between the first and second increments. In any event, itwill eventually fail because theEvenChecker threads are able to access the information inEvenGenerator while it’s in an "incorrect" state.
   Controlling access
   The previous example shows a fundamental problem when using threads: You never know when a thread might be run. Imagine sitting at a table with a fork, about to spear the last piece of food on your plate, and as your fork reaches for it, the food suddenly vanishes (because your thread was suspended and another task came in and stole the food). That’s the problem you’re dealing with when writing concurrent programs.
   Sometimes you don’t care if a resource is being accessed at the same time you’re trying to use it (the food is on some other plate). But for multithreading to work, you need some way to prevent two threads from accessing the same resource, at least during critical periods.
   Preventing this kind of collision is simply a matter of putting a lock on a resource when one thread is using it. The first thread that accesses a resource locks it, and then the other threads cannot access that resource until it is unlocked, at which time another thread locks and uses it, and so on. If the front seat of the car is the limited resource, the child who shouts "Dibs!" acquires the lock.
   Thus, we need to be able to prevent any other tasks from accessing the storage when that storage is not in a proper state. That is, we need to have a mechanism thatexcludes a second task from accessing the storage when a first task is already using it. This idea is fundamental to all multithreading systems and is calledmutual exclusion; the mechanism used abbreviates this tomutex. The ZThread library contains a mutex mechanism declared in the headerMutex.h.
   To solve the problem in the above program, we identify thecritical sections in which mutual exclusion must apply; then weacquire the mutex before entering the critical section andrelease it at the end of the critical section. Only one thread can acquire the mutex at any time, so mutual exclusion is achieved:
   //: C11:MutexEvenGenerator.cpp
   // Preventing thread collisions with mutexes.
   //{L} ZThread
   #include "EvenChecker.h"
   #include "zthread/ThreadedExecutor.h"
   #include "zthread/Mutex.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class MutexEvenGenerator : public Generator {
     int currentEvenValue;
     Mutex lock;
   public:
     MutexEvenGenerator() { currentEvenValue = 0; }
     ~MutexEvenGenerator() {
       cout&lt;&lt; "~MutexEvenGenerator"&lt;&lt; endl;
     }
     int nextValue() {
       lock.acquire();
       currentEvenValue++;
       Thread::yield();
       currentEvenValue++;
       int rval = currentEvenValue;
       lock.release();
       return rval;
     }
   };

   int main() {
     EvenChecker::test&lt;MutexEvenGenerator&gt;();
   } ///:~

   The only changes here are inMutexEvenGenerator, which adds aMutex calledlock and usesacquire( ) andrelease( ) innextValue( ). Note thatnextValue( ) must capture the return value inside the critical section, because if you return from inside the critical section, you won’t release the lock and will thus prevent it from being acquired again. (This usually leads todeadlock, which you’ll learn about at the end of this chapter.)
   The first thread that entersnextValue( ) acquires the lock, and any further threads that try to acquire the lock are blocked from doing so until the first thread releases the lock. At that point, the scheduling mechanism selects another thread that is waiting on the lock. This way, only one thread at a time can pass through the code that is guarded by the mutex.
   Simplified coding with Guards
   The use of mutexes rapidly becomes complicated when exceptions are introduced. To make sure that the mutex is always released, you must ensure that each possible exception path includes a call torelease( ). In addition, any function that has multiple return paths must carefully ensure that it callsrelease( ) at the appropriate points.
   These problems can be easily solved by using the fact that a stack-based object has a destructor that is always called regardless of how you exit from a function scope. In the ZThread library, this is implemented as theGuard template. TheGuard template creates objects on the local stack thatacquire( )aLockable object when constructed andrelease( ) that lock when destroyed. Because theGuard object exists on the local stack, it will automatically be destroyed regardless of how the function exits and will therefore always unlock theLockable object. Here’s the above example reimplemented usingGuards:
   //: C11:GuardedEvenGenerator.cpp
   // Simplifying mutexes with the Guard template.
   //{L} ZThread
   #include "EvenChecker.h"
   #include "zthread/ThreadedExecutor.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class GuardedEvenGenerator : public Generator {
     int currentEvenValue;
     Mutex lock;
   public:
     GuardedEvenGenerator() { currentEvenValue = 0; }
     ~GuardedEvenGenerator() {
       cout&lt;&lt; "~GuardedEvenGenerator"&lt;&lt; endl;
     }
     int nextValue() {
       Guard&lt;Mutex&gt; g(lock);
       currentEvenValue++;
       Thread::yield();
       currentEvenValue++;
       return currentEvenValue;
     }
   };

   int main() {
     EvenChecker::test&lt;GuardedEvenGenerator&gt;();
   } ///:~

   Note that the temporary return value is no longer necessary innextValue( ). In general, there is less code to write, and the opportunity for user error is greatly reduced.
   An interesting feature of theGuard template is that it can be used to manipulate other guards safely. For example, a secondGuard can be used to temporarily unlock a guard:
   //: C11:TemporaryUnlocking.cpp
   // Temporarily unlocking another guard.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   using namespace ZThread;

   class TemporaryUnlocking {
     Mutex lock;
   public:
     void f() {
       Guard&lt;Mutex&gt; g(lock);
       // lock is acquired
       // ...
       {
         Guard&lt;Mutex, UnlockedScope&gt; h(g);
         // lock is released
         // ...
         // lock is acquired
       }
       // ...
       // lock is released
     }
   };

   int main() {
     TemporaryUnlocking t;
     t.f();
   } ///:~

   A Guard can also be used to try to acquire a lock for a certain amount of time and then abort:
   //: C11:TimedLocking.cpp
   // Limited time locking.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   using namespace ZThread;

   class TimedLocking {
     Mutex lock;
   public:
     void f() {
       Guard&lt;Mutex, TimedLockedScope&lt;500&gt;&gt; g(lock);
       // ...
     }
   };

   int main() {
     TimedLocking t;
     t.f();
   } ///:~

   In this example, aTimeout_Exception will be thrown if the lock cannot be acquired within 500 milliseconds.
   Synchronizing entire classes
   The ZThread library also provides aGuardedClass template to automatically create a synchronized wrapper for an entire class. This means that every member function in the class will automatically be guarded:
   //: C11:SynchronizedClass.cpp
   //{L} ZThread
   #include "zthread/GuardedClass.h"
   using namespace ZThread;

   class MyClass {
   public:
     void func1() {}
     void func2() {}
   };

   int main() {
     MyClass a;
     a.func1(); // not synchronized
     a.func2(); // not synchronized
     GuardedClass&lt;MyClass&gt; b(new MyClass);
     // Synchronized calls, only one thread at a time allowed:
     b-&gt;func1();
     b-&gt;func2();
   } ///:~

   Objecta is a not synchronized, sofunc1( ) andfunc2( ) can be called at any time by any number of threads. Objectb is protected by theGuardedClass wrapper, so each member function is automatically synchronized and only one function per object can be called any time.
   The wrapper locks at a class level of granularity, which may affect performance in some cases. If a class contains some unrelated functions, it may be better to synchronize those functions internally with two different locks. However, if you find yourself doing this, it means that one class contains groups of data that may not be strongly associated. Consider breaking the class into two classes.
   Guarding all member functions of a class with a mutex does not automatically make that class thread-safe. You must carefully consider all threading issues in order to guarantee thread safety.
   Thread local storage
   A second way to eliminate the problem of tasks colliding over shared resources is to eliminate the sharing of variables, which can be done by creating different storage for the same variable, for each different thread that uses an object. Thus, if you have five threads using an object with a variablex,thread local storage automatically generates five different pieces of storage forx. Fortunately, the creation and management of thread local storage is taken care of automatically by ZThread’sThreadLocal template, as seen here:
   //: C11:ThreadLocalVariables.cpp
   // Automatically giving each thread its own storage.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include "zthread/ThreadedExecutor.h"
   #include "zthread/Cancelable.h"
   #include "zthread/ThreadLocal.h"
   #include "zthread/CountedPtr.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class ThreadLocalVariables : public Cancelable {
     ThreadLocal&lt;int&gt; value;
     bool canceled;
     Mutex lock;
   public:
     ThreadLocalVariables() : canceled(false) {
       value.set(0);
     }
     void increment() { value.set(value.get() + 1); }
     int get() { return value.get(); }
     void cancel() {
       Guard&lt;Mutex&gt; g(lock);
       canceled = true;
     }
     bool isCanceled() {
       Guard&lt;Mutex&gt; g(lock);
       return canceled;
     }
   };

   class Accessor : public Runnable {
     int id;
     CountedPtr&lt;ThreadLocalVariables&gt; tlv;
   public:
     Accessor(CountedPtr&lt;ThreadLocalVariables&gt;& tl, int idn)
     : id(idn), tlv(tl) {}
     void run() {
       while(!tlv-&gt;isCanceled()) {
         tlv-&gt;increment();
         cout&lt;&lt; *this&lt;&lt; endl;
       }
     }
     friend ostream&
       operator&lt;&lt;(ostream& os, Accessor& a) {
       return os&lt;&lt; "#"&lt;&lt; a.id&lt;&lt; ": "&lt;&lt; a.tlv-&gt;get();
     }
   };

   int main() {
     cout&lt;&lt; "Press&lt;Enter&gt; to quit"&lt;&lt; endl;
     try {
       CountedPtr&lt;ThreadLocalVariables&gt;
         tlv(new ThreadLocalVariables);
       const int sz = 5;
       ThreadedExecutor executor;
       for(int i = 0; i&lt; sz; i++)
         executor.execute(new Accessor(tlv, i));
       cin.get();
       tlv-&gt;cancel(); // All Accessors will quit
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   When you create aThreadLocal object by instantiating the template, you are only able to access the contents of the object using theget( ) andset( ) functions. Theget( )function returns a copy of the object that is associated with that thread, andset( ) inserts its argument into the object stored for that thread, returning the old object that was in storage. You can see this is use inincrement( ) andget( ) inThreadLocalVariables.
   Sincetlv is shared by multipleAccessor objects, it is written asCancelable so that theAccessors can be signaled when we want to shut the system down.
   When you run this program, you’ll see evidence that the individual threads are each allocated their own storage.
   Terminating tasks
   In previous examples, we have seen the use of a "quit flag" or theCancelable interface in order to terminate a task. This is a reasonable approach to the problem. However, in some situations the task must be terminated more abruptly. In this section, you’ll learn about the issues and problems of such termination.
   First, let’s look at an example that not only demonstrates the termination problem but is also an additional example of resource sharing. To present this example, we’ll first need to solve the problem of iostream collision
   Preventing iostream collision
   You may have noticed in previous examples that the output is sometimes garbled. The problem is that C++ iostreams were not created with threading in mind, and so there’s nothing to keep one thread’s output from interfering with another thread’s output.
   To solve the problem, we need to create the entire output packet first and then explicitly decide when to try to send it to the console. One simple solution is to write the information to anostringstream and then use a single object with a mutex as the point of output among all threads, to prevent more than one thread from writing at the same time:
   //: C11:Display.h
   // Prevents ostream collisions
   #ifndef DISPLAY_H
   #define DISPLAY_H
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;

   class Display { // Share one of these among all threads
     ZThread::Mutex iolock;
   public:
     void output(std::ostringstream& os) {
       ZThread::Guard&lt;ZThread::Mutex&gt; g(iolock);
       std::cout&lt;&lt; os.str();
     }
   };
   #endif // DISPLAY_H ///:~

   This way, all of the standardoperator&lt;&lt;( ) functions are predefined for us and the object can be built in memory using familiarostream operators. When a task wants to display output, it creates a temporaryostringstreamobject that it uses to build up the desired output message. When it callsoutput( ), the mutex prevents multiple threads from writing to thisDisplay object. (You must use only oneDisplay object in your program, as you’ll see in the following examples.)
   This just shows the basic idea, but if necessary, you can build a more elaborate framework. For example, you could enforce the requirement that there be only oneDisplay object in a program by making it aSingleton. (The ZThread library has aSingleton template to support Singletons.)
   The ornamental garden
   In this simulation, the garden committee would like to know how many people enter the garden each day though its multiple gates. Each gate has a turnstile or some other kind of counter, and after the turnstile count is incremented, a shared count is incremented that represents the total number of people in the garden.
   //: C11:OrnamentalGarden.cpp
   //{L} ZThread
   #include "Display.h"
   #include "zthread/Thread.h"
   #include "zthread/FastMutex.h"
   #include "zthread/Guard.h"
   #include "zthread/ThreadedExecutor.h"
   #include "zthread/CountedPtr.h"
   #include&lt;vector&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   using namespace ZThread;
   using namespace std;

   class Count : public Cancelable {
     FastMutex lock;
     int count;
     bool paused, canceled;
   public:
     Count() : count (0), paused(false), canceled(false) {
       srand(time(0)); // Seed the random number generator
     }
     int increment() {
       // Comment the following line to see counting fail:
       Guard&lt;FastMutex&gt; g(lock);
       int temp = count ;
       if(rand()&lt; RAND_MAX/2) // Yield half the time
         Thread::yield();
       return (count  = ++temp);
     }
     int value() {
       Guard&lt;FastMutex&gt; g(lock);
       return count;
     }
     void cancel() {
       Guard&lt;FastMutex&gt; g(lock);
       canceled = true;
     }
     bool isCanceled() {
       Guard&lt;FastMutex&gt; g(lock);
       return canceled;
     }
     bool pause() {
       Guard&lt;FastMutex&gt; g(lock);
       paused = true;
     }
     bool isPaused() {
       Guard&lt;FastMutex&gt; g(lock);
       return paused;
     }
   };

   class Entrance : public Runnable {
     CountedPtr&lt;Count&gt; count;
     CountedPtr&lt;Display&gt; display;
     int number;
     int id;
     bool waitingForCancel;
   public:
     Entrance(CountedPtr&lt;Count&gt;& cnt,
       CountedPtr&lt;Display&gt;& disp, int idn)
     : count(cnt), display(disp), id(idn), number(0),
       waitingForCancel(false) {}
     void run() {
       while(!count-&gt;isPaused()) {
         number++;
         {
           ostringstream os;
           os&lt;&lt; *this&lt;&lt; " Total: "
             &lt;&lt; count-&gt;increment()&lt;&lt; endl;
           display-&gt;output(os);
         }
         Thread::sleep(100);
       }
       waitingForCancel = true;
       while(!count-&gt;isCanceled()) // Hold here...
         Thread::sleep(100);
       ostringstream os;
       os&lt;&lt; "Terminating "&lt;&lt; *this&lt;&lt; endl;
       display-&gt;output(os);
     }
     int getValue() {
       while(count-&gt;isPaused()&& !waitingForCancel)
         Thread::sleep(100);
       return number;
     }
     friend ostream&
     operator&lt;&lt;(ostream& os, const Entrance& e) {
       return os&lt;&lt; "Entrance "&lt;&lt; e.id&lt;&lt; ": "&lt;&lt; e.number;
     }
   };

   int main() {
     cout&lt;&lt; "Press&lt;ENTER&gt; to quit"&lt;&lt; endl;
     CountedPtr&lt;Count&gt; count(new Count);
     vector&lt;Entrance*&gt; v;
     CountedPtr&lt;Display&gt; display(new Display);
     const int sz = 5;
     try {
       ThreadedExecutor executor;
       for(int i = 0; i&lt; sz; i++) {
         Entrance* task = new Entrance(count, display, i);
         executor.execute(task);
         // Save the pointer to the task:
         v.push_back(task);
       }
       cin.get(); // Wait for user to press&lt;Enter&gt;
       count-&gt;pause(); // Causes tasks to stop counting
       int sum = 0;
       vector&lt;Entrance*&gt;::iterator it = v.begin();
       while(it != v.end()) {
         sum += (*it)-&gt;getValue();
         it++;
       }
       ostringstream os;
       os&lt;&lt; "Total: "&lt;&lt; count-&gt;value()&lt;&lt; endl
         &lt;&lt; "Sum of Entrances: "&lt;&lt; sum&lt;&lt; endl;
       display-&gt;output(os);
       count-&gt;cancel(); // Causes threads to quit
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Count is the class that keeps the master count of garden visitors. The singleCount object defined inmain( ) ascountis held as aCountedPtr inEntrance and thus is shared by allEntrance objects. AFastMutex calledlockis used in this example instead of an ordinaryMutex because aFastMutex uses the native operating system mutex and will thus yield more interesting results.
   AGuard is used withlock inincrement( ) to synchronize access tocount. This function usesrand( ) to cause ayield( ) roughly half the time, in between fetchingcount intotempand incrementing and storingtempback intocount. Because of this, if you comment out theGuard object definition, you will rapidly see the program break because multiple threads will be accessing and modifyingcount simultaneously.
   TheEntrance class also keeps a localnumber with the number of visitors that have passed through this particular entrance. This provides a double-check against thecount object to make sure that the proper number of visitors is being recorded.Entrance::run( ) simply incrementsnumber and thecount object and sleeps for 100 milliseconds.
   In main, avector&lt;Entrance*&gt; is loaded with eachEntrance that is created. After the user presses&lt;Enter&gt;, thisvectoris used to iterate over all the individualEntrance values and total them.
   This program goes to quite a bit of extra trouble to shut everything down in a stable fashion. Part of the reason for this is to show just how careful you must be when terminating a multithreaded program, and part of the reason is to demonstrate the value ofinterrupt( ), which you will learn about shortly.
   All the communication between theEntrance objects takes place through the singleCount object. When the user presses&lt;Enter&gt;,main( ) sends thepause( ) message tocount. Since eachEntrance::run( ) is watching thecount object to see whether it is paused, this causes eachEntrance to move into thewaitingForCancel state, where it is no longer counting, but it is still alive. This is essential becausemain( ) must still be able to safely iterate over each object in thevector&lt;Entrance*&gt;. Note that because there is a slight possibility that the iteration might occur before anEntrance has finished counting and moved into thewaitingForCancel state, thegetValue( ) function cycles through calls tosleep( ) until the object moves intowaitingForCancel. (This is one form of what is called abusy wait, which is undesirable. You’ll see the preferred approach of usingwait( ) later in the chapter.) Oncemain( ) completes its iteration through thevector&lt;Entrance*&gt;, thecancel( ) message is sent to thecount object, and once again all theEntrance objects are watching for this state change. At this point, they print a termination message and exit fromrun( ), which causes each task to be destroyed by the threading mechanism.
   As this program runs, you will see the total count and the count at each entrance displayed as people walk through a turnstile. If you comment out theGuard object inCount::increment( ), you’ll notice that the total number of people is not what you expect it to be. The number of people counted by each turnstile will be different from the value incount. As long as theMutex is there to synchronize access to theCounter, things work correctly. Keep in mind thatCount::increment( ) exaggerates the potential for failure by usingtemp andyield( ). In real threading problems, the possibility for failure may be statistically small, so you can easily fall into the trap of believing that things are working correctly. Just as in the example above, there are likely to be hidden problems that haven’t occurred to you, so be exceptionally diligent when reviewing concurrent code.
   Atomic operations
   Note thatCount::value( ) returns the value ofcountusing aGuard object for synchronization. This brings up an interesting point, because this code willprobably work fine with most compilers and systems without synchronization. The reason is that, in general, a simple operation such as returning anint will be anatomic operation, which means that it will probably happen in a single microprocessor instruction that will not get interrupted. (The multithreading mechanism is unable to stop a thread in the middle of a microprocessor instruction.) That is, atomic operations are not interruptible by the threading mechanism and thus do not need to be guarded.[126] In fact, if we removed the fetch ofcount intotemp and removed theyield( ), and instead simply incrementedcount directly, we probably wouldn’t need a lock at all because the increment operation isusually atomic, as well.
   The problem is that the C++ standard doesn’t guarantee atomicity for any of these operations. Although operations such as returning anint and incrementing anint are almost certainly atomic on most machines, there’s no guarantee. And because there’s no guarantee, you have to assume the worst. Sometimes you might investigate the atomicity behavior on a particular machine (usually by looking at assembly language) and write code based on those assumptions. That’s always dangerous and ill-advised. It’s too easy for that information to be lost or hidden, and the next person that comes along may assume that this code can be ported to another machine and then go mad tracking down the occasional glitch caused by thread collisions.
   So, while removing the guard onCount::value( ) seems to work, it’s not airtight, and thus on some machines you may see aberrant behavior.
   Terminating when blocked
   Entrance::run( ) in the previous example includes a call tosleep( ) in the main loop. We know that in that example the sleep will eventually wake up and the task will reach the top of the loop where it has an opportunity to break out of that loop by checking theisPaused( ) status. However,sleep( ) is just one situation in which a thread isblocked from executing, and sometimes you must terminate a task that’s blocked.
   Thread states
   A thread can be in any one of four states:
   1.New: A thread remains in this state only momentarily, as it is being created. It allocates any necessary system resources and performs initialization. At this point it becomes eligible to receive CPU time. The scheduler will then transition this thread to therunnable orblocked state.
   2.Runnable: This means that a threadcan be run when the time-slicing mechanism has CPU cycles available for the thread. Thus, the thread might or might not be running at any moment, but there’s nothing to prevent it from being run if the scheduler can arrange it; it’s not dead or blocked.
   3.Blocked: The thread could be run, but something prevents it. (It might be waiting for I/O to complete, for example.) While a thread is in the blocked state, the scheduler will simply skip it and not give it any CPU time. Until a thread reenters therunnable state, it won’t perform any operations.
   4.Dead: A thread in the dead state is no longer schedulable and is not eligible to receive any CPU time. Its task is completed, and it is no longerrunnable. The normal way for a thread to die is by returning from itsrun( )function.
   Becoming blocked
   A thread is blocked when it cannot continue running. A thread can become blocked for the following reasons:
   ·         You’ve put the thread to sleep by callingsleep(milliseconds), in which case it will not be run for the specified time.
   ·         You’ve suspended the execution of the thread withwait( ). It will not become runnable again until the thread gets thesignal( ) orbroadcast( ) message. We’ll examine these in a later section.
   ·         The thread is waiting for some I/O to complete.
   ·         The thread is trying to enter a block of code that is guarded by a mutex, and that mutex has already been acquired by another thread.
   The problem we need to look at now is this: sometimes you want to terminate a thread that is in a blocked state. It can be blocked for any of the reasons in the above list (exceptfor IO, as you’ll see). If you can’t wait for it to get to a point in the code where it can check a state value and decide to terminate on its own, you have to abort the thread out of its blocked state.
   Interruption
   As you might imagine, it’s much messier to break out of the middle of a loop than it is to wait for the loop to get to a test ofisCanceled( ) (or some other place where the programmer is ready to leave the loop). When you break out of a blocked task, you might be breaking out of yourrun( ) loop in a place where you must destroy objects and clean up resources. Because of this, breaking out of the middle of arun( ) loop in a task is more like throwing an exception than anything else, so in ZThreads, exceptions are used for this kind of abort. (This walks the fine edge of being an inappropriate use of exceptions because it means you are often using them for control flow.) To return to a known good state when terminating a task this way, carefully consider the execution paths of your code and properly clean up everything inside thecatch clause. We’ll look at these issues in this section.
   To terminate a blocked thread, the ZThread library provides theThread::interrupt( ) function. This sets theinterrupted status for that thread. A thread with its interrupted status set will throw anInterrupted_Exception if it is already blocked or it attempts a blocking operation. The interrupted status will be reset when the exception is thrown or if the task callsThread::interrupted( ). As you’ll see,Thread::interrupted( ) provides a second way to leave yourrun( ) loop, without throwing an exception.
   Here’s an example that shows the basics ofinterrupt( ):
   //: C11:Interrupting.cpp
   // Interrupting a blocked thread.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class Blocked : public Runnable {
   public:
     void run() {
       try {
         Thread::sleep(1000);
         cout&lt;&lt; "Waiting for get() in run():";
         cin.get();
       } catch(Interrupted_Exception&) {
         cout&lt;&lt; "Caught Interrupted_Exception"&lt;&lt; endl;
         // Exit the task
       }
     }
   };

   int main(int argc, char* argv[]) {
     try {
       Thread t(new Blocked);
       if(argc&gt; 1)
         Thread::sleep(1100);
       t.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   You can see thatrun( ) containstwo points where blocking can occur: the call toThread::sleep(1000) and the call tocin.get( ). By giving the program any command-line argument, you tellmain( ) to sleep long enough that the task will finish itssleep( ) and move into thecin.get( ). If you don’t give the program an argument, thesleep( ) inmain( ) is skipped. In this case, the call tointerrupt( ) will occur while the task is sleeping, and you’ll see that this will causeInterrupted_Exception to be thrown. If you give the program a command-line argument, you’ll discover that a task cannot be interrupted if it is blocked on IO. That is, you can interrupt out of any blocking operationexcept IO.
   This is a little disconcerting if you’re creating a thread that performs IO, because it means that I/O has the potential of locking your multithreaded program. The problem is that, again, C++ was not designed with threading in mind; quite the opposite, it effectively pretends that threading doesn’t exist. Thus, the iostream library is not thread-friendly. If the new C++ standard decides to add thread support, the iostream library may need to be reconsidered in the process.
   Blocked by a mutex
   In the previous list of ways to become blocked, the last one happens when you’re trying to call a function whose mutex has already been acquired. In this situation, the calling task will be suspended until the mutex becomes available. The following example tests whether this kind of blocking is interruptible:
   //: C11:Interrupting2.cpp
   // Interrupting a thread blocked
   // with a synchronization guard.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include&lt;iostream&gt;
   using namespace ZThread;
   using namespace std;

   class BlockedMutex {
     Mutex lock;
   public:
     BlockedMutex() {
       lock.acquire();
     }
     void f() {
       Guard&lt;Mutex&gt; g(lock);
       // This will never be available
     }
   };

   class Blocked2 : public Runnable {
     BlockedMutex blocked;
   public:
     void run() {
       try {
         cout&lt;&lt; "Waiting for f() in BlockedMutex"&lt;&lt; endl;
         blocked.f();
       } catch(Interrupted_Exception& e) {
         cerr&lt;&lt; e.what()&lt;&lt; endl;
         // Exit the task
       }
     }
   };

   int main(int argc, char* argv[]) {
     try {
       Thread t(new Blocked2);
       t.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   The classBlockedMutex has a constructor that acquires the object’s ownMutex and never releases it. For that reason, if you try to callf( ), you will always be blocked because theMutex cannot be acquired. InBlocked2, therun( ) function will therefore be stopped at the call toblocked.f( ). When you run the program you’ll see that, unlike the iostream call,interrupt( ) can break out of a call that’s blocked by a mutex.
   Checking for an interrupt
   Note that when you callinterrupt( )on a thread, the only time that the interrupt occurs is when the task enters, or is already inside, a blocking operation (except, as you’ve seen, in the case of IO, where you’re just stuck). But what if you’ve written code that may or may not make such a blocking call, depending on the conditions in which it is run? If you can only exit by throwing an exception on a blocking call, you won’t always be able to leave therun( )loop. Thus, if you callinterrupt( ) to stop a task, your task needs asecond opportunity to exit in the event that yourrun( ) loop doesn’t happen to be making any blocking calls.
   This opportunity is presented by theinterrupted status, which is set by the call tointerrupt( ). You check for the interrupted status by callinginterrupted( ). This not only tells you whetherinterrupt( ) has been called, it also clears the interrupted status. Clearing the interrupted status ensures that the framework will not notify you twice about a task being interrupted. You will be notified via either a singleInterrupted_Exception, or a single successfulThread::interrupted( ) test. If you want to check again to see whether you were interrupted, you can store the result when you callThread::interrupted( ).
   The following example shows the typical idiom that you should use in yourrun( ) function to handle both blocked and non-blocked possibilities when the interrupted status is set:
   //: C11:Interrupting3.cpp
   // General idiom for interrupting a task.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include&lt;iostream&gt;
   #include&lt;cmath&gt;
   #include&lt;cstdlib&gt;
   using namespace ZThread;
   using namespace std;

   class NeedsCleanup {
     int id;
   public:
     NeedsCleanup(int ident) : id(ident) {
       cout&lt;&lt; "NeedsCleanup "&lt;&lt; id&lt;&lt; endl;
     }
     ~NeedsCleanup() {
       cout&lt;&lt; "~NeedsCleanup "&lt;&lt; id&lt;&lt; endl;
     }
   };

   class Blocked3 : public Runnable {
     volatile double d;
   public:
     Blocked3() : d(0.0) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           point1:
           NeedsCleanup n1(1);
           cout&lt;&lt; "Sleeping"&lt;&lt; endl;
           Thread::sleep(1000);
           point2:
           NeedsCleanup n2(2);
           cout&lt;&lt; "Calculating"&lt;&lt; endl;
           // A time-consuming, non-blocking operation:
           for(int i = 1; i&lt; 100000; i++)
             d = d + (M_PI + M_E) / (double)i;
         }
         cout&lt;&lt; "Exiting via while() test"&lt;&lt; endl;
       } catch(Interrupted_Exception&) {
         cout&lt;&lt; "Exiting via Interrupted_Exception"&lt;&lt; endl;
       }
     }
   };

   int main(int argc, char* argv[]) {
     if(argc != 2) {
       cerr&lt;&lt; "usage: "&lt;&lt; argv[0]
        &lt;&lt; " delay-in-milliseconds"&lt;&lt; endl;
       exit(1);
     }
     int delay = atoi(argv[1]);
     try {
       Thread t(new Blocked3);
       Thread::sleep(delay);
       t.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   TheNeedsCleanup class emphasizes the necessity of proper resource cleanup if you leave the loop via an exception. Note that no pointers are defined inBlocked3::run( ) because, for exception safety, all resources must be enclosed in stack-based objects so that the exception handler can automatically clean them up by calling the destructor.
   You must give the program a command-line argument which is the delay time in milliseconds before it callsinterrupt( ). By using different delays, you can exitBlocked3::run( ) at different points in the loop: in the blockingsleep( ) call, and in the non-blocking mathematical calculation. You’ll see that ifinterrupt( ) is called after the labelpoint2(during the non-blocking operation), first the loop is completed, then all the local objects are destructed, and finally the loop is exited at the top via thewhile statement. However, ifinterrupt( ) is called betweenpoint1andpoint2(after thewhile statement but before or during the blocking operationsleep( )), the task exits via theInterrupted_Exception. In that case, only the stack objects that have been created up to the point where the exception is thrown are cleaned up, and you have the opportunity to perform any other cleanup in thecatch clause.
   A class designed to respond to aninterrupt( )must establish a policy that ensures it will remain in a consistent state. This generally means that all resource acquisition should be wrapped inside stack-based objects so that the destructors will be called regardless of how therun( )loop exits. Correctly done, code like this can be elegant. Components can be created that completely encapsulate their synchronization mechanisms but are still responsive to an external stimulus (viainterrupt( )) without adding any special functions to an object’s interface.
   Cooperation between threads
   As you’ve seen, when you use threads to run more than one task at a time, you can keep one task from interfering with another task’s resources by using a mutex to synchronize the behavior of the two tasks. That is, if two tasks are stepping on each other over a shared resource (usually memory), you use a mutex to allow only one task at a time to access that resource.
   With that problem solved, you can move on to the issue of getting threads to cooperate, so that multiple threads can work together to solve a problem. Now the issue is not about interfering with one another, but rather about working in unison, since portions of such problems must be solved before other portions can be solved. It’s much like project planning: the footings for the house must be dug first, but the steel can be laid and the concrete forms can be built in parallel, and both of those tasks must be finished before the concrete foundation can be poured. The plumbing must be in place before the concrete slab canbe poured, the concrete slab must be in place before you start framing, and so on. Some of these tasks can be done in parallel, but certain steps require all tasks to be completed before you can move ahead.
   The key issue when tasks are cooperating is handshaking between those tasks. To accomplish this handshaking, we use the same foundation: the mutex, which in this case guarantees that only one task can respond to a signal. This eliminates any possible race conditions. On top of the mutex, we add a way for a task to suspend itself until some external state changes ("the plumbing is now in place"), indicating that it’s time for that task to move forward. In this section, we’ll look at the issues of handshaking between tasks, the problems that can arise, and their solutions.
   Wait and signal
   In ZThreads, the basic class that uses a mutex and allows task suspension is theCondition, and you can suspend a task by callingwait( ) on aCondition. When external state changes take place that might mean that a task should continue processing, you notify the task by callingsignal( ), to wake up one task, orbroadcast( ), to wake up all tasks that have suspended themselves on thatCondition object.
   There are two forms ofwait( ). The first takes an argument in milliseconds that has the same meaning as insleep( ): "pause for this period of time." The difference is that in a timedwait( ):
   1.       TheMutex that is controlled by theCondition object is released during thewait( ).
   2.      You can come out of thewait( ) due to asignal( ) or abroadcast( ), as well as by letting the clock run out.
   The second form ofwait( ) takes no arguments; this version is more commonly used. It also releases the mutex, but thiswait( ) suspends the thread indefinitely until thatCondition object receives asignal( ) orbroadcast( ).
   Typically, you usewait( ) when you’re waiting for some condition to change that is under the control of forces outside the current function. (Often, this condition will be changed by another thread.) You don’t want to idly loop while testing the condition inside your thread; this is called a "busy wait," and it’s a bad use ofCPU cycles. Thus,wait( ) allows you to suspend the thread while waiting for the world to change, and only when asignal( ) orbroadcast( )occurs (suggesting that something of interest may have happened), does the thread wake up and check for changes. Therefore,wait( ) provides a way to synchronize activities between threads.
   Let’s look at a simple example.WaxOMatic.cpp applies wax to aCarand polishes it using two separate processes. The polishing process cannot do its job until the application process is finished, and the application process must wait until the polishing process is finished before it can put on another coat of wax. BothWaxOn andWaxOff use theCar object, which contains aCondition that it uses to suspend a thread insidewaitForWaxing( ) orwaitForBuffing( ):
   //: C11:WaxOMatic.cpp
   // Basic thread cooperation.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include "zthread/Condition.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace ZThread;
   using namespace std;

   class Car {
     Mutex lock;
     Condition condition;
     bool waxOn;
   public:
     Car() : condition(lock), waxOn(false) {}
     void waxed() {
       Guard&lt;Mutex&gt; g(lock);
       waxOn = true; // Ready to buff
       condition.signal();
     }
     void buffed() {
       Guard&lt;Mutex&gt; g(lock);
       waxOn = false; // Ready for another coat of wax
       condition.signal();
     }
     void waitForWaxing() {
       Guard&lt;Mutex&gt; g(lock);
       while(waxOn == false)
         condition.wait();
     }
     void waitForBuffing() {
       Guard&lt;Mutex&gt; g(lock);
       while(waxOn == true)
         condition.wait();
     }
   };

   class WaxOn : public Runnable {
     CountedPtr&lt;Car&gt; car;
   public:
     WaxOn(CountedPtr&lt;Car&gt;& c) : car(c) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           cout&lt;&lt; "Wax On!"&lt;&lt; endl;
           Thread::sleep(200);
           car-&gt;waxed();
           car-&gt;waitForBuffing();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Ending Wax On process"&lt;&lt; endl;
     }
   };

   class WaxOff : public Runnable {
     CountedPtr&lt;Car&gt; car;
   public:
     WaxOff(CountedPtr&lt;Car&gt;& c) : car(c) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           car-&gt;waitForWaxing();
           cout&lt;&lt; "Wax Off!"&lt;&lt; endl;
           Thread::sleep(200);
           car-&gt;buffed();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Ending Wax Off process"&lt;&lt; endl;
     }
   };

   int main() {
     cout&lt;&lt; "Press&lt;Enter&gt; to quit"&lt;&lt; endl;
     try {
       CountedPtr&lt;Car&gt; car(new Car);
       ThreadedExecutor executor;
       executor.execute(new WaxOff(car));
       executor.execute(new WaxOn(car));
       cin.get();
       executor.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   InCar’s constructor, a singleMutex is wrapped in aCondition object so that it can be used to manage inter-task communication. However, theCondition object contains no information about the state of your process, so you need to manage additional information to indicate process state. Here,Car has a singlebool waxOn, which indicates the state of the waxing-polishing process.
   InwaitForWaxing( ), thewaxOn flag is checked, and if it isfalse, the calling thread is suspended by callingwait( ) on theCondition object. It’s important that this occur inside a guarded clause, in which the thread has acquired the lock (here, by creating aGuard object). When you callwait( ), the thread is suspended andthe lock is released. It is essential that the lock be released because, to safely change the state of the object (for example, to changewaxOn totrue, which must happen if the suspended thread is to ever continue), that lock must be available to be acquired by some other task. In this example, when another thread callswaxed( ) to tell it that it’s time to do something, the mutex must be acquired in order to changewaxOn totrue. Afterward,waxed( )sends asignal( ) to theCondition object, which wakes up the thread suspended in the call towait( ). Althoughsignal( ) may be called inside a guarded clause—as it is here—you are not required to do this.[127]
   In order for a thread to wake up from await( ), it must first reacquire the mutex that it released when it entered thewait( ). The thread will not wake up until that mutex becomes available.
   The call towait( ) is placed inside awhile loop that checks the condition of interest. This is important for two reasons:
   ·         It is possible that when the thread gets asignal( ), some other condition has changed that is not associated with the reason that we calledwait( ) here. If that is the case, this thread should be suspended again until its condition of interest changes.
   ·         By the time this thread awakens from itswait( ), it’s possible that some other task has changed things such that this thread is unable or uninterested in performing its operation at this time. Again, it should be re-suspended by callingwait( ) again.
   Because these two reasons are always present when you are callingwait( ), always write your call towait( ) inside awhile loop that tests for your condition(s) of interest.
   WaxOn::run( ) represents the first step in the process of waxing the car, so it performs its operation (a call tosleep( ) to simulate the time necessary for waxing). It then tells the car that waxing is complete, and callswaitForBuffing( ), which suspends this thread with await( )until theWaxOff process callsbuffed( ) for the car, changing the state and callingnotify( ).WaxOff::run( ), on the other hand, immediately moves intowaitForWaxing( ) and is thus suspended until the wax has been applied byWaxOn andwaxed( ) is called. When you run this program, you can watch this two-step process repeat itself as control is handed back and forth between the two threads. When you press the&lt;Enter&gt; key,interrupt( ) halts both threads—when you callinterrupt( ) for anExecutor, it callsinterrupt( ) for all the threads it is controlling.
   Producer-consumer relationships
   A common situation in threading problems is theproducer-consumer relationship, in which one task is creating objects and other tasks are consuming them. In such a situation, make sure that (among other things) the consuming tasks do not accidentally skip any of the produced objects.
   To show this problem, consider a machine that has three tasks: one to make toast, one to butter the toast, and one to put jam on the buttered toast.
   //: C11:ToastOMatic.cpp
   // Problems with thread cooperation.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include "zthread/Condition.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   using namespace ZThread;
   using namespace std;

   // Apply jam to buttered toast:
   class Jammer : public Runnable {
     Mutex lock;
     Condition butteredToastReady;
     bool gotButteredToast;
     int jammed;
   public:
     Jammer(): butteredToastReady(lock) {
       gotButteredToast = false;
       jammed = 0;
     }
     void moreButteredToastReady() {
       Guard&lt;Mutex&gt; g(lock);
       gotButteredToast = true;
       butteredToastReady.signal();
     }
     void run() {
       try {
         while(!Thread::interrupted()) {
           {
             Guard&lt;Mutex&gt; g(lock);
             while(!gotButteredToast)
               butteredToastReady.wait();
             jammed++;
           }
           cout&lt;&lt; "Putting jam on toast "&lt;&lt; jammed&lt;&lt; endl;
           {
             Guard&lt;Mutex&gt; g(lock);
             gotButteredToast = false;
           }
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Jammer off"&lt;&lt; endl;
     }
   };

   // Apply butter to toast:
   class Butterer : public Runnable {
     Mutex lock;
     Condition toastReady;
     CountedPtr&lt;Jammer&gt; jammer;
     bool gotToast;
     int buttered;
   public:
     Butterer(CountedPtr&lt;Jammer&gt;& j)
     : jammer(j), toastReady(lock) {
       gotToast = false;
       buttered = 0;
     }
     void moreToastReady() {
       Guard&lt;Mutex&gt; g(lock);
       gotToast = true;
       toastReady.signal();
     }
     void run() {
       try {
         while(!Thread::interrupted()) {
           {
             Guard&lt;Mutex&gt; g(lock);
             while(!gotToast)
               toastReady.wait();
             buttered++;
           }
           cout&lt;&lt; "Buttering toast "&lt;&lt; buttered&lt;&lt; endl;
           jammer-&gt;moreButteredToastReady();
           {
             Guard&lt;Mutex&gt; g(lock);
             gotToast = false;
           }
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Butterer off"&lt;&lt; endl;
     }
   };

   class Toaster : public Runnable {
     CountedPtr&lt;Butterer&gt; butterer;
     int toasted;
   public:
     Toaster(CountedPtr&lt;Butterer&gt;& b) : butterer(b) {
       toasted = 0;
       srand(time(0)); // Seed the random number generator
     }
     void run() {
       try {
         while(!Thread::interrupted()) {
           Thread::sleep(rand()/(RAND_MAX/5)*100);
           // ...
           // Create new toast
           // ...
           cout&lt;&lt; "New toast "&lt;&lt; ++toasted&lt;&lt; endl;
           butterer-&gt;moreToastReady();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Toaster off"&lt;&lt; endl;
     }
   };

   int main() {
     try {
       cout&lt;&lt; "Press&lt;Return&gt; to quit"&lt;&lt; endl;
       CountedPtr&lt;Jammer&gt; jammer(new Jammer);
       CountedPtr&lt;Butterer&gt; butterer(new Butterer(jammer));
       ThreadedExecutor executor;
       executor.execute(new Toaster(butterer));
       executor.execute(butterer);
       executor.execute(jammer);
       cin.get();
       executor.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   The classes are defined in the reverse order that they operate to simplify forward-referencing issues.
   Jammer andButterer both contain aMutex, aCondition, and some kind of internal state information that changes to indicate that the process should suspend or resume. (Toaster doesn’t need these since it is the producer and doesn’t have to wait on anything.) The tworun( ) functions perform an operation, set a state flag, and then callwait( ) to suspend the task. ThemoreToastReady( ) andmoreButteredToastReady( ) functions change their respective state flags to indicate that something has changed and the process should consider resuming and then callsignal( ) to wake up the thread.
   The difference between this example and the previous one is that, at least conceptually, something is being produced here: toast. The rate of toast production is randomized a bit, to add some uncertainty. And you’ll see that when you run the program, things aren’t going right, because many pieces of toast appear to be getting dropped on the floor—not buttered, not jammed.
   Solving threading problems with queues
   Often, threading problems are based on the need for tasks to be serialized—that is, to take care of things in order.ToastOMatic.cpp must not only take care of things in order, it must be able to work on one piece of toast without worrying that toast is falling on the floor in the meantime. You can solve many threading problems by using a queue that synchronizes access to the elements within:
   //: C11:TQueue.h
   #ifndef TQUEUE_H
   #define TQUEUE_H
   #include "zthread/Thread.h"
   #include "zthread/Condition.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include&lt;deque&gt;

   template&lt;class T&gt; class TQueue {
     ZThread::Mutex lock;
     ZThread::Condition cond;
     std::deque&lt;T&gt; data;
   public:
     TQueue() : cond(lock) {}
     void put(T item) {
       ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);
       data.push_back(item);
       cond.signal();
     }
     T get() {
       ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);
       while(data.empty())
         cond.wait();
       T returnVal = data.front();
       data.pop_front();
       return returnVal;
     }
   };
   #endif // TQUEUE_H ///:~

   This builds on the Standard C++ Librarydeque by adding:
   1.Synchronization to ensure that no two threads add objects at the same time.
   2.wait( ) andsignal( ) so that a consumer thread will automatically suspend if the queue is empty, and resume when more elements become available.
   This relatively small amount of code can solve a remarkable number of problems.
   Here’s a simple test that serializes the execution ofLiftOff objects. The consumer isLiftOffRunner, which pulls eachLiftOff object off theTQueue and runs it directly. (That is, it uses its own thread by callingrun( ) explicitly rather than starting up a new thread for each task.)
   //: C11:TestTQueue.cpp
   //{L} ZThread
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include "TQueue.h"
   #include "zthread/Thread.h"
   #include "LiftOff.h"
   using namespace ZThread;
   using namespace std;

   class LiftOffRunner : public Runnable {
     TQueue&lt;LiftOff*&gt; rockets;
   public:
     void add(LiftOff* lo) { rockets.put(lo); }
     void run() {
       try {
         while(!Thread::interrupted()) {
           LiftOff* rocket = rockets.get();
           rocket-&gt;run();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Exiting LiftOffRunner"&lt;&lt; endl;
     }
   };

   int main() {
     try {
       LiftOffRunner* lor = new LiftOffRunner;
       Thread t(lor);
       for(int i = 0; i&lt; 5; i++)
         lor-&gt;add(new LiftOff(10, i));
       cin.get();
       lor-&gt;add(new LiftOff(10, 99));
       cin.get();
       t.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   The tasks are placed on theTQueue bymain( ) and are taken off theTQueue by theLiftOffRunner. Notice thatLiftOffRunner can ignore the synchronization issues because they are solved by theTQueue.
   Proper toasting
   To solve theToastOMatic.cpp problem, we can run the toast throughTQueues between processes. And to do this, we will need actual toast objects, which maintain and display their state:
   //: C11:ToastOMaticMarkII.cpp
   // Solving the problems using TQueues
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include "zthread/Condition.h"
   #include "zthread/ThreadedExecutor.h"
   #include "TQueue.h"
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   using namespace ZThread;
   using namespace std;

   class Toast {
     enum Status { dry, buttered, jammed };
     Status status;
     int id;
   public:
     Toast(int idn) : id(idn), status(dry) {}
     void butter() { status = buttered; }
     void jam() { status = jammed; }
     string getStatus() const {
       switch(status) {
         case dry: return "dry";
         case buttered: return "buttered";
         case jammed: return "jammed";
         default: return "error";
       }
     }
     int getId() { return id; }
     friend ostream& operator&lt;&lt;(ostream& os, const Toast& t) {
       return os&lt;&lt; "Toast "&lt;&lt; t.id&lt;&lt; ": "&lt;&lt; t.getStatus();
     }
   };

   typedef CountedPtr&lt; TQueue&lt;Toast&gt;&gt; ToastQueue;

   class Toaster : public Runnable {
     ToastQueue toastQueue;
     int count;
   public:
     Toaster(ToastQueue& tq) : toastQueue(tq), count(0) {
       srand(time(0)); // Seed the random number generator
     }
     void run() {
       try {
         while(!Thread::interrupted()) {
           int delay = rand()/(RAND_MAX/5)*100;
           Thread::sleep(delay);
           // Make toast
           Toast t(count++);
           cout&lt;&lt; t&lt;&lt; endl;
           // Insert into queue
           toastQueue-&gt;put(t);
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Toaster off"&lt;&lt; endl;
     }
   };

   // Apply butter to toast:
   class Butterer : public Runnable {
     ToastQueue dryQueue, butteredQueue;
   public:
     Butterer(ToastQueue& dry, ToastQueue& buttered)
     : dryQueue(dry), butteredQueue(buttered) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until next piece of toast is available:
           Toast t = dryQueue-&gt;get();
           t.butter();
           cout&lt;&lt; t&lt;&lt; endl;
           butteredQueue-&gt;put(t);
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Butterer off"&lt;&lt; endl;
     }
   };

   // Apply jam to buttered toast:
   class Jammer : public Runnable {
     ToastQueue butteredQueue, finishedQueue;
   public:
     Jammer(ToastQueue& buttered, ToastQueue& finished)
     : butteredQueue(buttered), finishedQueue(finished) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until next piece of toast is available:
           Toast t = butteredQueue-&gt;get();
           t.jam();
           cout&lt;&lt; t&lt;&lt; endl;
           finishedQueue-&gt;put(t);
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Jammer off"&lt;&lt; endl;
     }
   };

   // Consume the toast:
   class Eater : public Runnable {
     ToastQueue finishedQueue;
     int counter;
   public:
     Eater(ToastQueue& finished)
     : finishedQueue(finished), counter(0) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until next piece of toast is available:
           Toast t = finishedQueue-&gt;get();
           // Verify that the toast is coming in order,
           // and that all pieces are getting jammed:
           if(t.getId() != counter++ ||
              t.getStatus() != "jammed") {
             cout&lt;&lt; "&gt;&gt;&gt;&gt; Error: "&lt;&lt; t&lt;&lt; endl;
             exit(1);
           } else
             cout&lt;&lt; "Chomp! "&lt;&lt; t&lt;&lt; endl;
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Eater off"&lt;&lt; endl;
     }
   };

   int main() {
     try {
       ToastQueue dryQueue(new TQueue&lt;Toast&gt;),
   butteredQueue(new TQueue&lt;Toast&gt;),
   finishedQueue(new TQueue&lt;Toast&gt;);
       cout&lt;&lt; "Press&lt;Return&gt; to quit"&lt;&lt; endl;
       ThreadedExecutor executor;
       executor.execute(new Toaster(dryQueue));
       executor.execute(new Butterer(dryQueue,butteredQueue));
       executor.execute(
         new Jammer(butteredQueue, finishedQueue));
       executor.execute(new Eater(finishedQueue));
       cin.get();
       executor.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Two things are immediately apparent in this solution: first, the amount and complexity of code within eachRunnable class is dramatically reduced by the use of theTQueue, because the guarding, communication, andwait( )/signal( ) operations are now taken care of by theTQueue. TheRunnable classes don’t haveMutexes orCondition objects anymore. Second, the coupling between the classes is eliminated because each class communicates only with itsTQueues. Notice that the definition order of the classes is now independent. Less code and less coupling is always a good thing, which suggests that the use of theTQueue has a positive effect here, as it does on most problems.
   Broadcast
   Thesignal( ) function wakes up a single thread that is waiting on aCondition object. However, multiple threads may be waiting on the same condition object, and in that case you’ll want to wake them all up usingbroadcast( ) instead ofsignal( ).
   As an example that brings together many of the concepts in this chapter, consider a hypothetical robotic assembly line for automobiles. EachCar will be built in several stages, and in this example we’ll look at a single stage: after the chassis has been created, at the time when the engine, drive train, and wheels are attached. TheCars are transported from one place to another via aCarQueue, which is a type ofTQueue. ADirector takes eachCar (as a raw chassis) from the incomingCarQueue and places it in aCradle, which is where all the work is done. At this point, theDirector tells all the waiting robots (usingbroadcast( )) that theCar is in theCradle ready for the robots to work on it. The three types of robots go to work, sending a message to theCradle when they finish their tasks. TheDirector waits until all the tasks are complete and then puts theCar onto the outgoingCarQueue to be transported to the next operation. In this case, the consumer of the outgoingCarQueue is aReporter object, which just prints theCar to show that the tasks have been properly completed.
   //: C11:CarBuilder.cpp
   // How broadcast() works.
   //{L} ZThread
   #include "zthread/Thread.h"
   #include "zthread/Mutex.h"
   #include "zthread/Guard.h"
   #include "zthread/Condition.h"
   #include "zthread/ThreadedExecutor.h"
   #include "TQueue.h"
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   using namespace ZThread;
   using namespace std;

   class Car {
     bool engine, driveTrain, wheels;
     int id;
   public:
     Car(int idn) : id(idn), engine(false),
     driveTrain(false), wheels(false) {}
     // Empty Car object:
     Car() : id(-1), engine(false),
     driveTrain(false), wheels(false) {}
     // Unsynchronized -- assumes atomic bool operations:
     int getId() { return id; }
     void addEngine() { engine = true; }
     bool engineInstalled() { return engine; }
     void addDriveTrain() { driveTrain = true; }
     bool driveTrainInstalled() { return driveTrain; }
     void addWheels() { wheels = true; }
     bool wheelsInstalled() { return wheels; }
     friend ostream& operator&lt;&lt;(ostream& os, const Car& c) {
       return os&lt;&lt; "Car "&lt;&lt; c.id&lt;&lt; " ["
        &lt;&lt; " engine: "&lt;&lt; c.engine
        &lt;&lt; " driveTrain: "&lt;&lt; c.driveTrain
        &lt;&lt; " wheels: "&lt;&lt; c.wheels&lt;&lt; " ]";
     }
   };

   typedef CountedPtr&lt; TQueue&lt;Car&gt;&gt; CarQueue;

   class ChassisBuilder : public Runnable {
     CarQueue carQueue;
     int counter;
   public:
     ChassisBuilder(CarQueue& cq) : carQueue(cq), counter(0){}
     void run() {
       try {
         while(!Thread::interrupted()) {
           Thread::sleep(1000);
           // Make chassis:
           Car c(counter++);
           cout&lt;&lt; c&lt;&lt; endl;
           // Insert into queue
           carQueue-&gt;put(c);
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "ChassisBuilder off"&lt;&lt; endl;
     }
   };

   class Cradle {
     Car c; // Holds current car being worked on
     bool occupied;
     Mutex workLock, readyLock;
     Condition workCondition, readyCondition;
     bool engineBotHired, wheelBotHired, driveTrainBotHired;
   public:
     Cradle()
     : workCondition(workLock), readyCondition(readyLock) {
       occupied = false;
       engineBotHired = true;
       wheelBotHired = true;
       driveTrainBotHired = true;
     }
     void insertCar(Car chassis) {
       c = chassis;
       occupied = true;
     }
     Car getCar() { // Can only extract car once
       if(!occupied) {
         cerr&lt;&lt; "No Car in Cradle for getCar()"&lt;&lt; endl;
         return Car(); // "Null" Car object
       }
       occupied = false;
       return c;
     }
     // Access car while in cradle:
     Car* operator-&gt;() { return&c; }
     // Allow robots to offer services to this cradle:
     void offerEngineBotServices() {
       Guard&lt;Mutex&gt; g(workLock);
       while(engineBotHired)
         workCondition.wait();
       engineBotHired = true; // Accept the job
     }
     void offerWheelBotServices() {
       Guard&lt;Mutex&gt; g(workLock);
       while(wheelBotHired)
         workCondition.wait();
       wheelBotHired = true; // Accept the job
     }
     void offerDriveTrainBotServices() {
       Guard&lt;Mutex&gt; g(workLock);
       while(driveTrainBotHired)
         workCondition.wait();
       driveTrainBotHired = true; // Accept the job
     }
     // Tell waiting robots that work is ready:
     void startWork() {
       Guard&lt;Mutex&gt; g(workLock);
       engineBotHired = false;
       wheelBotHired = false;
       driveTrainBotHired = false;
       workCondition.broadcast();
     }
     // Each robot reports when their job is done:
     void taskFinished() {
       Guard&lt;Mutex&gt; g(readyLock);
       readyCondition.signal();
     }
     // Director waits until all jobs are done:
     void waitUntilWorkFinished() {
       Guard&lt;Mutex&gt; g(readyLock);
       while(!(c.engineInstalled()&& c.driveTrainInstalled()
              && c.wheelsInstalled()))
         readyCondition.wait();
     }
   };

   typedef CountedPtr&lt;Cradle&gt; CradlePtr;

   class Director : public Runnable {
     CarQueue chassisQueue, finishingQueue;
     CradlePtr cradle;
   public:
     Director(CarQueue& cq, CarQueue& fq, CradlePtr cr)
     : chassisQueue(cq), finishingQueue(fq), cradle(cr) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until chassis is available:
           cradle-&gt;insertCar(chassisQueue-&gt;get());
           // Notify robots car is ready for work
           cradle-&gt;startWork();
           // Wait until work completes
           cradle-&gt;waitUntilWorkFinished();
           // Put car into queue for further work
           finishingQueue-&gt;put(cradle-&gt;getCar());
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Director off"&lt;&lt; endl;
     }
   };

   class EngineRobot : public Runnable {
     CradlePtr cradle;
   public:
     EngineRobot(CradlePtr cr) : cradle(cr) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until job is offered/accepted:
           cradle-&gt;offerEngineBotServices();
           cout&lt;&lt; "Installing engine"&lt;&lt; endl;
           (*cradle)-&gt;addEngine();
           cradle-&gt;taskFinished();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "EngineRobot off"&lt;&lt; endl;
     }
   };

   class DriveTrainRobot : public Runnable {
     CradlePtr cradle;
   public:
     DriveTrainRobot(CradlePtr cr) : cradle(cr) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until job is offered/accepted:
           cradle-&gt;offerDriveTrainBotServices();
           cout&lt;&lt; "Installing DriveTrain"&lt;&lt; endl;
           (*cradle)-&gt;addDriveTrain();
           cradle-&gt;taskFinished();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "DriveTrainRobot off"&lt;&lt; endl;
     }
   };

   class WheelRobot : public Runnable {
     CradlePtr cradle;
   public:
     WheelRobot(CradlePtr cr) : cradle(cr) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           // Blocks until job is offered/accepted:
           cradle-&gt;offerWheelBotServices();
           cout&lt;&lt; "Installing Wheels"&lt;&lt; endl;
           (*cradle)-&gt;addWheels();
           cradle-&gt;taskFinished();
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "WheelRobot off"&lt;&lt; endl;
     }
   };

   class Reporter : public Runnable {
     CarQueue carQueue;
   public:
     Reporter(CarQueue& cq) : carQueue(cq) {}
     void run() {
       try {
         while(!Thread::interrupted()) {
           cout&lt;&lt; carQueue-&gt;get()&lt;&lt; endl;
         }
       } catch(Interrupted_Exception&) { /* Exit */ }
       cout&lt;&lt; "Reporter off"&lt;&lt; endl;
     }
   };

   int main() {
     cout&lt;&lt; "Press&lt;Enter&gt; to quit"&lt;&lt; endl;
     try {
       CarQueue chassisQueue(new TQueue&lt;Car&gt;),
                finishingQueue(new TQueue&lt;Car&gt;);
       CradlePtr cradle(new Cradle);
       ThreadedExecutor assemblyLine;
       assemblyLine.execute(new EngineRobot(cradle));
       assemblyLine.execute(new DriveTrainRobot(cradle));
       assemblyLine.execute(new WheelRobot(cradle));
       assemblyLine.execute(
         new Director(chassisQueue, finishingQueue, cradle));
       assemblyLine.execute(new Reporter(finishingQueue));
       // Start everything running by producing chassis:
       assemblyLine.execute(new ChassisBuilder(chassisQueue));
       cin.get();
       assemblyLine.interrupt();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   You’ll notice thatCartakes a shortcut: it assumes thatbool operations are atomic, which, as previously discussed, is generally a safe assumption but one to consider carefully. EachCar begins as an unadorned chassis, and different robots will attach different parts to it, calling the appropriate "add" function when they do.
   AChassisBuilder simply creates a newCar every second and places it into thechassisQueue. ADirector manages the build process by taking the nextCar off thechassisQueue, putting it into theCradle, telling all the robots tostartWork( ), and suspending itself by callingwaitUntilWorkFinished( ). When the work is done, theDirector takes theCar out of theCradle and puts in into thefinishingQueue.
   TheCradle is the crux of the signaling operations. AMutex and aCondition object control both the working of the robots and indicate whether all the operations are finished. A particular type of robot can offer its services to theCradle by calling the "offer" function appropriate to its type. At this point, that robot thread is suspended until theDirector callsstartWork( ), which changes the hiring flags and callsbroadcast( ) to tell all the robots to show up for work. Although this system allows any number of robots to offer their services, each one of those robots has its thread suspended by doing so. You could imagine a more sophisticated system in which the robots register themselves with many differentCradles without being suspended by that registration process and then reside in a pool waiting for the firstCradle that needs a task completed.
   After each robot finishes its task (changing the state of theCar in the process), it callstaskFinished( ), which sends asignal( ) to thereadyCondition, which is what theDirector is waiting on inwaitUntilWorkFinished( ). Each time the director thread awakens, the state of theCar is checked, and if it still isn’t finished, that thread is suspended again.
   When theDirectorinserts aCar into theCradle, you can perform operations on thatCar via theoperator-&gt;( ). To prevent multiple extractions of the same car, a flag causes an error report to be generated. (Exceptions don’t propagate across threads in the ZThread library.)
   Inmain( ), all the necessary objects are created and the tasks are initialized, with theChassisBuilder begun last to start the process. (However, because of the behavior of theTQueue, it wouldn’t matter if it were started first.) Note that this program follows all the guidelines regarding object and task lifetime presented in this chapter, and so the shutdown process is safe.
   Deadlock
   Because threads can become blockedand because objects can have mutexes that prevent threads from accessing that object until the mutex is released, it’s possible for one thread to get stuck waiting for another thread, which in turn waits for another thread, and so on, until the chain leads back to a thread waiting on the first one. You get a continuous loop of threads waiting on each other, and no one can move. This is calleddeadlock.
   If you try running a program and it deadlocks right away, you immediately know you have a problem, and you can track it down. The real problem is when your program seems to be working fine but has the hidden potential to deadlock. In this case, you may get no indication that deadlocking is a possibility, so it will be latent in your program until it unexpectedly happens to a customer. (And you probably won’t be able to easily reproduce it.) Thus, preventing deadlock through careful program design is a critical part of developing concurrent programs.
   Let’s look at the classic demonstration of deadlock, invented by Edsger Dijkstra: thedining philosophers problem. The basic description specifies five philosophers (but the example shown here will allow any number). These philosophers spend part of their time thinking and part of their time eating. While they are thinking, they don’t need any shared resources, but when they are eating, they sit at a table with a limited number of utensils. In the original problem description, the utensils are forks, and two forks are required to get spaghetti from a bowl in the middle of the table, but it seems to make more sense to say that the utensils are chopsticks. Clearly, each philosopher will require two chopsticks in order to eat.
   A difficulty is introduced into the problem: as philosophers, they have very little money, so they can only afford five chopsticks. These are spaced around the table between them. When a philosopher wants to eat, they must pick up the chopstick to the left and the one to the right. If the philosopher on either side is using a desired chopstick, our philosopher must wait until the necessary chopsticks become available.
   //: C11:DiningPhilosophers.h
   // Classes for Dining Philosohophers
   #ifndef DININGPHILOSOPHERS_H
   #define DININGPHILOSOPHERS_H
   #include "zthread/Condition.h"
   #include "zthread/Guard.h"
   #include "zthread/Mutex.h"
   #include "zthread/Thread.h"
   #include "Display.h"
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;

   class Chopstick {
     ZThread::Mutex lock;
     ZThread::Condition notTaken;
     bool taken;
   public:
     Chopstick() : notTaken(lock), taken(false) {}
     void take() {
       ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);
       while(taken)
         notTaken.wait();
       taken = true;
     }
     void drop() {
       ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);
       taken = false;
       notTaken.signal();
     }
   };

   class Philosopher : public ZThread::Runnable {
     Chopstick& left;
     Chopstick& right;
     int id;
     int ponderFactor;
     ZThread::CountedPtr&lt;Display&gt; display;
     int randSleepTime() {
       if(ponderFactor == 0) return 0;
       return rand()/(RAND_MAX/ponderFactor) * 250;
     }
   public:
     Philosopher(Chopstick& l, Chopstick& r,
     ZThread::CountedPtr&lt;Display&gt;& disp, int ident,int ponder)
     : left(l), right(r), display(disp),
       id(ident), ponderFactor(ponder) { srand(time(0)); }
     virtual void run() {
       try {
         while(!ZThread::Thread::interrupted()) {
           {
             std::ostringstream os;
             os&lt;&lt; *this&lt;&lt; " thinking"&lt;&lt; std::endl;
             display-&gt;output(os);
           }
           ZThread::Thread::sleep(randSleepTime());
           // Hungry
           {
             std::ostringstream os;
             os&lt;&lt; *this&lt;&lt; " grabbing right"&lt;&lt; std::endl;
             display-&gt;output(os);
           }
           right.take();
           {
             std::ostringstream os;
             os&lt;&lt; *this&lt;&lt; " grabbing left"&lt;&lt; std::endl;
             display-&gt;output(os);
           }
           left.take();
           // Eating
           {
             std::ostringstream os;
             os&lt;&lt; *this&lt;&lt; " eating"&lt;&lt; std::endl;
             display-&gt;output(os);
           }
           ZThread::Thread::sleep(randSleepTime());
           right.drop();
           left.drop();
         }
       } catch(ZThread::Synchronization_Exception& e) {
         std::ostringstream os;
         os&lt;&lt; *this&lt;&lt; " "&lt;&lt; e.what()&lt;&lt; std::endl;
         display-&gt;output(os);
       }
     }
     friend std::ostream&
     operator&lt;&lt;(std::ostream& os, const Philosopher& p) {
       return os&lt;&lt; "Philosopher "&lt;&lt; p.id;
     }
   };
   #endif // DININGPHILOSOPHERS_H ///:~

   No twoPhilosophers cantake( ) aChopstick at the same time, sincetake( ) is synchronized with aMutex. In addition, if the chopstick has already been taken by onePhilosopher, another canwait( ) on theavailable Condition until theChopstick becomes available when the current holder callsdrop( ) (which must also be synchronized to prevent race conditions).
   EachPhilosopher holds references to their left and rightChopstick so they can attempt to pick those up. The goal of thePhilosopher is to think part of the time and eat part of the time, and this is expressed inmain( ). However, you will observe that if thePhilosophers spend very little time thinking, they will all be competing for theChopsticks while they try to eat, and deadlock will happen much more quickly. So you can experiment with this, theponderFactor weights the length of time that aPhilosopher tends to spend thinking and eating. A smallerponderFactor will increase the probability of deadlock.
   InPhilosopher::run( ), eachPhilosopher just thinks and eats continuously. You see thePhilosopher thinking for a randomized amount of time, then trying totake( ) theright and then theleft Chopstick, eating for a randomized amount of time, and then doing it again. Output to the console is synchronized as seen earlier in this chapter.
   This problem is interesting because it demonstrates that a program can appear to run correctly but actually be deadlock prone. To show this, the command-line argument allows you to adjust a factor to affect the amount of time each philosopher spends thinking. If you have lots of philosophers and/or they spend a lot of time thinking, you may never see the deadlock even though it remains a possibility. A command-line argument of zero tends to make it deadlock fairly quickly:[128]
   //: C11:DeadlockingDiningPhilosophers.cpp
   // Dining Philosophers with Deadlock
   //{L} ZThread
   #include "DiningPhilosophers.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;cstdlib&gt;
   using namespace ZThread;
   using namespace std;

   int main(int argc, char* argv[]) {
     int ponder = argc&gt; 1 ? atoi(argv[1]) : 5;
     cout&lt;&lt; "Press&lt;ENTER&gt; to quit"&lt;&lt; endl;
     static const int sz = 5;
     try {
       CountedPtr&lt;Display&gt; d(new Display);
       ThreadedExecutor executor;
       Chopstick c[sz];
       for(int i = 0; i&lt; sz; i++) {
         int j = (i+1)&gt; (sz-1) ? 0 : (i+1);
         executor.execute(
           new Philosopher(c[i], c[j], d, i, ponder));
       }
       cin.get();
       executor.interrupt();
       executor.wait();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   Note that theChopstickobjects do not need internal identifiers; they are identified by their position in the arrayc. EachPhilosopher is given a reference to a left and rightChopstick object when constructed; these are the utensils that must be picked up before thatPhilosopher can eat. EveryPhilosopher except the last one is initialized by situating thatPhilosopher between the next pair ofChopstick objects. The lastPhilosopher is given the zerothChopstick for its rightChopstick, so the round table is completed. That’s because the lastPhilosopher is sitting right next to the first one, and they both share that zeroth chopstick. With this arrangement, it’s possible at some point for all the philosophers to be trying to eat and waiting on the philosopher next to them to put down their chopstick, and the program will deadlock.
   If thepondervalue is nonzero, you can show that if your threads (philosophers) are spending more time on other tasks (thinking) than eating, then they have a much lower probability of requiring the shared resources (chopsticks), and thus you can convince yourself that the program is deadlock free, even though it isn’t.
   To repair the problem, you must understand that deadlock can occur if four conditions are simultaneously met:
   1.       Mutual exclusion. At least one resource used by the threads must not be shareable. In this case, a chopstick can be used by only one philosopher at a time.
   2.      At least one process must be holding a resource and waiting to acquire a resource currently held by another process. That is, for deadlock to occur, a philosopher must be holding one chopstick and waiting for the other one.
   3.      A resource cannot be preemptively taken away from a process. All processes must only release resources as a normal event. Our philosophers are polite, and they don’t grab chopsticks from other philosophers.
   4.      A circular wait must happen, whereby a process waits on a resource held by another process, which in turn is waiting on a resource held by another process, and so on, until one of the processes is waiting on a resource held by the first process, thus gridlocking everything. InDeadlockingDiningPhilosophers.cpp, the circular wait happens because each philosopher tries to get the right chopstick first and then the left.
   Because all these conditions must be met to cause deadlock, you need to stop only one of them from occurring to prevent deadlock. In this program, the easiest way to prevent deadlock is to break condition four. This condition happens because each philosopher is trying to pick up their chopsticks in a particular sequence: first right, then left. Because of that, it’s possible to get into a situation in which each of them is holding their right chopstick and waiting to get the left, causing the circular wait condition. However, if the last philosopher is initialized to try to get the left chopstick first and then the right, that philosopher will never prevent the philosopher on the immediate right from picking up their left chopstick. In this case, the circular wait is prevented. This is only one solution to the problem, but you could also solve it by preventing one of the other conditions (see advanced threading books for more details):
   //: C11:FixedDiningPhilosophers.cpp
   // Dining Philosophers without Deadlock
   //{L} ZThread
   #include "DiningPhilosophers.h"
   #include "zthread/ThreadedExecutor.h"
   #include&lt;cstdlib&gt;
   using namespace ZThread;
   using namespace std;

   int main(int argc, char* argv[]) {
     int ponder = argc&gt; 1 ? atoi(argv[1]) : 5;
     cout&lt;&lt; "Press&lt;ENTER&gt; to quit"&lt;&lt; endl;
     static const int sz = 5;
     try {
       CountedPtr&lt;Display&gt; d(new Display);
       ThreadedExecutor executor;
       Chopstick c[sz];
       for(int i = 0; i&lt; sz; i++) {
         int j = (i+1)&gt; (sz-1) ? 0 : (i+1);
         if(i&lt; (sz-1))
           executor.execute(
             new Philosopher(c[i], c[j], d, i, ponder));
         else
           executor.execute(
             new Philosopher(c[j], c[i], d, i, ponder));
       }
       cin.get();
       executor.interrupt();
       executor.wait();
     } catch(Synchronization_Exception& e) {
       cerr&lt;&lt; e.what()&lt;&lt; endl;
     }
   } ///:~

   By ensuring that the last philosopher picks up and puts down their left chopstick before their right, the deadlock is removed, and the program will run smoothly.
   There is no language support to help prevent deadlock; it’s up to you to avoid it by careful design. These are not comforting words to the person who’s trying to debug a deadlocking program.
   Summary
   The goal of this chapter was to give you the foundations of concurrent programming with threads:
   1.       You can (at least in appearance) run multiple independent tasks.
   2.      You must consider all the possible problems when these tasks shut down. Objects or other tasks may disappear before tasks are finished with them.
   3.      Tasks can collide with each other over shared resources. The mutex is the basic tool used to prevent these collisions.
   4.      Tasks can deadlock if they are not carefully designed.
   However, there are multiple additional facets of threading and tools to help you solve threading problems. The ZThreads library contains a number of these tools, such assemaphores and special types of queues, similar to the one you saw in this chapter. Explore that library as well as other resources on threading to gain more in-depth knowledge.
   It is vital to learn when to use concurrency and when to avoid it. The main reasons to use it are:
   ·         To manage a number of tasks whose intermingling will make more efficient use of the computer (including the ability to transparently distribute the tasks across multiple CPUs).
   ·         To allow better code organization.
   ·         To be more convenient for the user.
   The classic example of resource balancing is to use the CPU during I/O waits. The classic example of user convenience is to monitor a "stop" button during long downloads.
   An additional advantage to threads is that they provide "light" execution context switches (on the order of 100 instructions) rather than "heavy" process context switches (thousands of instructions). Since all threads in a given process share the same memory space, a light context switch changes only program execution and local variables. A process change—the heavy context switch—must exchange the full memory space.
   The main drawbacks to multithreading are:
   ·         Slowdown occurs while waiting for shared resources.
   ·         Additional CPU overhead is required to manage threads.
   ·         Unrewarded complexity arises from poor design decisions.
   ·         Opportunities are created for pathologies such as starving, racing, deadlock, and livelock.
   ·         Inconsistencies occur across platforms. When developing the original material (in Java) for this chapter, we discovered race conditions that quickly appeared on some computers but that wouldn’t appear on others. The C++ examples in this chapter behaved differently (but usually acceptably) under different operating systems. If you develop a program on a computer and things seem to work right, you might get an unwelcome surprise when you distribute it.
   One of the biggest difficulties with threads occurs because more than one thread might be sharing a resource—such as the memory in an object—and you must make sure that multiple threads don’t try to read and change that resource at the same time. This requires judicious use of synchronization tools, which must be thoroughly understood because they can quietly introduce deadlock situations.
   In addition, there’s a certain art to the application of threads. C++ is designed to allow you to create as many objects as you need to solve your problem—at least in theory. (Creating millions of objects for an engineering finite-element analysis, for example, might not be practical.) However, there is usually an upper bound to the number of threads you’ll want to create, because at some number, threads may become balky. This critical point can be difficult to detect and will often depend on the OS and thread library; it could be fewer than a hundred or in the thousands. As you often create only a handful of threads to solve a problem, this is typically not much of a limit; but in a more general design it becomes a constraint.
   Regardless of how simple threading can seem using a particular language or library, consider it a black art. There’s always something you haven’t considered that can bite you when you least expect it. (For example, note that because the dining philosophers problem can be adjusted so that deadlock rarely happens, you can get the impression that everything is OK.) An appropriate quote comes from Guido Van Rossum, creator of the Python programming language:
   In any project that is multi-threaded, most bugs will come from threading issues. This is regardless of programming language—it’s a deep, as yet un-understood property of threads.
   For more advanced discussions of threading, seeConcurrent Programming in Java, 2nd Edition, by Doug Lea, Addison-Wesley, 2000.
   Exercises
   Solutions to selected exercises can be found in the electronic documentThe Thinking in C++ Volume 2 Annotated Solution Guide, available for a small fee fromwww.BruceEckel.com.
                1.             Inherit a class fromRunnable and override therun( ) function. Insiderun( ), print a message, and then callsleep( ). Repeat this three times, and then return fromrun( ). Put a start-up message in the constructor and a shut-down message when the task terminates. Make several thread objects of this type, and run them to see what happens.
                2.             ModifyBasicThreads.cpp to makeLiftOff threads start otherLiftOff threads.
                3.             ModifyResponsiveUI.cpp to eliminate any possible race conditions. (Assumebool operations are not atomic.)
                4.             InIncrementer.cpp, modify theCount class to use a singleint instead of an array ofint. Explain the resulting behavior.
                5.             InEvenChecker.h, correct the potential problem in theGenerator class. (Assumebool operations are not atomic.)
                6.             ModifyEvenGenerator.cpp to useinterrupt( ) instead of quit flags.
                7.             InMutexEvenGenerator.cpp, change the code inMutexEvenGenerator::nextValue( ) so that the return expression precedes therelease( ) statement and explain what happens.
                8.             ModifyResponsiveUI.cpp to useinterrupt( ) instead of thequitFlag approach.
                9.             Look up theSingletondocumentation in the ZThreads library. ModifyOrnamentalGarden.cpp so that theDisplay object is controlled by aSingleton to prevent more than oneDisplay from being accidentally created.
           10.             InOrnamentalGarden.cpp, change theCount::increment( ) function so that it does a direct increment ofcount. Now remove the guard and see if that causes a failure. Is this safe and reliable?
            11.             ModifyOrnamentalGarden.cpp so that it usesinterrupt( ) instead of thepause( ) mechanism. Make sure that your solution doesn’t prematurely destroy objects.
            12.             Generate assembly code from C++ examples to discover which operations (bool assignment,intincrement, and so on) your particular compiler performs atomically.
            13.             ModifyWaxOMatic.cpp by adding more instances of theProcess class so that it applies and polishes three coats of wax instead of just one.
            14.             Create twoRunnable subclasses, one with arun( ) that starts up and then callswait( ). The other class’srun( ) should capture the reference of the firstRunnableobject. Itsrun( )should callsignal( ) for the first thread after some number of seconds have passed so that first thread can print a message.
            15.             Create an example of a "busy wait." One thread sleeps for awhile and then sets a flag totrue. The second thread watches that flag inside awhile loop (this is the "busy wait") and, when the flag becomestrue, sets it back tofalse and reports the change to the console. Note how much wasted time the program spends inside the "busy wait," and create a second version of the program that useswait( ) instead of the "busy wait." Extra: run a profiler to show the time used by the CPU in each case.
            16.             ModifyToastOMaticMarkII.cpp to create peanut-butter and jelly on toast sandwiches using two separate assembly lines and an outputTQueue for the finished sandwiches. Use aReporter object as inCarBuilder.cpp to display the results.
            17.             RewriteC07:BankTeller.cpp to use real threading instead of simulated threading.
            18.             ModifyCarBuilder.cpp to give identifiers to the robots, and add more instances of the different kinds of robots. Note whether all robots get utilized.
            19.             ModifyCarBuilder.cpp to add another stage to the car-building process, whereby you add the exhaust system, body, and fenders. As with the first stage, assume these processes can be performed simultaneously by robots.
           20.             ModifyCarBuilder.cpp so thatCar has synchronized access to all thebool variables. BecauseMutexes cannot be copied, this will require significant changes throughout the program.
            21.             Using the approach inCarBuilder.cpp, model the house-building story that was given in this chapter.
           22.             Change both of the dining philosophers examples so that the number ofPhilosophers is controlled on the command line, in addition to the ponder time. Try different values and explain the results.
           23.             ChangeDiningPhilosophers.cpp so that thePhilosophers just pick the next available chopstick. (When aPhilosopher is done with their chopsticks, they drop them into a bin. When aPhilosopher wants to eat, they take the next two available chopsticks from the bin.) Does this eliminate the possibility of deadlock? Can you reintroduce deadlock by simply reducing the number of available chopsticks?



   A: Recommended reading
   General C++
   The C++ Programming Language, 3rd edition, by Bjarne Stroustrup (Addison-Wesley 1997). To some degree, the goal of the book that you’re currently holding is to allow you to use Bjarne’s book as a reference. Since his book contains the description of the language by the author of that language, it’s typically the place where you’ll go to resolve any uncertainties about what C++ is or isn’t supposed to do. When you get the knack of the language and are ready to get serious, you’ll need it.
   C++ Primer, 3rd Edition, by Stanley Lippman and Josee Lajoie (Addison-Wesley 1998). Not that much of a primer anymore; it’s evolved into a thick book filled with lots of detail, and the one that I reach for along with Stroustrup’s when trying to resolve an issue.Thinking in C++ should provide a basis for understanding theC++ Primeras well as Stroustrup’s book.
   Accelerated C++, by Andrew Koenig and Barbara Moo (Addison-Wesley, 2000). Takes you through C++ by programming topic instead of language feature. Excellent introductory book.
   The C++ Standard Library, by Nicolai Josuttis (Addison-Wesley, 1999). Readable tutorial and reference for the entire C++ library, including STL. Assumes familiarity with language concepts.
   STL Tutorial and Reference Guide, 2nd Edition, by David R. Musser et al (Addison-Wesley, 2001). Gentle but thorough introduction to the concepts underlying STL. Contains an STL reference manual.
    The C++ ANSI/ISO Standard. This isnot free, unfortunately (I certainly didn’t get paid for my time and effort on the Standards Committee—in fact, it cost me a lot of money). But at least you can buy the electronic form in PDF for only $18 at http://www.cssinfo.com.
   Bruce’s books
   Listed in order of publication. Not all these are currently available.
   Computer Interfacing with Pascal& C, (Self-published via the Eisys imprint, 1988. Only available viawww.BruceEckel.com). An introduction to electronics from back when CP/M was still king and DOS was an upstart. I used high-level languages and often the parallel port of the computer to drive various electronic projects. Adapted from my columns in the first and best magazine I wrote for,Micro Cornucopia.(To paraphrase Larry O’Brien, long-time editor ofSoftware Development Magazine: The best computer magazine ever published—they even had plans for building a robot in a flower pot!) Alas, Micro C became lost long before the Internet appeared. Creating this book was an extremely satisfying publishing experience.
   Using C++, (Osborne/McGraw-Hill, 1989). One of the first books out on C++. This is out of print and replaced by its second edition, the renamedC++ Inside& Out.
   C++ Inside& Out, (Osborne/McGraw-Hill, 1993). As noted, actually the second edition ofUsing C++. The C++ in this book is reasonably accurate, but it's circa 1992 andThinking in C++ is intended to replace it. You can find out more about this book and download the source code atwww.BruceEckel.com.
   Thinking in C++, 1st Edition, (Prentice Hall, 1995). Winner of theSoftware Development Magazine Jolt Award for best book of 1995.
   Thinking in C++, 2nd Edition, Volume 1, (Prentice Hall, 2000). Downloadable fromwww.BruceEckel.com.
   Black Belt C++: the Master’s Collection, Bruce Eckel, editor (M&T Books, 1994). Out of print (often available through out-of-print services on the Web). A collection of chapters by various C++ luminaries based on their presentations in the C++ track at the Software Development Conference, which I chaired. The cover on this book stimulated me to gain control over all future cover designs.
   Thinking in Java, 1st Edition, (Prentice Hall, 1998). The first edition of this book won theSoftware Development Magazine Productivity Award, theJava Developer’s JournalEditor’s Choice Award, and theJavaWorld Reader’s Choice Award for best book. On the CD ROM in the back of this book, and downloadable fromwww.BruceEckel.com.
   Thinking in Java, 2nd Edition, (Prentice Hall, 2000). This edition won theJavaWorld Editor’s Choice Award for best book. On the CD ROM in the back of this book, and downloadable fromwww.BruceEckel.com.
   Thinking in Java, 3rd Edition, (Prentice Hall, 2002). This edition won theSoftware Development Magazine Jolt Award for best book of 2002, and theJava Developer’s JournalEditor’s Choice Award. The new CD ROM in the back of this book now includes the first seven lectures from the 2nd edition of theHands-On Java CD ROM.
   The Hands-On Java CD ROM, 3rd edition (MindView, 2003). Over 15 hours of lectures and slides covering the basics of the Java language, based onThinking in Java, 3rd Edition. Available only at www.MindView.net.
   Chuck’s books
   C& C++ Code Capsules, by Chuck Allison (Prentice-Hall, 1998). Assumes that you already know C and C++, and covers some of the issues that you may be rusty on, or that you may not have gotten right the first time. This book fills in C gaps as well as C++ gaps.[ ]
   Thinking in C: Foundations for Java& C++, by Chuck Allison (not actually a book, but a MindView, Inc. Seminar on CD ROM, 1999, bundled withThinking in Java andThinking in C++, Volume 1). A multimedia course including lectures and slides in the foundations of the C Language to prepare you to learn Java or C++. This is not an exhaustive course in C; only the necessities for moving on to the other languages are included. An extra section covering features for the C++ programmer is included. Prerequisite: experience with a high-level programming language, such as Pascal, BASIC, FORTRAN, or LISP.
   In-depth C++
   Books that go more deeply into topics of the language, and help you avoid the typical pitfalls inherent in developing C++ programs.
   Large-Scale C++ Software Design, by John Lakos (Addison-Wesley, 1996). Motivates and presents in-the-trenches techniques for large C++ projects.
   Effective C++, 2nd Edition, by Scott Meyers (Addison-Wesley, 1997). Classic book of techniques to improve C++ designs. Codifies many of the things that programmers have to learn the hard way.
   More Effective C++, by Scott Meyers (Addison-Wesley, 1995) Continuation ofEffective C++ (above). Another C++ classic.
   Effective STL, by Scott Meyers (Addison-Wesley, 2001). Extremely practical, in-depth coverage of how to use the STL. Contains expert advice found nowhere else.
   Generic Programming and the STL, by Matt Austern (Addison-Wesley, 1998). Explores the conceptual underpinnings of the design of the STL. Heavy on theory, but imparts a visionary look into the design of generic libraries.
   Exceptional C++, by Herb Sutter (Addison-Wesley, 2000). Leads the reader through a progression of problems and their solution. Gives easy-to-remember advice for solid design of modern C++ programs.
   More Exceptional C++, by Herb Sutter (Addison-Wesley, 2001). Continuation ofExceptional C++ (above).
   C++ FAQs, 2nd Edition, by Marshall Cline, Greg Lomow, and Mike Girou (Addison-Wesley, 1998). Nicely-structured compendium of common C++ questions and their answers. Covers a broad range of topics, from beginner to advanced.
   C++ Gotchas, by Stephen Dewhurst (Addison-Wesley, 2002). Contemporary catalog of easy-to-discover but hard-to-remedy C++ quirks by a widely-renowned recognized C++ expert.
   C++ Templates, The Complete Guide, by David Vandervoorde and Nicolai M. Josuttis (Addison-Wesley, 2002). The first and only book devoted completely to templates. The definitive reference.
   Standard C++ IOStreams and Locales, by Angelika Langer and Klaus Kreft (Addison-Wesley, 2000). The most in-depth coverage of iostreams available. Plumbs the depths of streams implementation and idiomatic use. A handy reference as well as tutorial.
   Design& Evolution of C++, by Bjarne Stroustrup (Addison-Wesley, 1994). Traces the complete history of C++, documenting the design decisions that were made along the way. If you want to know why C++ is the way it is, this is the book with the answers, written by the designer of the language.
   Modern C++ Design, by Andrei Alexandrescu (Addison-Wesley, 2001). The standard text on policy-based design in C++. Filled with practical, advanced uses of templates.
   Generative Programming, by Krzysztof Czarnecki and Ulrich Eisencecker, (Addison-Wesley, 2000). Ground-breaking book on highly-advanced C++ techniques. Takes software automation to the next level.
   Multi-Paradigm Design for C++, by James O. Coplien (Addison-Wesley, 1998). Advanced text showing how to harmonize the use of procedural, object-oriented, and generic programming for effective C++ designs.
   Design Patterns
   Design Patterns, by Erich Gamma et al (Addison-Wesley, 1995). The revolutionary book that introduced design patterns to the industry. Catalogs a critical of design patterns with motivation and examples (using C++ and a little SmallTalk).
   Pattern-Oriented System Architecture, Volume 1: A System of Patterns, by Frank Buschmann et al (John Wiley& Son, 1996). Another look at design patterns in practice. Introduces new design patterns.
   [ ]
   B: Etc
   This appendix contains files that are required to build the files in Volume 2.
   //: :require.h
   // Test for error conditions in programs
   // Local "using namespace std" for old compilers
   #ifndef REQUIRE_H
   #define REQUIRE_H
   #include&lt;cstdio&gt;
   #include&lt;cstdlib&gt;
   #include&lt;fstream&gt;

   inline void require(bool requirement,
     const char* msg = "Requirement failed") {
     using namespace std;
     if (!requirement) {
       fputs(msg, stderr);
       fputs("\n", stderr);
       exit(EXIT_FAILURE);
     }
   }

   inline void requireArgs(int argc, int args,
     const char* msg = "Must use %d arguments") {
     using namespace std;
      if (argc != args + 1) {
        fprintf(stderr, msg, args);
        fputs("\n", stderr);
        exit(EXIT_FAILURE);
      }
   }

   inline void requireMinArgs(int argc, int minArgs,
     const char* msg =
       "Must use at least %d arguments") {
     using namespace std;
     if(argc&lt; minArgs + 1) {
       fprintf(stderr, msg, minArgs);
       fputs("\n", stderr);
       exit(EXIT_FAILURE);
     }
   }

   inline void assure(std::ifstream& in,
     const char* filename = "") {
     using namespace std;
     if(!in) {
       fprintf(stderr,
         "Could not open file %s\n", filename);
       exit(EXIT_FAILURE);
     }
   }

   inline void assure(std::ofstream& in,
     const char* filename = "") {
     using namespace std;
     if(!in) {
       fprintf(stderr,
         "Could not open file %s\n", filename);
       exit(EXIT_FAILURE);
     }
   }

   inline void assure(std::fstream& in,
     const char* filename = "") {
     using namespace std;
     if(!in) {
       fprintf(stderr,
         "Could not open file %s\n", filename);
       exit(EXIT_FAILURE);
     }
   }
   #endif // REQUIRE_H ///:~

   //: C0B:Dummy.cpp
   // To give the makefile at least one target
   // for this directory
   int main() {} ///:~

   TheDate class files:
   //: C02:Date.h
   #ifndef DATE_H
   #define DATE_H
   #include&lt;string&gt;
   #include&lt;stdexcept&gt;
   #include&lt;iosfwd&gt;

   class Date {
   public:
     // A class for date calculations
     struct Duration {
       int years, months, days;
       Duration(int y, int m, int d)
       : years(y), months(m) ,days(d) {}
     };
     // An exception class
     struct DateError : public std::logic_error {
   DateError(const std::string& msg = "")
     : std::logic_error(msg) {}
     };
     Date();
     Date(int, int, int) throw(DateError);
     Date(const std::string&) throw(DateError);
     int getYear() const;
     int getMonth() const;
     int getDay() const;
     std::string toString() const;
     friend Duration duration(const Date&, const Date&);
     friend bool operator&lt;(const Date&, const Date&);
     friend bool operator&lt;=(const Date&, const Date&);
     friend bool operator&gt;(const Date&, const Date&);
     friend bool operator&gt;=(const Date&, const Date&);
     friend bool operator==(const Date&, const Date&);
     friend bool operator!=(const Date&, const Date&);
     friend std::ostream& operator&lt;&lt;(std::ostream&,
                      const Date&);
     friend std::istream& operator&gt;&gt;(std::istream&,
                                     Date&);
   private:
     int year, month, day;
     int compare(const Date&) const;
     static int daysInPrevMonth(int year, int mon);
   };

   #endif ///:~

   //: C02:Date.cpp {O}
   #include "Date.h"
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt; // for swap()
   #include&lt;ctime&gt;
   #include&lt;cassert&gt;
   #include&lt;iomanip&gt;
   using namespace std;

   namespace {
     const int daysInMonth[][13] = {
       {0,31,28,31,30,31,30,31,31,30,31,30,31},
       {0,31,29,31,30,31,30,31,31,30,31,30,31}};
     inline bool isleap(int y) {
       return y%4 == 0&& y%100 != 0 || y%400 == 0;
     }
   }

   Date::Date() {
     // Get current date
     time_t tval = time(0);
     struct tm *now = localtime(&tval);
     year = now-&gt;tm_year + 1900;
     month = now-&gt;tm_mon + 1;
     day = now-&gt;tm_mday;
   }

   Date::Date(int yr,int mon,int dy) throw(Date::DateError) {
     if (!(1&lt;= mon&& mon&lt;= 12))
       throw DateError("Bad month in Date ctor");
     if (!(1&lt;= dy&& dy&lt;= daysInMonth[isleap(year)][mon]))
       throw DateError("Bad day in Date ctor");
     year = yr;
     month = mon;
     day = dy;
   }

   Date::Date(const std::string& s) throw(Date::DateError) {
     // Assume YYYYMMDD format
     if (!(s.size() == 8))
       throw DateError("Bad string in Date ctor");
     for(int n = 8; --n&gt;= 0;)
       if (!isdigit(s[n]))
         throw DateError("Bad string in Date ctor");
     string buf = s.substr(0, 4);
     year = atoi(buf.c_str());
     buf = s.substr(4, 2);
     month = atoi(buf.c_str());
     buf = s.substr(6, 2);
     day = atoi(buf.c_str());
     if (!(1&lt;= month&& month&lt;= 12))
       throw DateError("Bad month in Date ctor");
   if (!(1&lt;= day&& day&lt;=
     daysInMonth[isleap(year)][month]))
       throw DateError("Bad day in Date ctor");
   }

   int Date::getYear() const { return year; }

   int Date::getMonth() const { return month; }

   int Date::getDay() const { return day; }

   string Date::toString() const {
     ostringstream os;
     os.fill('0');
     os&lt;&lt; setw(4)&lt;&lt; year
       &lt;&lt; setw(2)&lt;&lt; month
       &lt;&lt; setw(2)&lt;&lt; day;
     return os.str();
   }

   int Date::compare(const Date& d2) const {
     int result = year - d2.year;
     if (result == 0) {
       result = month - d2.month;
       if (result == 0)
         result = day - d2.day;
     }
     return result;
   }

   int Date::daysInPrevMonth(int year, int month) {
     if (month == 1) {
       --year;
       month = 12;
     }
     else
       --month;
     return daysInMonth[isleap(year)][month];
   }

   bool operator&lt;(const Date& d1, const Date& d2) {
     return d1.compare(d2)&lt; 0;
   }
   bool operator&lt;=(const Date& d1, const Date& d2) {
     return d1&lt; d2 || d1 == d2;
   }
   bool operator&gt;(const Date& d1, const Date& d2) {
     return !(d1&lt; d2)&& !(d1 == d2);
   }
   bool operator&gt;=(const Date& d1, const Date& d2) {
     return !(d1&lt; d2);
   }
   bool operator==(const Date& d1, const Date& d2) {
     return d1.compare(d2) == 0;
   }
   bool operator!=(const Date& d1, const Date& d2) {
     return !(d1 == d2);
   }

   Date::Duration
   duration(const Date& date1, const Date& date2) {
     int y1 = date1.year;
     int y2 = date2.year;
     int m1 = date1.month;
     int m2 = date2.month;
     int d1 = date1.day;
     int d2 = date2.day;

     // Compute the compare
     int order = date1.compare(date2);
     if (order == 0)
       return Date::Duration(0,0,0);
     else if (order&gt; 0) {
       // Make date1 precede date2 locally
       using std::swap;
       swap(y1, y2);
       swap(m1, m2);
       swap(d1, d2);
     }

     int years = y2 - y1;
     int months = m2 - m1;
     int days = d2 - d1;
     assert(years&gt; 0 ||
        years == 0&& months&gt; 0 ||
        years == 0&& months == 0&& days&gt; 0);

     // Do the obvious corrections (must adjust days
     // before months!) - This is a loop in case the
     // previous month is February, and days&lt; -28.
     int lastMonth = m2;
     int lastYear = y2;
     while (days&lt; 0) {
       // Borrow from month
       assert(months&gt; 0);
       days += Date::daysInPrevMonth(
         lastYear, lastMonth--);
       --months;
     }

     if (months&lt; 0) {
       // Borrow from year
       assert(years&gt; 0);
       months += 12;
       --years;
     }
     return Date::Duration(years, months, days);
   }

   ostream& operator&lt;&lt;(ostream& os, const Date& d) {
     char fillc = os.fill('0');
     os&lt;&lt; setw(2)&lt;&lt; d.getMonth()&lt;&lt;‘-‘
       &lt;&lt; setw(2)&lt;&lt; d.getDay()&lt;&lt;‘-‘
       &lt;&lt; setw(4)&lt;&lt; setfill(fillc)&lt;&lt; d.getYear();
     return os;
   }

   istream& operator&gt;&gt;(istream& is, Date& d) {
     is&gt;&gt; d.month;
     char dash;
     is&gt;&gt; dash;
     if (dash != '-')
       is.setstate(ios::failbit);
     is&gt;&gt; d.day;
     is&gt;&gt; dash;
     if (dash != '-')
       is.setstate(ios::failbit);
     is&gt;&gt; d.year;
     return is;
   } ///:~

   The file test.txt used in Chapter 6:
   //: C06:Test.txt
   f a f d A  G f d F a A F h f A d f f a a
   ///:~

 [Êàðòèíêà: img_15.png] 
   Index
   &lt;
   &lt;exception&gt;· 59
   &lt;memory&gt;· 55
   &lt;stdexcept&gt;· 59
   A
   abort( ): Standard C library function · 46
   abstraction: in program design· 664
   ANSI/ISO C++ committee· 25
   applicator· 231
   applying a function to a container· 289
   arguments: variable argument list· 181
   atof( ) · 209
   atoi( ) · 209
   atomic operation· 763
   auto_ptr· 55
   automatic type conversion: and exception handling· 42
   awk· 234
   B
   bad_cast: Standard C++ library exception type· 61
   bad_exception class· 65
   bad_typeid: Standard C++ library exception type· 61
   before( ): run-time type identification · 607
   behavioral design patterns· 673
   blocking: and threads· 764
   blocking and mutexes· 767
   book errors, reporting· 26
   broadcast( ) · 765
   broadcast( ), threading · 772, 787
   buffering, iostream· 200
   busy wait· 762
   busy wait, threading· 773
   bytes, reading raw· 191
   C
   C: basic data types· 181; error handling in C · 34; rand( ), Standard library · 246; Standard C · 25; Standard C library function abort( ) · 46
   C++: ANSI/ISO C++ committee· 25; Standard C++ · 25; Standard string class · 182
   C++ standards committee: and concurrency· 721
   cancel( ), function in ZThread threading library · 746
   Cancelable, ZThread threading library· 746
   cast: run-time type identification, casting to intermediate levels· 608
   catch· 39, 41; catching any exception · 44
   chaining, in iostreams· 185
   change: vector of change· 664
   character: transforming strings to typed values· 209
   class: class hierarchies and exception handling· 43; maintaining library source · 235; Standard C++ string · 182; wrapping · 176
   cleaning up the stack during exception handling· 48
   cohesion· 71
   command line: interface· 188
   committee, ANSI/ISO C++· 25
   compile time: error checking· 181
   compiler error tests· 240
   composition: and design patterns· 665
   concurrency· 719; blocking · 764; when to use it · 803
   ConcurrentExecutor (Concurrency)· 732
   Condition class, threading· 772
   console I/O· 188
   constructor: and exception handling· 50; default constructor · 696; default constructor synthesized by the compiler · 666; exception handling · 48, 80; failing · 80; order of constructor and destructor calls · 610; private constructor · 666; simulating virtual constructors · 691; virtual functions inside constructors · 692
   conversion, automatic type conversions and exception handling· 42
   cooperation between threads· 771
   Coplien, James· 693
   CountedPtr, reference-counting template in ZThread library (Concurrency)· 743
   covariance: exception specifications· 69
   Crahen, Eric· 722
   creating: manipulators· 230
   creational design patterns· 672
   critical section, in thread programming· 749
   Cygwin: and ZThreads· 724
   D
   data: C data types· 181
   datalogger· 242
   dead, thread· 764
   deadlock: conditions for· 800
   deadlock, concurrency· 750
   deadlock, concurrency (multithreading)· 795
   decimal: dec in iostreams· 225; dec manipulator in iostreams · 225; formatting · 217
   default: constructor· 696
   default constructor: synthesized by the compiler· 666
   design: abstraction in program design· 664; cohesion · 71; exception-neutral · 74; exception-safe · 70
   design patterns· 663; behavioral · 673; creational · 672; observer · 699; structural · 672; vector of change · 664; visitor · 714
   destructor: and exception handling· 48; exception handling · 80; order of constructor and destructor calls · 610
   dining philosophers, threading· 795
   dispatching: double dispatching· 711; multiple dispatching · 710
   domain_error: Standard C++ library exception type· 61
   double dispatching· 711
   dynamic_cast: difference between dynamic_cast and typeid( ), run-time type identification · 609
   E
   efficiency: and threads· 721; run-time type identification · 613
   ellipses, with exception handling· 44
   endl, iostreams· 225
   errno· 34
   error: compile-time checking· 181; error handling in C · 34; handling · 33; recovery · 33; reporting errors in book · 26
   error handling· 33
   exception· 33; and ZThreads (Concurrency) · 737; catching an · 41; catching any · 45; catching by reference · 42; catching via accessible base · 44; handler · 39; rethrowing an · 45, 74; re-throwing an · 45; safety · 70; throwing an · 38; uncaught · 48
   exception class· 58; what( ) · 59
   exception handling· 33; asynchronous events · 76; atomic allocations for safety · 52; automatic type conversions · 42; bad_cast Standard C++ library exception type · 61; bad_exception class · 65; bad_typeid Standard C++ library exception type · 61; catching any exception · 44; class hierarchies · 43; cleaning up the stack during a throw · 48; constructors · 48, 50, 80; destructors · 48, 56, 80; domain_error Standard C++ library exception type · 61; ellipses · 44; exception class · 58; exception class, what( ) · 59; exception handler · 39; exception hierarchies · 79; exception matching · 42;exception Standard C++ library exception type · 60; incomplete objects · 48; inheritance · 43; invalid_argument Standard C++ library exception type · 61; length_error Standard C++ library exception type · 61; logic_error Standard C++ library exception type · 60; memory leaks · 48; multiple inheritance · 79; naked pointers · 50; object slicing and exception handling · 42; out_of_range Standard C++ library exception type · 61; overhead of · 81; programming guidelines · 75; references · 54, 80; resource management · 50; runtime_error class · 58; runtime_error Standard C++ libraryexception type · 60; set_terminate( ) · 46; set_unexpected( ) · 63; specification · 62; specifications and inheritance · 68; specifications, covariance · 69; specifications, when not to use · 70; stack unwinding · 38; Standard C++ library exception type · 60; Standard C++ library exceptions · 58; terminate( ) · 65; termination vs. resumption · 41; testing · 104; throwing& catching pointers· 80; throwing an exception · 37; typical uses of exceptions · 77; uncaught exceptions · 45; unexpected( ) · 63; when to avoid · 75; zero-cost model · 83
   exception hierarchies· 79
   exception neutral· 74
   exception safety· 70
   exception specifications· 62; covariance of · 69; inheritance · 68; when not to use · 70
   exclusion, mutual, in threads· 749
   Executors, ZThread (Concurrency)· 731
   exeption handling: logic_error class· 58
   extensible program· 181
   extractor· 184
   F
   file: iostreams· 182, 188
   FILE, stdio· 177
   fill: width, precision, iostream· 219
   flags, iostreams format· 215
   flock( ), and SynchronousExecutor (Concurrency) · 733
   flush, iostreams· 224, 225
   format flags, iostreams· 215
   formatting: formatting manipulators, iostreams· 224; in-core · 207; iostream internal data · 215; output stream · 214
   fseek( ) · 203
   FSTREAM.H· 197
   function: applying a function to a container· 289; function templates · 279; pointer to a function · 47
   Function-level try blocks· 56
   G
   get pointer· 205
   get( ) · 190, 198; overloaded versions · 191; with streambuf · 202
   getline( ) · 190, 198
   getPriority( ) · 739
   goto: non-local goto, setjmp( ) and longjmp( ) · 35
   graphical user interface (GUI)· 188
   Guard template, ZThread (concurrency)· 750
   GUI: graphical user interface· 188
   H
   handler, exception· 39
   handshaking, between concurrent tasks· 772
   hex· 225
   hex (hexadecimal) in iostreams· 225
   hex( ) · 218
   hexadecimal· 217
   hierarchy: object-based hierarchy· 622
   I
   I/O: and threads, blocking· 767; console · 188
   ifstream· 182, 196, 202
   ignore( ) · 198
   in-core formatting· 207
   inheritance: and design patterns· 664; multiple inheritance and run-time type identification · 608, 611, 619
   initialization: controlling initialization order· 667
   Initialization: Resource Acquisition Is Initialization· 52
   initialization, lazy· 666
   input: line at a time· 188
   inserter· 184
   interface: command-line· 188; graphical user (GUI) · 188; repairing an interface with multiple inheritance · 655
   interfaces: responsive user· 728
   interpreter, printf( ) run-time · 180
   interrupt( ), threading · 765
   interrupted status, threading· 769
   Interrupted_Exception, threading· 769
   invalid_argument: Standard C++ library exception type· 61
   iostream: and threads (concurrency), colliding output· 757
   IOSTREAM.H· 197
   iostreams: applicator· 231; automatic · 219; buffering · 200; dec · 225; dec (decimal) · 225; endl · 225; files · 188;fixed· 227; flush · 224, 225; format flags · 215; formatting manipulators · 224; fseek( ) · 203; get( ) · 198; getline( ) · 198; hex · 225; hex (hexadecimal) · 225; ignore( ) · 198;internal· 226; internal formatting data · 215; ios::basefield · 217; ios::beg · 204; ios::cur · 204;ios::dec· 218; ios::end · 204;ios::fill( )· 220;ios::fixed· 218; ios::flags( ) · 215;ios::hex· 218;ios::internal· 219;ios::left· 219;ios::oct· 218;ios::precision( )· 220;ios::right· 219;ios::scientific· 218;ios::showbase· 216;ios::showpoint· 216;ios::showpos· 216;ios::skipws· 216;ios::unitbuf· 216;ios::uppercase· 216;ios::width( )· 220;left· 226; manipulators, creating · 230;noshowbase· 225;noshowpoint· 226;noshowpos· 226;noskipws· 226;nouppercase· 226; oct (octal) · 225; open modes · 199; precision( ) · 244; rdbuf( ) · 201;resetiosflags· 227;right· 226;scientific· 227; seekg( ) · 204; seeking in · 203; seekp( ) · 204;setbase· 227; setf( ) · 215, 244;setfill· 227;setiosflags· 227;setprecision· 228;showbase· 225;showpoint· 226;showpos· 226;skipws· 226; tellg( ) · 204; tellp( ) · 204;uppercase· 226; width, fill and precision · 219; ws · 225
   istream· 182
   istringstreams· 182
   istrstream· 207
   iterator· 665
   J
   Java: and concurrency/threads· 722
   Josee Lajoie· 84
   K
   keyword: catch· 39
   L
   lazy initialization· 666
   length_error: Standard C++ library exception type· 61
   library: maintaining class source· 235
   LIMITS.H· 234
   line input· 188
   Linux: and ZThreads· 724
   logic_error: Standard C++ library exception type· 60
   logic_error class· 58
   longjmp( ) · 35
   M
   maintaining class library source· 235
   manipulator: creating· 230; iostreams formatting · 224
   memory management, and threads· 740
   modes, iostream open· 199
   modulus operator· 247
   monolithic· 622
   multiple dispatching· 710
   multiple inheritance: and run-time type identification· 608, 611, 619; duplicate subobjects · 635; exception handling · 79; repairing an interface · 655
   multiprocessor machine, and threading· 720
   multitasking· 719
   multithreading· 719; drawbacks · 803
   multithreading library for C++, ZThread· 722
   mutex: ZThread FastMutex· 761
   mutex, simplifying with the Guard template· 750
   mutex, threading· 772
   mutual exclusion, in threads· 749
   N
   naked pointers, and exception handling· 50
   non-local goto: setjmp( ) and longjmp( ) · 35
   notifyObservers( ) · 699, 702
   O
   object: object-based hierarchy· 622; slicing, and exception handling · 42; temporary · 234
   Observable· 699
   observer design pattern· 699
   oct· 225
   ofstream· 182, 196
   open modes, iostreams· 199
   operator: []· 54;&lt;&lt;· 184;&gt;&gt;· 184; modulus · 247
   optimization: throughput, with threading· 720
   order: of constructor and destructor calls· 610
   order, controlling initialization· 667
   ostream· 182, 198
   ostringstreams· 182
   ostrstream· 207
   out_of_range: Standard C++ library exception type· 61
   output: stream formatting· 214
   overhead: exception handling· 81
   P
   Park, Nick· 291
   patterns, design patterns· 663
   perror( ) · 34
   philosophers, dining and threading· 795
   pointer: pointer to a function· 47
   polymorphism· 613
   PoolExecutor (Concurrency)· 732
   precision: width, fill, iostream· 219
   precision( ) · 244
   preprocessor: stringizing· 222
   printf( ) · 180, 214; error code · 33; run-time interpreter · 180
   priority, thread· 738
   private: constructor· 666
   process, and threading· 719
   producer-consumer, threading· 777
   put pointer· 204
   Q
   queues, thread, for problem-solving· 781
   R
   race condition· 746
   RAII· 52, 56
   raise( ) · 34
   rand( ) · 246
   RAND_MAX· 247
   raw, reading bytes· 191
   rdbuf( ) · 201
   read( ) · 191
   reading raw bytes· 191
   reference: and exception handling· 80; exception handling · 54
   reference counting, and ZThreads (Concurrency)· 741
   reporting errors in book· 26
   Resource: Acquisition Is Initialization· 52
   Resource Acquisition Is Initialization· 52
   responsive user interfaces· 728
   resumption: termination vs. resumption, exception handling· 41
   rethrow: an exception· 45; exception · 74
   Runnable· 724
   run-time interpreter for printf( ) · 180
   run-time type identification· 599; and efficiency · 613; and multiple inheritance · 608, 611, 619; and templates · 610; and void pointers · 609; before( ) · 607; casting to intermediate levels · 608; difference between dynamic_cast and typeid( ) · 609; mechanism& overhead· 619; misuse · 612; typeinfo · 619; VTABLE · 619; when to use it · 612
   runtime_error: Standard C++ library exception type· 60
   S
   Scott Meyers· 84
   sed· 234
   seekg( ) · 204
   seeking in iostreams· 203
   seekp( ) · 204
   serialization· 247
   serialization, thread· 781
   set: STL set class example· 475
   set_terminate( ) · 46
   set_unexpected( ) · 63; exception handling · 63
   setChanged( ) · 702
   setf( ), iostreams · 215, 244
   setjmp( ) · 35
   setPriority( ) · 740
   signal( ) · 34, 76, 764
   signal( ), threading · 772
   simulating virtual constructors· 691
   Singleton· 665; and ZThreads library (concurrency) · 758; implemented with Curiously Recurring Template Pattern · 670; Meyers’ Singleton · 669
   sleep( ) · 764; threading · 736
   slicing: object slicing and exception handling· 42
   Smalltalk· 622
   specification: exception· 62
   stack unwinding· 38
   standard: Standard C· 25; Standard C++ · 25
   Standard C++ libraries: string class· 182
   Standard C++ library: standard library exception types· 58
   standard template library: set class example· 475
   stdio· 176
   STDIO.H· 195
   stream· 182; output formatting · 214
   streambuf· 201; and get( ) · 202
   streampos, moving· 203
   string: Standard C++ library string class· 182; transforming character strings to typed values · 209
   stringizing, preprocessor· 222
   strstream· 207
   structural design patterns· 672
   subobject: duplicate subobjects in multiple inheritance· 635
   subtasks· 719
   synchronization: (concurrency) example of problem from lack of synchronization· 762; and blocking · 765
   synchronization, thread· 748
   Synchronization_Exception (Concurrency)· 731
   Synchronization_Exception, in ZThread library· 727
   synchronized: threading, wrapper for an entire class· 753
   SynchronousExecutor (Concurrency)· 733
   T
   task: defining for threading· 724
   tellg( ) · 204
   tellp( ) · 204
   template: and run-time type identification· 610; function templates · 279
   temporary: object· 234
   terminate( ) · 46, 65; uncaught exceptions · 45
   terminating threads· 765
   termination: vs. resumption, exception handling· 41
   termination problem, concurrency· 757
   thread· 719; atomic operation · 763; blocked · 764; blocking and mutexes · 767; broadcast( ) · 765, 773, 787; busy wait · 762, 773; Cancelable class from ZThread libaray · 746; colliding over resources, improperly accessing shared resources · 744; Condition class for wait() and signal() · 772; cooperation · 771; dead state · 764; deadlock · 750, 795; deadlock, and priorities · 738; dining philosophers · 795; drawbacks · 803; example of problem from lack of synchronization · 762; getPriority( ) · 739; handshaking between tasks · 772; I/O and threads, blocking · 767; interrupt( ) · 765; interrupted status · 769; Interrupted_Exception · 769; iostreams and colliding output · 757; memory management · 740; multiple, for problem-solving · 772; mutex, for handshaking · 772; mutex, simplifying with the Guard template · 750; new state · 764; order of task shutdown · 746;order of thread execution · 737; priority · 738; producer-consumer · 777; queues solve problems · 781; race condition · 746; reference counting · 741; reference-counting with CountedPtr · 743; runnable state · 764; serialization · 781; setPriority( ) · 740; sharing resources · 740; signal( ) · 764, 772; sleep( ) · 736, 764; states · 764; synchronization · 748; synchronization and blocking · 765; synchronized wrapper for an entire class · 753; termination · 765; termination problem · 757; thread local storage · 754; threads and efficiency · 721; TQueue, solving threading problems with · 781; wait( ) · 764, 772; when to use threads · 803; yield( ) · 734; ZThread FastMutex · 761
   thread object, concurrency· 726
   thread, and concurrency· 719
   ThreadedExecutor (Concurrency)· 731
   throughput, optimize· 720
   throw· 37, 38
   throwing an exception· 37
   TQueue, solving threading problems with· 781
   transforming character strings to typed values· 209
   try· 38; Function-level try blocks · 56
   try block· 38; function-level · 56
   type: automatic type conversions and exception handling· 42; run-time type identification (RTTI) · 599
   typeid( ): difference between dynamic_cast and typeid( ), run-time type identification · 609
   typeinfo: structure· 619
   U
   ULONG_MAX· 234
   uncaught exceptions· 45
   uncaught_exception( )· 75
   unexpected( ) · 63
   Unix· 234
   Urlocker, Zack· 660
   user interface: responsive, with threading· 720, 728
   V
   value: transforming character strings to typed values· 209
   Van Rossum, Guido· 804
   variable: variable argument list· 181
   vector of change· 664
   virtual: simulating virtual constructors· 691; virtual functions inside constructors · 692
   visitor pattern· 714
   void: void pointers and run-time type identification· 609
   VPTR· 692
   VTABLE· 692; and run-time type identification · 619
   W
   wait( ), threading · 764, 772
   web servers, multiprocessor· 721
   wrapping, class· 176
   write( ) · 191
   ws· 225
   Y
   yield( ), threading · 734
   Z
   ZThread: Cancelable class· 746; Executors · 731; installing the library · 723; multithreading library for C++ · 722
   Notes
   1
   You might be surprised when you run the example—some C++ compilers have extendedlongjmp( ) to clean up objects on the stack. This behavior is not portable.
   2
   Visual Basic supports a limited form of resumptive exception handling with its ON ERROR facility.
   3
   In fact, you might want to always specify exception objects byconst reference in exception handlers. It’s very rare to modify and rethrow an exception. We are not dogmatic about this practice however.
   4
    Onlyunambiguous, accessible base classes can catch derived exceptions. This rule minimizes the runtime overhead needed to validate exceptions. Remember that exceptions are checked at runtime, not at compile time, and therefore the extensive information available at compile time is not available during exception handling
   5
    For more detail onauto_ptr, see Herb Sutter’s article entitled, "Using auto_ptr Effectively" in the October 1999 issue of theC/C++ Users Journal, pp. 63–67.
   6
   If you’re interested in a more in-depth analysis of exception safety issues, the definitive reference is Herb Sutter’sExceptional C++, Addison-Wesley, 2000.
   7
   The library functionuncaught_exception( ) returnstrue in the middle of stack unwinding, so technically you can testuncaught_exception( ) forfalse and let an exception escape from a destructor. We’ve never seen a situation in which this constituted good design, however, so we only mention it in this footnote.
   8
   Some compilers do throw exceptions in these cases, but they usually provide a compiler option to disable this (unusual) behavior.
   9
   This depends, of course, on how much checking of return codes you would have to insert if you weren’t using exceptions.
   10
   Borland enables exceptions by default; to disable exceptions use the-x- compiler option. Microsoft disables support by default; to turn it on, use the-GX option. With both compilers use the-c option to compile only.
   11
   The GNU C++ compiler uses the zero-cost model by default. Metrowerks Code Warrior for C++ also has an option to use the zero-cost model.
   12
   Thanks to Scott Meyers and Josee Lajoie for their insights on the zero-cost model. You can find more information on how exceptions work in Josee’s excellent article, "Exception Handling: Behind the Scenes,"C++ Gems, SIGS, 1996.
   13
   Among other things he invented Quicksort.
   14
   As quoted inProgramming Language Pragmatics, by Michael L. Scott, Morgan-Kaufmann, 2000.
   15
   See his book,Object-Oriented Software Construction, Prentice-Hall, 1994.
   16
   This is still an assertionconceptually, but since we donâ€™t want to halt execution, theassert(Â ) macro is not appropriate. Java 1.4, for example, throws an exception when an assertion fails.
   17
   There is a nice phrase to help remember this phenomenon:â€œRequire no more; promise no less,â€ first coined inC++ FAQs, by Marshall Cline and Greg Lomow (Addison-Wesley, 1994). Since pre-conditions can weaken in derived classes, we say that they arecontravariant, and, conversely, post-conditions arecovariant (which explains why we mentioned the covariance of exception specifications in Chapter 1).
   18
   This section is based on Chuckâ€™s article, â€œThe Simplest Automated Unit Test Framework That Could Possibly Workâ€, C/C++ Users Journal, Sept. 2000.
   19
   A good book on this subject is Martin Fowler'sRefactoring: Improving the Design of Existing Code (Addison-Wesley, 2000). See alsowww.refactoring.com. Refactoring is a crucial practice of Extreme Programming (XP).
   20
   Lightweight methodologies such as XP haveâ€œjoined forcesâ€ in the Agile Alliance (see http://www.agilealliance.org/home).
   21
   Our Date class is alsoâ€œinternationalizedâ€, in that it supports wide character sets. This is introduced at the end of the next chapter.
   22
   Seehttp://sourceforge.net/projects/cppunit for more information.
   23
   â€œRuntime Type Identificationâ€, discussed in chapter 9. Specifically, we use thename(Â ) member function of thetypeinfo class. By the way, if you're using Microsoft Visual C++, you need to specify the compile option/GR. If you don't, you'll get an access violation at runtime.
   24
   In particular, we usestringizing (via the# operator) and the predefined macros__FILE__ and__LINE__. See the code later in the chapter.
   25
   Batch files and shell scripts work well for this, of course. TheSuite class is a C++-based way of organizing related tests.
   26
   Our key technical reviewer, Pete Becker of Dinkumware. Ltd., brought to our attention that it is illegal to use macros to replace C++ keywords. His take on this technique was as follows:â€œ"This is a dirty trick. Dirty tricks are sometimes necessary to figure out why code isn't working, so you may want to keep this in your toolbox, but don't ship any code with it." Caveat programmer :-).
   27
   Thanks to Reg Charney of the C++ Standards Committee for suggesting this trick.
   28
   Some of the material in this chapter was originally created by Nancy Nicolaisen.
   29
   Itâ€™s difficult to make reference-counting implementations thread safe. (See Herb Sutter,More Exceptional C++, pp. 104â€"14). See Chapter 10 for more on programming with multiple threads.
   30
   It as an abbreviation forâ€œno position.â€
   31
   Discussed in depth in Chapter 6.
   32
   To keep the exposition simple, this version does not handle nested tags, such as comments.
   33
   It is tempting to use mathematics here to factor out some of these calls toerase(Â ), but since in some cases one of the operands isstring::npos (the largest unsigned integer available), integer overflow occurs and wrecks the algorithm.
   34
   Alert: For the safety reasons mentioned, the C++ Standards Committee is considering a proposal to redefinestring::operator[] to behave identically tostring::at() for C++0x.
   35
   Your implementation can define all three template arguments here. Because the last two template parameters have default arguments, such a declaration is equivalent to what we show here.
   36
   Beware that some versions of Microsoft Word erroneously replace single quote characters with an extended ASCII character when you save a document as text, which of course causes a compile error. We have no idea why this happens. Just replace the character manually with an apostrophe.
   37
   POSIX, an IEEE standard, stands forâ€œPortable Operating System Interfaceâ€ and is a generalization of many of the low-level system calls found in UNIX systems.
   38
   The implementation and test files for FULLWRAP are available in the freely distributed source code for this book. See the preface for details.
   39
   Explained in depth in Chapter 5.
   40
   For this reason, we can writeios::failbit instead ofios_base::failbit to save typing.
   41
   It is customary to useoperator void*(Â ) in preference tooperator bool(Â ) because the implicit conversions frombool toint may cause surprises, should you errantly place a stream in a context where an integer conversion can be applied. Theoperator void*(Â ) function will only implicitly be called in the body of a Boolean expression.
   42
   An integral type used to hold single-bit flags.
   43
   A more in-depth treatment of stream buffers and streams in general can be found in Langer& Kreftâ€™s,Standard C++ IOStreams and Locales, Addison-Wesley, 1999.
   44
   For more information on machine epsilon and floating-point computation in general, see Chuckâ€™s article, â€œThe Standard C Library, Part 3â€,C/C++ Users Journal, March 1995, also available at www.freshsources.com/1995006a.htm.
   45
   Before puttingnl into a header file, make it aninline function (see Chapter 7).
   46
   Jerry Schwarz is the designer of iostreams.
   47
   See the Langer& Kreft book mentioned earlier for more detailed information.
   48
   See, for example, Dinkumwareâ€™s Abridged library at www.dinkumware.com. This library omits locale support. and exception support is optional.
   49
   Vandevoorde and Josuttis,C++ Templates: The Complete Guide, Addison-Wesley, 2003.
   50
   The C++ standards committee is considering relaxing the only-within-a-template rule for these disambiguation hints, and some compilers are allowing then in non-template code already.
   51
   See Stroustrup,The C++ Programming Language, 3rd Edition, Addison-Wesley, pp. 335-336.
   52
   Technically, comparing two pointers not inside the same array is undefined behavior, but compilers nowadays donâ€™t complain about this. All the more reason to do it right.
   53
   We are indebted to Nathan Myers for this example.
   54
   Such as type information encoded in a decorated name.
   55
   C++ compilers can introduce names anywhere they want, however. Fortunately, most donâ€™t declare names they donâ€™t need.
   56
   If youâ€™re interested in seeing the proposal, itâ€™s Core Issue 352.
   57
   A reference to the British animated short featureThe Wrong Trousers by Nick Park.
   58
   We discussvector&lt;bool&gt; in depth in Chapter 7.
   59
   Since the forwarding functions are inline, no code is generated at all!
   60
   Also calledKoenig lookup, after Andrew Koenig, who first proposed the technique to the C++ standards committee. ADL applies universally, whether templates are involved or not.
   61
   In a talk given atThe C++ Seminar, Portland, OR, September, 2001.
   62
   Another template idiom, mixin inheritance, is covered in Chapter 9.
   63
   The fact thatchar_traits&lt;&gt;::compare(Â ) may callstrcmp(Â ) in one instance vs.wcscmp(Â ) in another, for example, is immaterial to the point we make here: the function performed bycompare(Â ) is the same.
   64
   Modern C++ Design: Generic Programming and Design Patterns Applied, Addison-Wesley, 2001.
   65
   C++ Gems, edited by Stan Lippman, SIGS, 1996.
   66
   Floating-point values are not compile-time constants, and therefore cannot be used in compile-time arithmetic.
   67
   In 1966 BÃ¶hm and Jacopini proved that any language supporting selection and repetition, along with the ability to use an arbitrary number of variables, is equivalent to a Turing machine, which can implement any algorithm.
   68
   Czarnecki and Eisenecker,Generative Programming: Methods, Tools, and Applications, Addison-Wesley, 2000, p. 417.
   69
   There is a much better to compute powers of integers, of course (viz., the Russian Peasant Algorithm), but that is beside the point here.
   70
   Modern C++ Design, pp. 23-26.
   71
   You actually are not allowed to pass object types (other than built-ins) to an ellipsis parameter specification, but since we are only asking for its size (a compile-time operation), the expression is never actually evaluated at runtime.
   72
   A reprint of Toddâ€™s original article can be found in Lippman,C++ Gems, SIGS, 1996.
   73
   See his and Nicoâ€™s book,C++ Templates, book cited earlier.
   74
   Namely, Blitz++ (http://www.oonumerics.org/blitz/), the Matrix Template Library (http://www.osl.iu.edu/research/mtl/), and POOMA (http://www.acl.lanl.gov/pooma/).Â 
   75
   We meanâ€œvectorâ€ in the mathematical sense, as a fixed-length, one-dimensional, numerical array.
   76
   Langer and Kreft,â€œC++ Expression Templatesâ€,C/C++ Users Journal, March 2003. See also the article on expression templates by Thomas Becker in the June 2003 issue of the same journal, and which was the inspiration for the material in this section.
   77
   As explained earlier, you must explicitly instantiate a template only once per program.
   78
   Visit http://www.bdsoft.com/tools/stlfilt.html.
   79
   Or something that is callable as a function, as youâ€™ll see shortly.
   80
   This is simply an English rendition ofO(n log n), which is the mathematical way of saying that for largen, the number of comparisons grows in direct proportion to the functionf(n) = n log n.
   81
   Unless you do something ungainly like use global variables.
   82
   Function objects are also calledfunctors, after a mathematical concept with similar behavior.
   83
   All standard iterators define a number of nested types, includingvalue_type, which represents the type the iterator refers to. See Chapter 7 for more detail.
   84
   If a compiler were to definestring::empty with default arguments (which is allowed), then the expression&string::empty would define a pointer to a member function taking the total number of arguments. Since there is no way for the compiler to provide the extra defaults, there would be aâ€œmissing argumentâ€ error when an algorithm appliedstring::empty viamem_fun_ref.
   85
   STLPort, for instance, which comes with version 6 of Borland C++ Builder and is based on SGI STL.
   86
   Thestable_sort(Â ) algorithm usesmergesort, which is indeed stable, but tends to run slower thanquicksort on average.
   87
   Iterators are discussed in more depth in the next chapter.
   88
   Algorithms can determine the type of an iterator by reading itstag, discussed in the next chapter.
   89
   Weâ€™re ignoring the copy constructor and assignment operator in this example, since they donâ€™t apply.
   90
   Without violating any copyright laws, of course.
   91
   Visithttp://www.dinkumware.com, http://www.sgi.com/tech/stl, or http://www.stlport.org.
   92
   The container adaptors, stack, queue, and priority_queue do not support iterators, since they do not behave as sequences from the userâ€™s point of view.
   93
   It will only work for implementations of vector that uses apointer (aT*) as the iterator type, like STLPort does.
   94
   These were actually created to abstract theâ€œlocaleâ€ facets away from iostreams, so that locale facets could operate on any sequence of characters, not only iostreams. Locales allow iostreams to easily handle culturally-different formatting (such as the representation of money) and are beyond the scope of this book.
   95
   You will need to provide achar_traits specialization for any other argument type.
   96
   We are indebted to Nathan Myers for explaining this.
   97
   This is another example coached by Nathan Myers.
   98
   For a detailed explanation of this oddity, see Items 6 and 29 in Scott Meyerâ€™sEffective STL.
   99
   We revisit multi-threading issues in Chapter 11.
   100
   Chuck designed and provided the original reference implementations forbitset and alsobitstring, the precursor tovector&lt;bool&gt;, while an active member of the C++ standards committee in the early 1990s.
   101
   They will likely appear in the next revision of Standard C++.
   102
   Available at http://www.sgi.com/tech/stl.
   103
   As we explained earlier, thevector&lt;bool&gt; specialization is also a non-STL container to some degree.
   104
   With Microsoftâ€™s compilers you will have to enable RTTI; itâ€™s disabled by default. The command-line option enable it is/GR.
   105
   Compilers typically insert a pointer to a classâ€™s RTTI table inside of its virtual function table.
   106
   Adynamic_cast&lt;void*&gt; always gives the address of the full objectâ€"not a subobject. This will be explained more fully in the next chapter.
   107
   Even more importantly, we donâ€™t want undefined behavior. It is an error for a base class not to have a virtual destructor.
   108
   The actual layout is of course implementation specific.
   109
   But not detected as an error.Â dynamic_cast, however can solve this problem. See the next chapter for details.
   110
   Compilers can add arbitrary padding, so the size of an object must be at least as large as the sum of its parts, but can be larger.
   111
   We use the termhierarchy because everyone else does, but the graph representing multiple inheritance relationships is in general adirected acyclic graph (DAG), also called alattice, for obvious reasons.
   112
   The presence of these pointers explains why the size ofb is much larger than the size of four integers.Â  This is (part of) the cost of virtual base classes. There is also VPTR overhead due to the virtual constructor.
   113
   Note that the virtual inheritance is crucial to this example. IfTop were not a virtual base class, there would be multipleTop subobjects, and the ambiguity would remain. Dominance with multiple inheritance only comes into play with virtual base classes.
   114
   Jerry Schwarz, the author of IOStreams, has remarked to both of us on separate occasions that if he had it to do over again, he would probably remove MI from the design of IOStreams and use multiple stream buffers and conversion operators instead.
   115
   A phrase coined by Zack Urlocker.
   116
   Also known as theâ€œGang of Fourâ€ book (GoF). Conveniently, the examples are in C++.
   117
   The C++ standards states:â€œNo translation unit shall contain more than one definition of any variable, function, class type, enumeration type or templateâ€¦ Every program shall contain exactly one definition of every non-inline function or object that is used in that program.â€
   118
   This is known as Meyersâ€™ Singleton, after its creator, Scott Meyers.
   119
   Andrei Alexandrescu develops a superior, policy-based solution to implementing the Singleton pattern inModern C++ Design.
   120
   For more information, see the articleâ€œOnce is Not Enoughâ€ by Hyslop and Sutter in the March 2003 issue ofCUJ.
   121
   For up-to-date information, visit http://hillside.net/patterns.
   122
   James O. Coplien,Advanced C++ Programming Styles and Idioms, Addison-Wesley, 1992.
   123
   It differs from Java in thatjava.util.Observable.notifyObservers(Â ) doesn't callclearChanged(Â ) until after notifying all the observers
   124
   There is some similarity between inner classes andsubroutine closures, which save the reference environment of a function call so it can be reproduced later.
   125
   Much of this chapter began as a translation from theConcurrencychapter inThinking in Java, 3rd edition, Prentice Hall 2003.
   126
   This is an oversimplification. Sometimes even when it seems like an atomic operation should be safe, it may not be, so you must be very careful when deciding that you can get away without synchronization. Removing synchronization is often a sign of premature optimizationâ€" things that can cause you a lot of trouble without gaining much. Or anything.
   127
   This is in contrast to Java, where you must hold the lock in order to callnotify() (Javaâ€™s version ofsignal()). Although Posix threads, on which the ZThread library is loosely based, do not require that you hold the lock in order to callsignal() orbroadcast(), it is often recommended.
   128
   At the time of this writing, Cygwin (www.cygwin.com) was undergoing much-needed changes and improvements to its threading support, but we were still unable to observe deadlocking behavior with this program under the available version of Cygwin. The program deadlocked quickly under, for example, Linux.

Âçÿòî èç Ôëèáóñòû, http://flibusta.net/b/215819
